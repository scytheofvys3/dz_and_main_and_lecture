import this # импорт Дзен питона
print("Hello World") # =str-string строка

print(type(5)) # тип числа =int-integer - целое число
print(type(2.1)) # тип числа =float число с плавающей запятой
print(type("Stro4ka")) # тип данных =str-string строка

# concatenate - связывает, сцепляет, соединяет оператор +, но одинаковые объекты
# запятая в командах "," говорит о том, что элемент закончился и сейчас будет другой

print(78 % 33) # сколько в число 78 помещается число 33 получим остаток от этого/остаток от деления
print(78 / 33) # деление с плавающей запятой =float
print(78 // 33) # деление с ответом без запятой =int-integer
print(7 % 7) # сколько в число 7 поместится число 7, если поместилось, то это 0

print(5 ** 3) # степень

#boolean - тип данных "примитивно" да-нет, истина-ложь # если функция возвращает true/false, то это можно использовать в ветвлениях или функция(не точно)
print(type(True),type(False))
print(5 == 5, 5 > 2, 3 < 1, 5 != 5, 5 != 4) # == - они равны?, != - они не равны?

'''команда and= и, or= или'''

# and= и - если все условия с двух сторон равны, то все выражения считаются истинными
# and= и - чтобы получить «True», должны быть истинны оба выражения
'СТРОГИЙ ОПЕРАТОР'
print(5 == 5 and 5 != 5)
print(10 == 10 and 6 > 3)

# or= или - выражение ложно, если оно с двух сторон ложно, если одно из них истинное, то все выражения истинно
# or= или, чтобы получить «True» достаточно, чтобы истинным было хотя бы одно.
'НЕ СТРОГИЙ ОПЕРАТОР'
print(5 == 5 or 5 != 5)
print(5 > 6 or 6 > 7 )

# Перевод данных в другой тип. Текстовую пятерку перевел в число и также наоборот в строку. Код расшифровывается справа налево.
print(type(int("5")))
print(type(str(5)))

## DZ 1
# 1st program
print(9 ** 0.5 * 5)
# 2nd program
print(9.99 > 99.98 or 1000 != 1000.1)
# 3rd program
print(2 * 2 + 2 == 2 * (2 + 2))
# 4th program
print(int(float ('123.456')* 10 % 10))

# Функция abs в Python возвращает абсолютное значение числа. Таким образом результат всегда положительный.
# На вход функция принимает: целые числа; числа с плавающей точкой; комплексные числа.
# Пример работы функции:
# abs(-20) # => 20
# abs(-20.5) # => 20.5
# abs(3 + 4j) # => 5.0


# Динамическая типизация - это смена типа данных в переменной
# Оператор = присваивает переменной (прим. Name) тип данных, то есть переменная name ссылается на значение Urban
# Получается, что правый объект присваивает себе некую переменную(левое значение), которую в дальнейшем можно использовать
name1 = 'Urban'
print(name1, type(name1))
name1 = 5
print(name1, type(name1))
name1 = 2.2
print(name1, type(name1))

name01 = 5
name01 = 6
print(name01 + name01) # Запомнит он последний объект привязанный к одной переменной

## DZ 2
name = 'Ilya'
print(name, type(name))
age = 24
print(age,type(age))
age = age + 24
print(age,type(age))
is_student = True
print(is_student, type(is_student))

# Переменная - хранит в себе информацию к которой мы можем обращаться в дальнейшей работе
# Важно, чтобы переменная носила осмысленное название и была эксклюзивной (не была названа другой командой)
# Snake case - название переменной пишется через нижнее подчеркивание (для читаемости и быстрого понимания) - data_of_brith
# Camel case - название переменной пишется с заглавной буквы (каждое слово) - dataOfBrith
## Мне больше понравился стиль snake case, в дальнейшем иногда можно путать ноль и букву О

a, b, c = 1, 2, 3 # Множественное присваивание - присвоить сразу несколько значений в одной строке
print(c + b * a)

a =  b = c = 67 # Каскадное присваивание - то есть a = b = c, а все перечисленные переменные содержат объект int-integer 67
print(a + b + c)

d = list ('Begin') # Преобразование строки в список по символам - (пока не знаю для чего)
print(d)

list1 = [5, 3, 1] # Множественное присваивание со списками (Пока не очень понимаю для чего это)
a, b, c = list1

# DZ 3
completed_dz = 12 # Выполнено заданий
hours_spent = 1.5 # Время на одно задание
name_cource = 'Python' # Название курса
time_one_job = int (completed_dz / hours_spent) # Время на выполнение одного задания

print("Курс:", name_cource,",","Затраченное время на одно задание:", hours_spent,",","Среднее время на выполнения одного задания:", time_one_job, "ч.")

name = "IlyaNefedov"
print('Hello, ' * 2 + name) # Дублирование строки через оператор *

# Индексация строки у каждой строки есть свой порядковый индекс начинается он с нуля
# Так же можно выводить и последнюю букву начиная с -1 (последняя буква), -2 (предпоследняя буква) и так далее.
print(name [0]) # нулевой индекс принимается как первая буква и так далее
print(name [-1]) # индекс со знаком минус выводит буквы с конца
print(name [0:5]) # срез строки последний элемент не выводится, то есть получается 0 - 4 (в данном случае)
print(name [0:8:2]) # 0 начало, 8 конец, 2 шаг # выведет нам с 0 индекса по 8 (не включительно) с шагом 2
# Так же мы можем пропускать начальное и последние значение
print(name [:11]) # мы пропустили первое значение, но указали конечное, он сам понял, что не указанное это начало
print(name [:5]) # мы пропустили первое значение, но указали конечное, он сам понял, что не указанное это начало
print(name [0:]) # мы указали первое, но не указали конечное, поэтому для него конечное это конец строки
print(name [4:]) # мы указали первое, но не указали конечное, поэтому для него конечное это конец строки
print(name [::-1]) # срез с конца строки с шагом 1, мы не указали начальное и конечно, поэтому эти значения равны началу и концу строки
print(name [::1]) # срез с начала строки с шагом 1, мы не указали начальное и конечно, поэтому эти значения равны началу и концу строки
print(name [-1:-10:-2]) # срез с конца строки, но в начале, до 10 индекса с шагом два, обратный порядок

cc = "HelloWorld"
# Индексация строки:
#  H  e  l  l  o  W  o  r  l  d
#  0  1  2  3  4  5  6  7  8  9  (прямые индексы)
# -10 -9 -8 -7 -6 -5 -4 -3 -2 -1 (отрицательные индексы)

print(cc[-4:])  # Результат: "orld"

# DZ 4
example = 'AnString'
print(example [0]) # Первый символ в строке
print(example [-1]) # Последний символ в строке с использованием обратного индекса
print(example [3:]) # Вторая половина строки с нечетным кол-во букв
print(example [::-1]) # Слово наоборот
print(example [::2]) # Каждый второй индекс в строке с использованием шага

##name = input('Введите свое имя: ') # команда input говорит о том, что пользователю нужно ввести данные с клавиатуры
##current_data = 2024 # год на данный момент
##data_of_brith = int (input ('Ваш год рождения: ')) #год рождения юзера, команда int, которая преобразует ВВОД в число
### тк как изначально ВВОДИМЫЕ ДАННЫЕ имеют класс str-string строка
##age = current_data - data_of_brith # год на данный момент минус год рождения юзера
##print ('Добро пожаловать,',name) # выводи приветствия и имя юзера
##print ('В этом году вам исполнилось',age, 'года/лет' ) # выводит строку сколько лет исполнилось юзеру и переменную age
#^^^^ обычная программа, которая считает возраст юзера (без месяца и дня)


print('я строка в нижнем регистре'.replace('строка','человек'))
#заменили слово строка на человек
print('я строка в нижнем регистре'.replace('строка','Человек').replace('я','В').replace(' ','-'))
#замена нескольких слов в строке
print('я строка в нижнем регистре'.replace(' ','.')) #заменили символ ПРОБЕЛ ( ) на символ ТОЧКУ
# Метод .upper() - переводит текст в Верхний регистр
# Метод .lower() - переводит текст в Нижний регистр
# Метод .replace('что заменить','на что заменить') - заменяет выбранное слово на другое
# Метод .isdigit() возвращает True, если все символы в строке являются цифрами. Если нет, возвращается False.
# isdigit = is(является)digit(цифрой) - является цифрой

# Метод .title() делает каждую первую букву слова заглавной, при этом все остальные буквы переводятся в нижний регистр

# Метод .istitle() Вернёт True , если в строке хотя бы один символ или все слова в строке начинаются с заглавных букв, иначе — False .

# isupper() — метод строки, который проверяет, является ли все символы строки заглавными буквами.
# Он возвращает True, если все символы в строке (кроме символов, которые не являются буквами)
# находятся в верхнем регистре. Если хотя бы один символ в строке не является заглавным,
# метод вернет False.

# # Проверяем, что пароль содержит хотя бы одну заглавную букву и хотя бы одну цифру.
#         # any(i.isupper() for i in password) — проверяет, есть ли хотя бы одна заглавная буква в строке:
#         #     - i.isupper() возвращает True для каждого символа, который является заглавной буквой.
#         #     - any() возвращает True, если хотя бы один символ строки является заглавной буквой.
#         # any(i.isdigit() for i in password) — проверяет, есть ли хотя бы одна цифра в строке:
#         #     - i.isdigit() возвращает True для каждого символа, который является цифрой.
#         #     - any() возвращает True, если хотя бы один символ строки является цифрой.
#         # Если оба условия выполняются, продолжаем проверку и сравниваем пароль с подтверждением.
#         if any(i.isupper() for i in password) and any(i.isdigit() for i in password):

# Метод .split() разделяет строку на подстроки
##sep — разделитель, по которому разбивается исходная строка.
# По умолчанию или при указании None разделителями будут считаться любые пробельные символы
# (пробел, перевод строки, табуляция и другие).
##maxsplit — параметр, который определяет максимальное количество разбиений.
# По умолчанию (или если указано -1) строка разбивается полностью на все возможные подстроки.

#DZ 5
##my_string = input ('Введите произвольный текст:') # ввод текста в формате данных str
##print('Кол-во символов в строке:',len(my_string)) # функция len подсчитывает кол-во элементов
##print(my_string .upper()) # изменяем текст на верхний регистр
##print(my_string .lower()) # изменяем текст на нижний регистр
##print(my_string .replace(' ', '')) # удалям ПРОБЕЛЫ на ничего
##print(my_string [0:1]) # вывод первого символа в строка
##print(my_string [-1]) # вывод последнего символа в строке
#Здесь должен быть текст посвященный университету урбан

# СПИСКИ
# list_
food = ['apple', 'coco', 'banana', 'cherry', 2] # в квадратных скобках хранятся элементы списка
# то есть у каждого элемента есть порядковый номер он же - индекс
print(food[3]) # нумерация начинается с нуля, как и любой индекс
food [0] = 'beef'# замена нулевого индекса(то есть первого слова) на другое слово
food [2] = 2024 # замена второго индекса(то есть третьего слова) на другой элемент
# списки изменяемые, то есть их можно менять
print(food)
# функция len подсчитывает кол-во элементов, если элементы будут в списке она посчитает сколько элементов в списке

food.append(True)  # Добавляем элемент True в конец списка.
# Метод append(присоединить/добавить) добавляет только один элемент в конец списка.
# Если нужно сохранить список или кортеж как отдельный объект, используйте append.
# Синтаксис: list.append(элемент).
# .append - присоединить/добавить

food.append('pear')  # Добавляем строку 'pear' в конец списка.
# Элемент может быть любым типом данных (число, строка, булевое значение и т.д.).

food.extend('True')  # Добавляем строку 'True'. Каждый символ добавляется как отдельный элемент.
# Результат: food = [..., 'T', 'r', 'u', 'e'].

food.extend(['True', 2, 'Foll'])  # Добавляем элементы списка ['True', 2, 'Foll'] в конец.
# Результат: food = [..., 'T', 'r', 'u', 'e', 'True', 2, 'Foll'].
# Синтаксис: list.extend(iterable)
# Когда мы добавляем элементы с помощью метода extend, он не создает вложенный список или кортеж.
# Вместо этого он добавляет элементы из переданного итерируемого объекта (например, списка или кортежа) по одному.
# - Если iterable — строка: каждый символ строки добавляется как отдельный элемент.
# - Если iterable — список или кортеж: все элементы добавляются по одному.
# - Если iterable — множество: элементы добавляются в произвольном порядке.
# - Если iterable — словарь: добавляются только ключи.
# .extend - продлить/расширить

# Отличие append от extend:
# - append добавляет объект целиком как один элемент: my_list.append([4, 5]) -> [..., [4, 5]].
# - extend распаковывает объект и добавляет его элементы по одному: my_list.extend([4, 5]) -> [..., 4, 5].
# Если нужно добавить строку или список как один элемент, используйте append.

food.remove('cherry')  # Удаляем первый найденный элемент 'cherry' из списка.
# Метод remove удаляет первый элемент с указанным значением.
# Если элемента нет, возникает ошибка ValueError.

print("beef" in food) # командой in(в) можно проверять если элемент в списке
print('beeed' in food)
# данную команду можно расшифровывать как - если ли "слово (in) в списке?"
print('coco' not in food) # командой not in(не в) можно проверить отсутствие элемента в списке
print('peaar' not in food)
# данную команду можно расшифровывать как - "слово не в списке"?
print(food [-1::-1]) # так же мы можем проводить индексация со списком
print(food)

#Как копировать список:
# С помощью метода copy:
# new_list = original_list.copy()
#
# С помощью среза [:]:
# new_list = original_list[:]
#
# С помощью функции list:
#
# new_list = list(original_list)
# Все эти способы создают новый список, независимый от оригинала.

# Кортеж
# tuple - (тайпл) - кортеж - неизменяемый список, может содержать разные типы данных, так же как и список
# тот же самый список, но не изменяемый. нельзя изменить, удалить, добавить
# так же можно хранить в кортеже список
# class "tuple" - кортеж
tuple0 = (1, 2, 3, 4) + (9, 7, 8)
tuple1 = ('string', 'apple', 1, 5, True) # разные типы данных
tuple2 = ('beef', 'classic', ['dream', 'mono', 1, 3]) # так же можно хранить в кортеже список
print(tuple0)
print(tuple1)
print(tuple2)
tuple2[2][0] = 'bag' # в кортеже можно изменять ТОЛЬКО, что уже изменяется - то есть список в квадратных скобках
print(tuple2)
tuple3 = ("dragon",) * 3 # ВАЖНО, если КОРТЕЖ содержит один элемент, то он должен заканчиваться запятой, иначе мы не получим кортеж
# так же можно умножать
print(tuple3)
print(type(tuple3))

# DZ 6
immutable_var = ('string', 'm-track', 'gaming', 1, 2, 3, True, False, ['apple', 'cherry', 'coco'])
print(immutable_var)
immutable_var [8][0] = 'alesis' # кортеж не изменяется, если в нем нет изменяемых данных (к таким относятся типы данных как список)
print(immutable_var)

mutable_list = ['glass', 'long', 'bridge', 1, 5, 10, True]
print(mutable_list)
mutable_list.append('self-mish') # добавили элемент
mutable_list.extend('delete') # добавили элемент по разбиванию на символы
mutable_list.extend(['insert' ,'end']) # если добавлять два элемента команда идентична .append
print(mutable_list)
mutable_list .remove('bridge') # удалили элемент
print(mutable_list)

# Словарь, пара, есть ключ и значение. Изменяемый тип данных .class "dict"
phone_book = {'Ilya':89524460977,'Gaben':30685006988, 'Alina':[89108845077,321], 'Spam':89005558085}
# работает это следующим образом 'КЛЮЧ' : 'ЗНАЧЕНИЕ', 'КЛЮЧ' : 'ЗНАЧЕНИЕ'
# на месте ключа не может быть измененных данных, но в значение может быть и список
print(phone_book)
# если нам нужен элемент, то мы должны с помощью [] указать ключ
# print ('HOMEP:', phone_book['Ilya'])
phone_book['Ilya'] = 89524444444 # мы можем изменять ЗНАЧЕНИЕ обращаясь к ключу
print(phone_book)
phone_book['Misha'] = 89107798734 # если мы обращаемся к несуществующему ключу и пробуем его изменить, он его создает
print(phone_book)
del phone_book['Spam'] # оператор del удаляет данные привязанные к ключу
print(phone_book)
phone_book.update( # обновляем список, то есть вводим в него новые данные
    {'Anton' : 89203219876,
     'Vova' :  89556498718}
    )
# метод .update обновляет словарь - вставляет в него новые данные
print(phone_book)
print(phone_book.get('Gaben')) # метод .get позволяется ПОЛУЧИТЬСЯ значение по ключу
print(phone_book.get('Spam')) # метод .get лучше, чем обращение, так как не создает данные, а покажет none - пусто, ничего
print(phone_book.get('Spam', 'Такого ключа не существует'))# так же мы можем поменять значение none на свое через (запятую) после ключа
print(phone_book)
# phone_book.pop('Vova') # так мы удаляем ключ со значением (удаляет один ключ со значением)
# метод .pop удаляет ключ со значением, а если мы укажем переменную, то мы как бы извлечем/перенесем ключ со значением в переменную
delete_phone_book = phone_book.pop('Vova')
print(delete_phone_book)
# list_one = [1,2,3] #,a = list_one.pop(1), print (a) ,print (list_one)# тоже самое можно проделывать со списком
print(phone_book)
print(phone_book.keys()) # метод .keys позволяет получить список ключей
print(phone_book.values()) # метод .keys позволяет получить список значений
print(phone_book.items()) # метод .item позволяет получиться ключ и значение

# Множество class "set"
# Особенность множества в том, что хранит оно только уникальные значения, то есть повторных данных быть не может
set_ = {1, 2, 3, 4, 5, 5, 1, 3, 'StringAll', (1, 2, 3, 4, 9, 1)} # может хранить как числа, так и строки, так и кортеже (при списках выдает ошибку)
# при том что кортеж может хранить в себе повторяющие файлы
set_.discard(1,) # удаление первого элемента (не путать с индексом) удаляет по одному
# метод .discard() удаляет элемент из множества
print(set_)
list_1 = [1, 2, 3, 4, 4, 2, 1] # список
list_1 = set(list_1) # список перевели в множество
print(list_1)
list_1.discard(1) # метод .discard удаление элемента, в скобках указывается сам элемент, если такого элемента нет, то ошибки не будет
list_1.remove(2) # удаление элемента, в скобках указывается сам элемент, если такого элемента нет, то выдаст ошибку
# метод .discard от .remove отличаются тем, что дискард не выдаст ошибку при удалении, если такого элемента не будет
print(list_1)
# метод .pop работает по такому же принципу, что в списках и кортежах
# метод .add добавляет элемент в множество (один элемент)
list_1.add(17)
list_1.add(12)
print(list_1)

# DZ 7
my_dict = {'Ilya':2000, 'Alina':1999, 'Egor':1998} # Словарь с именами и год рождения
print(my_dict)
print(my_dict.get('Egor')) # запрос данных с помощью ключа, метод .get
print(my_dict.get('Misha','Данных нет')) # запрос данных с помощью ключа, метод .get, так как данных нет он выдает none
# но после ключа через запятую можно указать, текст при отсутствии данных
my_dict['Nikita'] = 1987 # если мы обращаемся к несуществующему ключу, то он создает его
my_dict['Artem'] = 1974 # а так мы могли изменить значение по ключу
print(my_dict)
deleted_my_dict = my_dict.pop('Egor') # методом .pop мы можем удалить элемент, но если мы присвоим ему переменную, то значение сохранится в переменную
print(deleted_my_dict) # вывод в консоль удаленного элемента и сохраненного в переменную
del my_dict['Artem'] # оператор del удаляет элемент по ключу

# Оператор del в Python является мощным инструментом для удаления объектов.
# Он позволяет удалять переменные, элементы списка, части списка и даже целые списки.

print(my_dict)

my_set = {'beef', 'apple', 1, 2, 4, 5, 6, 2 ,4, 3, 'apple'} # множество состоящие из разных типов данных
print(my_set)
my_set.add('cherry') # метод .add добавляет элемент в множество
my_set.add(10) # метод .add добавляет элемент в множество
print(my_set)
my_set.remove('beef') # метод .remove удаляет элемент в множестве (указать сам элемент)
print(my_set)

# DZ 8
grades = [[5, 3, 3, 5, 4], [2, 2, 2, 3], [4, 5, 5, 2], [4, 4, 3], [5, 5, 5, 4, 5]]
students = {'Johnny', 'Bilbo', 'Steve', 'Khendrik', 'Aaron'}
avg_scores = {} # пустой словарь для среднего балла
names = list(students) # преобразуем множество в список
names.sort() # в алфавитном порядке методом .sort
avg_scores.update(
    {names[0]:sum(grades[0]) / len(grades[0]), names[1]:sum(grades[1]) / len(grades[1])})
avg_scores.update(
    {names[2]:sum(grades[2]) / len(grades[2]), names[3]:sum(grades[3]) / len(grades[3])})
avg_scores.update(
    {names[4]:sum(grades[4]) / len(grades[4])})
# Обновили список следующим образом
# {Имя[Индекс]:Сумма.sum (НазваниеСписка[Индекс]/Кол-во символов.len(НазваниеСписка[Индекс])}
# функция sum сумма чисел
# функция len кол-во символов
print(avg_scores)

# DZ 1 GPT
grades = {
    'Lily': {'math': [4, 3, 5], 'english': [5, 4, 4], 'history': [3, 4]},
    'James': {'math': [5, 5, 4], 'english': [3, 4, 3], 'history': [4, 5]}
}
avg_scores_by_subject = {} # пустой словарь
avg_scores_by_subject.update(
    {"lily":{'math':sum(grades['Lily']['math']) / len(grades['Lily']['math']),
             'english':sum(grades['Lily']['english']) / len(grades['Lily']['english']),
             'history':sum(grades['Lily']['history']) / len(grades['Lily']['history'])}}
)
avg_scores_by_subject.update(
    {"James":{'math':sum(grades['James']['math']) / len(grades['James']['math']),
             'english':sum(grades['James']['english']) / len(grades['James']['english']),
             'history':sum(grades['James']['history']) / len(grades['James']['history'])}}
)

print(avg_scores_by_subject)
print(grades['Lily']['english']) # выводим оценки по предмету 'english' для 'Lily' из словаря grades(слева направо читается код)

# DZ 9
print('Hi,PyCharm and Urban') # вывод текста в консоль
x = 43 # присваиваем переменной х значение 43
y = 32 # присваиваем переменной y значение 43
print(x * y) # вывод в консоль переменной x * y
print('End line') # вывод текста в консоль

name = input('Введите ваше имя: ')
# if(если) переменная (name) равняется значению 'веденных в кавычках'
# то выводится строка которая в этом блоке прописана с помощью табуляции
# двоеточие в конце служит для конца условия
# принимает только одно условие
if name == 'Илья':
    print(f'Добро пожаловать юный падаван, {name} ')
# elif это сокращение от else if - иначе если
elif name == 'Алина':
    print(f'Добро пожаловать юный падаван, {name} ')
# else - иначе. Сразу ставится двоеточие
else:
    print(f'Привет, {name}')

number = int(input('Введите число: '))
# if(если) остаток от деления на 3 равен 0, выводим Fizz
if number % 5 == 0  and number % 3 == 0:
    print('FizzBuss')
elif number % 3 == 0:
    print('Fizz')
elif number % 5 == 0:
    print('Buss')
else:
    print('Программе не нравится число')
# if(если) переменная (name) равняется значению 'веденных в кавычках'
# elif это сокращение от else if - иначе если
# else(иначе) сразу ставится двоеточие

'''if — проверяет первое условие.
elif (сокращение от else if) — проверяет следующие условия, если предыдущее условие ложно.
else — выполняет блок кода, если все предыдущие условия ложны.'''

'''Cуществует негласное правило при формировании условий: когда имеются несколько условий, самое маловероятное или самое сложное следует поместить в начало'''
# elif это сокращение от else if - иначе если
'СТРОГИЙ ОПЕРАТОР'
# and= и - если все условия с двух сторон равны, то все выражения считаются истинными
# and= и - чтобы получить «True», должны быть истинны оба выражения
'НЕ СТРОГИЙ ОПЕРАТОР'
# or= или - выражение ложно, если оно с двух сторон ложно, если одно из них истинное, то все выражения истинно
# or= или, чтобы получить «True» достаточно, чтобы истинным было хотя бы одно.

# DZ 10
first = int(input('Введите 3 целых числа: '))
second = int(input('Введите 3 целых числа: '))
third = int(input('Введите 3 целых числа: '))
if first == second == third: # if(если) first равняется second равняется third то выводим 3, то три значения равны
    print(3)
elif first == second or second == third or first == third: # здесь получается надо нам получиться одну истину, чтобы получить значение 2
    print(2)
else: # иначе если не одно число не равно, то получаем ноль
    print(0)

'''Ctrl + Alt + L''' # сборка кода по пеп8

# DZ 2 GPT
a = int(input('Введите одно число: '))
b = int(input('Введите одно число: '))
c = int(input('Введите одно число: '))
d = int(input('Введите одно число: '))
if a == b == c == d:
    print(4)
elif a == b == c or a == b == d or b == c == d or a == c == d:
    print(3)
elif a == b or a == c or a == d or b == c or b == d or c == d:
    print(2)
else:
    print(0)


'''while - до тех пор, пока, это значит, что до тех пор, пока условие, вводимое while, 
истинное, тело цикла продолжит выполняться, при этом количество итераций заранее не известно 
(в отличие от циклов с оператором for).'''

while True:
    number = int(input('Введите число: '))
    if number % 2 == 0:
        print('Число четное')
        break
        # break - завершает выполнение цикла полностью
        # Используется, для выхода из цикла, как только выполнено нужное условие
    else:
        print('Число нечетное')

# continue - пропускает текущую итерацию цикла и переходит к следующей
 # Используется, для перехода к следующей итерации, если выполнено нужное условие

# Пример с тройкой
# GPT Пример работы "continue"
i = 1
while i <= 5:
    if i == 1:
        i += 1  # увеличиваем i перед continue, чтобы избежать зацикливания
        continue  # Пропускаем вывод 1 и переходим к следующей итерации
    print(i)
    i += 1


while True:
    number = int(input('Введите число: '))

# Проверка на отрицательное число
    if number < 0:
        print('Число отрицательное. Введите положительное число.')
        continue # Возвращаемся к началу цикла, чтобы снова запросить ввод

    # Проверка на четность
    if number % 2 == 0:
        print('Число четное')
        break # Завершаем цикл, если число четное
    else:
        print('Число нечетное')

'''# break - завершает выполнение цикла полностью
# Используется, для выхода из цикла, как только выполнено нужное условие

# continue - пропускает текущую итерацию цикла и переходит к следующей
# Используется, для перехода к следующей итерации, если выполнено нужное условие
# Обычно ставится в начале, когда нужно сразу пропустить текущую итерацию цикла, если выполнено определенное условие
# Важно заметить, что continue можно ставить в любом месте цикла, в зависимости от логики программы
# Главное, чтобы оно выполняло свою задачу — пропускать текущую итерацию и переходить к следующей'''

# DZ 10
my_list = [42, 69, 322, 13, 0, 99, -5, 9, 8, 7, -6, 5]
my_list_index = 0 # начальный индекс для списка my_list
while my_list_index < len(my_list): # цикл идет до того момента пока индекс меньше длины списка
    if my_list[my_list_index] < 0: # если элемент списка меньше 0
        break # то цикл заканчивается, тк встретили отрицательно число
    elif my_list[my_list_index] > 0: # иначе если элемент списка больше 0
        print(my_list[my_list_index]) # вывод его в консоль
    my_list_index += 1 # увеличиваем индекс, чтобы перейти к следующему элементу списка
    # Увеличение индекса должно быть вне блоков if или elif, потому что мы хотим, чтобы индекс увеличивался в любом случае после каждого прохода цикла,
    # Независимо от того, выполнилось ли условие в if или elif.

'''В Python квадратные скобки [] — это стандартный синтаксис для индексации (обращения к элементам коллекций). 
Когда ты пишешь my_list[my_list_index], ты говоришь программе: 
"Возьми элемент списка my_list, который находится на позиции, указанной в переменной my_list_index."'''

# DZ GTP 3
numbers = [2, 7, 18, 5, 6, 12, 9, 22, 4, 15, 10]
numbers_index = 0
while numbers_index < len(numbers):
    if numbers[numbers_index] > 20:
        break
    if numbers[numbers_index] == 10:
        numbers_index += 1
        continue
    if numbers[numbers_index] % 2 == 0:
        print(numbers[numbers_index])
    numbers_index += 1
print('123')

# DZ 4 GPT
temps = [16, 22, 20, 14, 26, 18, 9, 23, 15] # температура
temps_index = 0
while temps_index < len(temps):
    if temps[temps_index] < 10:
        break
    if temps[temps_index] == 20:
        temps_index += 1
        continue
    if 15 <= temps[temps_index] <= 25:
        print(temps[temps_index])
    temps_index += 1

# for (название переменной), как правило, ее называют «i», «j» или «k»
# данные переменные будут существовать только в переделе цикла
# for(для)(переменной) in(в) "последовательность"

for i in 1, 2, 3, 4:
    print(i)
list_ = ['hello', 'world', 'party']
for i in list_:
    if i == 'party':
        list_.remove(i)
print(list_)

# Функция range в Python создаёт последовательность чисел.
# range(start, stop, step)
# start (необязательный):
# Начальное значение последовательности.
# По умолчанию равно 0.
#
# stop (обязательный):
# Конечное значение последовательности (не включается в результат).
#
# step (необязательный):
# Шаг изменения последовательности.
# Может быть положительным или отрицательным.
# По умолчанию равно 1.
## Выше описана работа функции с числами

# Функция len() используется для получения длины (количества элементов) объектов, таких как:
# Списки (list),
# Кортежи (tuple),
# Строки (str),
# Словари (dict),
# Множества (set),
# И другие коллекции (например, пользовательские классы, если у них определён метод __len__).

# Функция hash(object) используется для получения хеш-значения объекта.
# object: объект, для которого нужно вычислить хеш.
# Этот объект должен быть неизменяемым (например, строки, числа, кортежи и другие типы, которые поддерживают хеширование).

# Чтобы работать с индексами в последовательностях (например, списках), range и len — это стандартный способ в Python.

list_ = ['hello', 'world', 'party']
for i in range(len(list_)):
    print(list_[i]) # вывод на экран каждого элемента по отдельности
    list_[i] = 'vince'
    print(list_[i]) # замена каждого элемента на другой

list_2 = [2, 4 ,8, 9, 1, 19]
sum_ = 0
for i in range(len(list_2)):
    sum_ += list_2[i]
print(sum_)

for i in range(1, 11): # start, end, step # i - 1
    for j in range(1, 11): # j - 1
        print(f'{i} x {j} = {i*j}')
# первый цикл с переменной i создается со значением 1
# дальше внутренний цикл с переменной j со значением 1
# пока цикл for с переменной j не дойдет до 10, то цикл for с переменной i не поменяется и так по кругу

dict_ = {'a': 1, 'b': 2, 'c': 3}
for i in dict_:
    print(i, dict_[i])

dict_1 = {'a': 1, 'b': 2, 'c': 3}
for i, k in dict_1.items():
    print(i, k)

# DZ GPT
numbers = [10, 15, 20, 25, 30, 35, 40, 45, 50]
even_numbers = []
odd_numbers = []
for i in range(len(numbers)):
    # Цикл for перебирает индексы списка numbers, начиная с 0 и заканчивая (длина списка - 1).
    # Функция range(len(numbers)) создаёт последовательность чисел от 0 до len(numbers) - 1.
    # На каждой итерации переменная i принимает текущее значение из этой последовательности.
    # Таким образом, i указывает на индекс текущего элемента в списке numbers.
    # Переменная i временная и меняется на каждом новом круге цикла, пока не переберёт все индексы.
    ### Итерация - повторение
    n = numbers[i] # n — это текущее число из списка `numbers`, с которым мы сейчас работаем
    if n % 2 == 0: #  Если остаток от деления числа `n` на 2 равен 0, то оно четное
        even_numbers.append(n) # Добавляем `n` в список четных чисел
    else: # Иначе, если число не делится на 2 без остатка, оно нечетное
        odd_numbers.append(n) # Добавляем `n` в список нечетных чисел
print('Even', even_numbers)
print('Odd', odd_numbers)

numbers = [3, 10, 15, 18, 20, 21, 25, 30, 33, 35, 40, 45, 50, 60]
divisible_by_3 = []
divisible_by_5 = []
for i in range(len(numbers)):
    n = numbers[i]
    if n % 3 == 0:
        divisible_by_3.append(n)
    if n % 5 == 0:
        divisible_by_5.append(n)
print(divisible_by_3)
print(divisible_by_5)

numbers = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
even_numbers = []
greater_than_ten = []

for k in (numbers):
    # k = numbers[i]
    if k % 2 == 0:
        even_numbers.append(k)
    if k > 10:
        greater_than_ten.append(k)

print(even_numbers)
print(greater_than_ten)

numbers = [23, 45, 12, 67, 89, 34, 54, 23, 90, 123, 78, 56]
odd_numbers = [] # нечетные
even_numbers = [] # четные
for q in numbers:
    if q % 2 == 0:
        even_numbers.append(q)
    else:
        odd_numbers.append(q)
print(odd_numbers)
print(even_numbers)
print(sum(odd_numbers))
print(sum(even_numbers))

numbers = [30, 45, 60, 23, 70, 81, 90, 100, 125, 150, 170, 200]
divisible_by_5 = []
divisible_by_3_and_5 =[]
greater_than_50 =[]
for b in range(len(numbers)):
    z = numbers[b]
    if z % 5 == 0 and z % 3 == 0:
        divisible_by_3_and_5.append(z)
    if z % 5 == 0:
        divisible_by_5.append(z)
    if z > 50:
        greater_than_50.append(z)

print(divisible_by_5)
print(divisible_by_3_and_5)
print(greater_than_50)

numbers = [23, 45, 60, 70, 81, 100, 150, 170, 200, 55, 30, 9, 12]
even_numbers = [] # четные
odd_numbers = [] # нечетные
divisible_by_3_and_5 = []
numbers.sort()
for p in range(len(numbers)):
    u = numbers[p]
    if u % 3 == 0 and u % 5 == 0:
        divisible_by_3_and_5.append(u)
    if u % 2 == 0:
        even_numbers.append(u)
    else:
        odd_numbers.append(u)
print(numbers)
print(even_numbers)
print(odd_numbers)
print(divisible_by_3_and_5)
print(len(even_numbers))
print(len(odd_numbers))
print(sum(divisible_by_3_and_5))

# DZ 11
# Исходный список чисел от 1 до 15
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]

# Пустые списки для хранения простых и не простых чисел
primes_ = []      # Сюда добавим простые числа
not_primes = []   # Сюда добавим числа, которые не являются простыми

# Основной цикл: перебираем каждое число из списка numbers
for i in range(len(numbers)):
    is_prime = True     # Переменная-флаг: изначально считаем, что число простое
    n = numbers[i]      # Текущее число из списка, которое будем проверять

    # Вложенный цикл: проверяем, есть ли делители у числа n
    # (перебираем делители от 2 до n-1)
    for k in range(2, n):
        if n % k == 0:    # Если n делится на k без остатка, то:
            is_prime = False  # Меняем флаг на False, значит, число не простое
            break            # Прерываем вложенный цикл, так как нашли делитель

    # После проверки числа на простоту добавляем его в соответствующий список
    if is_prime and n > 1:     # Если число простое и больше 1
        primes_.append(n)      # Добавляем его в список простых чисел
    elif n > 1:                # Если число не простое и больше 1
        not_primes.append(n)   # Добавляем его в список не простых чисел

# Выводим списки простых и не простых чисел
print("Primes:", primes_)
print("Not Primes:", not_primes)

# def имя_функции (аргументы):
#     тело_функции
#     return результат
# Здесь:
# имя_функции ― название, с помощью которого можно вызывать функцию в коде;
# аргументы ― значения, которые функция принимает на вход. Это поле может быть пустым;
# тело_функции ― набор инструкций, которые выполняются при вызове;
# результат ― значения, которые функция возвращает при завершении работы.

# def (от англ. define — определить, обозначить)
# То есть, мы как бы определяем функцию. Так же, как и с переменными, по названию функции мы должны понимать ее назначение.
# Рассмотренная ниже функция – это самая простая функция, которую можно встретить - обычная.
# Но функции можно разделить на несколько видов: обычные, принимающие, возвращающие и анонимные.
# Обычная функция
def say_hello():
    print('Hello')

say_hello()

def say_hello(name):
    print('Hello', name)

say_hello(name)

# Принимающая функция
# Поскольку функция принимающая (какое-то значение), у нее есть параметр, в момент вызова функции мы обязательно должны передать этот параметр ей
def say_hello(name): # def - определить say_hello (аргумент)
    print('Hello,', name)

say_hello('Ilya')
say_hello('Alina')
say_hello('Gaben')

import random # библиотека рандом

# .randint(3, 20) метод randint генерирует случайное число от - до
# .choice(объект) метод choice генерирует случайное число из объекта

# Возвращающая функция
# Оператор return используется в функциях для возвращения данных после выполнения работы самой функции.
def lottery(): # определяем лотерея
    tickets = [1, 2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10] # в которой содержится список от 1 до 10 # импорт библиотеки рандом
    win = random.choice(tickets) # переменная содержащая в себе рандом из списка tickets
    return win # Возврат win
# После команды return функция прекращает выполнять дальнейшие команды.
# Давайте попробуем вызвать нашу функцию. В ответе ничего не видим.


print(lottery()+lottery())

# Когда мы пишем просто lottery(), функция выполняется, выбирает случайное значение, но затем сразу прекращает работу и возвращает значение,
# которое просто "зависает" в памяти, так как никуда не передано. Если мы хотим увидеть это значение,
# нам нужно вывести его на экран (через print) или сохранить в переменную.
#
# Оба варианта — с print и с присвоением переменной — имеют свои особенности и подойдут для разных ситуаций:
#
# print(lottery()): Этот способ сразу выводит результат на экран, что полезно для быстрой проверки, например, чтобы увидеть результат в консоли.
#
# win = lottery(): Этот вариант сохраняет значение, и мы можем использовать его в дальнейшем коде, повторно к нему обращаться, или, как в примере,
# складывать результаты нескольких запусков функции.

# Но на самом деле возвращающие функции на месте своего вызова оставляют после себя какое-то значение.
# Мы можем поступить так, создать переменную и сохранить в нее вызов функции.
win = lottery() + lottery()
print(win)
print('----')

def lottery(mon, thue): # определяем лотерея
    tickets = [1, 2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10] # в которой содержится список от 1 до 10 # импорт библиотеки рандом
    win1 = random.choice(tickets) # переменная содержащая в себе рандом из списка tickets
    tickets.remove(win1)
    win2 = random.choice(tickets) # переменная содержащая в себе рандом из списка tickets
    return win1, win2 # Возврат win
win1, win2 = lottery('mon', 'thue')
print(win1, win2)
print('----')

# Если мы не знаем сколько параметров будет принимать функция, мы можем написать, например, «*args» для обычных параметров и «**kwargs» для именованных.
def lottery(*args, **kwargs): # определяем лотерея
    tickets = [1, 2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10] # в которой содержится список от 1 до 10 # импорт библиотеки рандом
    win1 = random.choice(tickets) # переменная содержащая в себе рандом из списка tickets
    tickets.remove(win1)
    win2 = random.choice(tickets) # переменная содержащая в себе рандом из списка tickets
    print(*args)
    return win1, win2 # Возврат win
win1, win2 = lottery(1, 2, 3, 4, 5, 6, 7 ,8 ,9 ,10)
print(win1, win2)
print('----')

# Параметры по умолчанию
# Но в случае с нашей функцией нам необязательно передавать параметры, если мы запустим программу, то увидим,
# что компьютер вывел «2» и «True» (Рис.21). Потому что тут были заданы параметры по умолчанию.
def test(a = 2, b = True):
    print(a, b)

test(False, 22)
test([1, 3])
# В ответе мы видим наш список и все то же «True». То есть наш список встал на место параметра «а» и распаковался, как один объект.
# Чтобы распаковать его так, чтобы каждый элемент встал на соответствующее какому-то параметру место, нам нужно поставить звездочку перед списком.
# Чтобы распаковать словарь, нужно поставить две звездочки.
test(*[1, 3])

# DZ 11
def get_matrix(n, m, value): # определяем функцию get_matrix с тремя параметрами
    matrix = [] # создаем пустой список для хранения матрицы
    for i in range(n): # цикл создает n строк в матрице
        matrix.append([]) # добавляем пустой список как новую строку
        for k in range(m): # добавляет m элементов в каждую строку
            matrix[i].append([value]) # вставляем значение value в текущую строку i
    return matrix # возврат данных в список
result1 = get_matrix(2, 2, 10) #
result2 = get_matrix(3, 5, 42) #
result3 = get_matrix(4, 2, 13) #
print(result1)
print(result2)
print(result3)

# DZ 12
# Сначала генерируем случайное число от 3 до 20
one_stone = random.randint(3, 20)
# Печатаем это случайное число, чтобы увидеть, что получилось
print(one_stone)
print('-------')
# Переменная для хранения результата
result = ''
# Два вложенных цикла: первый перебирает все значения от 1 до (one_stone-1),
# второй — от (i+1) до one_stone, чтобы не повторять одинаковые пары
for i in range(1, one_stone - 1):
    for j in range(i + 1, one_stone):  # j начинается с i+1, чтобы не повторять (i, i)
        sum_j_i = i + j  # Считаем сумму текущей пары (i + j)
        # Проверяем, делится ли число one_stone на эту сумму
        if one_stone % sum_j_i == 0:
            result += str(i) + str(j) + ' '  # Если делится, добавляем пару в результат

# Печатаем все найденные пары в строковом виде, убираем лишний пробел в конце
print(result.strip()) # strip(), чтобы удалить пробелы в конце строки

'''Существует несколько видов пространства имен:
Локальное пространство имен
Глобальное пространство имен
Встроенное пространство имен'''

'''Встроенное пространство имен включает в себя имена каких-либо встроенных функций. 
Локальное представляет собой имена, которые мы используем внутри каких-либо функций, которые мы используем и создаем самостоятельно. 
Глобальное пространство имен включает в себя все, что есть в нашей программе, исключая лишь локальное пространство.
в Python переменные, определённые вне функций, автоматически доступны внутри функций, если они только читаются, а не изменяются'''


# Глобальное пространство
z = 5
x = 10


def printer():
    # То что, находится в функции - называется локальным пространством имен
    # Часть, которая находится внутри функции, и является локальным пространством имен
    # Переменные «c» и «d» существуют до тех пор, пока функция не завершит свою работу
    ### Если нам нужно использовать глобальную переменную в функции то пишем global
    global z, x
    c = 110
    d = 220
    z = 'Str'
    x = 'Str 2'
    # В свою очередь есть такая особенность, что к глобальному пространству имен мы можем обращаться напрямую из локального
    # Сделаем для себя пояснение, что «c» и «d» у нас local, а «z» и «x» это global
    print(c, d, 'local')
    print(z, x, 'global')
 # При запуске программы мы видим, что теперь даже после завершения функции используются значения, присвоенные переменным внутри нее.
 # Таким образом во время вызова функции мы переопределили значения переменных «z» и «x» из глобального пространства имен.

printer()
print(z, x)

# DZ 13
calls = 0 # переменная со значением 0
def count_call(): # определяем count_call с пустым аргументом
    global calls # используем глобальную переменную, которая сохранена вне функции
    calls += 1 # прибавляем и сохраняем значение в переменную call
    return calls # возвращаем измененное значение в переменную calls
def string_info(string): # определяем string_info с принимающим аргументом
    count_call() # используем функцию count_call для подсчета вызова остальных функция
    tiple1_info_str = (len(string), string.upper(), string.lower()) # создаем кортеж, подсчитываем кол-во элементов в string(принимающем аргументе)
    print(tiple1_info_str) # выводим в консоль кортеж

def is_contains(string, list_to_search): # определяем is_contains с двумя принимающими аргументами
    count_call() # используем функцию count_call для подсчета вызова остальных функция
    string = string.lower() # создаем переменную в которой аргумент переводится в нижний регистр, так как переменные взаимозаменяемые даем такое же название
    new_list_to_search = [z.lower() for z in list_to_search] # Интересная строка. Создаем новый список, в котором элементы из списка list_to_search
                                                             # Преобразуются в нижний регистр
                                                             # Цикл
                                                             # Для каждого элемента в списке list_to_search переменная z временно принимает
                                                             # значение этого элемента, и к нему применяется метод lower(), чтобы привести строку к нижнему регистру.

    if string in new_list_to_search: # если аргумент есть в списке
        print(True) # то выводим в консоль значение True
    else: # иначе
        print(False) # выводим False

string_info('Capybara')
string_info('Armageddon')
is_contains('Urban', ['ban', 'BaNaN', 'urBAN']) # Urban ~ urBAN
is_contains('cycle', ['recycling', 'cyclic']) # No matches
print(calls)

def print_param(a = 1, b = 2, c = 3): # параметры по умолчанию, то есть если мы вызываем функция и не задаем ей параметры, он берет те, что написаны в аргументах
    print(a,b ,c)

print_param(12,3, 4) # так же мы можем переопределять параметры
print_param(c ='String') # так же мы можем указать, что хотим изменить конкретный параметр, при этом если не указывать другие параметры, то они будут взяты из параметров по умолчанию
print_param(c = 3, a = "StringSSS", b = True) # так же мы можем давать параметры в разнобой и другие типы данных

def print_param1(*, a ,b ,c):# Существует также способ конкретно указать, что параметр будет именованным. Нужно поставить знак «*» перед этим параметром.
    print(a, b ,c)
print_param1(a = 1,b = 3,c = 4)

def func_with_params(a, b = 2, c = 11):
    print(a + b + c)

func_with_params(3) # так же если в функции первое значение не по умолчанию, а следующие по умолчанию, то мы можем вызвать функцию и передать ей первое значение, а второе подставится само
func_with_params(3, 10) # но мы так же можем переопределять и второе значение
func_with_params(3)
func_with_params(3)

def func_with_params1(a, b = 2, c = []): # Значения параметров создаются не в момент, когда мы вызываем функцию, а создаются при её определении.
    c.append(a)
    print(c)
# Если запустим, то увидим, что эти значения, которые мы передаем, добавляются не в новый список, а в уже существующий
# Этот список был создан в момент определения функции func_with_params, и каждый вызов просто добавляем, в уже существующий список, новый элемент.
func_with_params1(3)
func_with_params1(3)
func_with_params1(3)
# Если нам необходимо избежать такого, например, работать в моменте, мы можем в “с” указать значение по умолчанию “None” и в функции проверить, что если “с”- “None”,
# Тогда мы говорим, что “с” будет списком, и в этот список добавим “а”, потом выведем этот список. Запускаем. В таких случаях у нас список “с” будет переопределяться.
# Если мы будем менять объекты, результат тоже будет, соответственно разным.
def func_with_params2(a, b = 2, c = None):
    if c is None: # если(if) С являет(is) None(ничего)
        c = []         # Если c равно None, создается пустой список для С
        c.append(a)    # Затем добавляется значение a в список С
    print(c)           # Печатается список С

        # Проверка if c is None:
    # Когда функция вызывается без аргумента С, параметр С будет None.
    # Проверка if c is None позволяет определить, был ли передан аргумент для С. Если С не передавали, то С равен None.
    # Если С — None, то переменной c присваивается пустой список [].

func_with_params2(2)
func_with_params2(3)
func_with_params2(4)

# DZ 14
def send_email(message, recipient, *, sender = "university.help@gmail.com"):
    ### Проверяем, что оба адреса имеют знак "@" и заканчиваются на ".com", ".ru" или ".net"
    if ('@' not in recipient or not recipient.endswith(('.com', '.ru', '.net')) or
            '@' not in sender or not sender.endswith(('.com','.ru','.net'))):
    # если(if) "элемент`а" нет(not) в(in) recipient или(or) нет(not) recipient.endswith(чего нет)
    # если у нас в if несколько условий, то они пишутся в скобках
    # метод .endswith проверяет - заканчивается ли строка указанным суффиксом, и возвращает True, если это так, или False, если нет
    ## Метод .endswith() принимает: Либо один строковый суффикс, например: string.endswith(".com").
    ## Либо кортеж из нескольких суффиксов, например: string.endswith((".com", ".ru", ".net"))
    ### Если хотя бы одно из условий истинно (то есть не выполнено), то выводим сообщение
        print(f'Невозможно отправить письмо с адреса {sender} на адрес {recipient}') # выводим
    elif sender == recipient: # иначе если sender ==(равен) recient то
        print('Нельзя отправить письмо самому себе') # выводим
    elif sender == "university.help@gmail.com": # Проверяем, используется ли адрес отправителя по умолчанию
        print(f'Письмо успешно отправлено с адреса {sender} на адрес {recipient}') # выводим
    else: # иначе ни одно из условий не выполнено
        print(f'НЕСТАНДАРТНЫЙ ОТПРАВИТЕЛЬ! Письмо отправлено с адреса {sender} на адрес {recipient}') # выводим

send_email('Это сообщение для проверки связи', 'vasyok1337@gmail.com')
send_email('Вы видите это сообщение как лучший студент курса!', 'urban.fan@mail.ru', sender='urban.info@gmail.com')
send_email('Пожалуйста, исправьте задание', 'urban.student@mail.ru', sender='urban.teacher@mail.uk')
send_email('Напоминаю самому себе о вебинаре', 'urban.teacher@mail.ru', sender='urban.teacher@mail.ru')

# Одна “звездочка” используется для распаковки и запаковки именно позиционных параметров, которые содержат один элемент: списки, кортежи, множества и т.д.;
# Две “звездочки” используются для запаковки и распаковки именованных параметров. В Python такая коллекция одна - словари. В них элементы хранятся парами.
# Для того чтобы добавить ключ и пару через функция надо применять не двоеточие, а равно как будто что-то присваиваем
def params3(*params): # кортеж
    print(params)

params3(1, 3 ,5, 2, 3)

def params1(a, b, c, d, e):
    print(a, b ,c ,d, e)

list1 = [1, 2, 3, 4, 5]
params1(*list1) # распаковка списка

def params2(**params): # словарь
    print(params)
params2(a= 2, b= 2) # при создании словаря в вызове функции, в ключе необходимо называть именованные параметры
# Для того чтобы добавить ключ и пару через функция надо применять не двоеточие, а равно как будто что-то присваиваем

# DZ 15
def print_params(a = 1, b = 'строка', c = True): # Функция с тремя параметрами по умолчанию
    print(a, b ,c) # вывод параметром

print_params(35) # вызов функции с параметром, так как он один, следующие подхватываются, которые были по умолчанию
print_params(4, 'test') # вызов функции с двумя параметром, так как их два, следующие подхватываются, которые были по умолчанию
print_params(8, None, False) # вызов функций с тремя параметрами, которые мы переопределили
print_params()

print_params(b = 25) # вызов функции с переопределением определенного параметра
print_params(c = [1, 2, 3]) # вызов функции с переопределением определенного параметра (в данном случае) создание списка в параметре C

values_list = [100, 'OneZero', True] # список
values_dict = {'a':200, 'b':'ZeroOne', 'c':None} # словарь ключ:значение

print_params(*values_list) # вызов функции с распаковкой списка
print_params(**values_dict) # вызов функции с распаковкой словаря(ключ это параметр в функции) важно, чтобы их было одинаковое кол-во
values_list_2 = [54.32, 'Строка' ] # Список
print_params(*values_list_2, 42) # вызов функции с распаковкой списка и замена параметра C (что пишет pyharm ошибочно) так как в списке уже два параметра, то мы ввели третий
'----------------------------------------------------------------------------------------------------------------------'
def test_func(*params): # функция где в аргументе одна звездочка, принимает неопределенное кол-во аргументов, создает кортеж
    print('Тип',type(params))
    print("Аргумент", params)

test_func()
test_func(1, 3, 5, 4, 6)

def summator(txt, *values):
    s = 0
    for i in values:
        s += i
    return f'{txt}{s}'

print(summator('Сумма чисел:', 2, 3, 5))

def info(**values): # # функция где в аргументе две звездочки, принимает неопределенное кол-во аргументов, создает словарь
    print('Тип', type(values))
    print("Аргумент", values)
    for key, value in values.items():
        print(key, value)
info(name='Ilya', cource='Python') # при создании словаря в вызове функции, в ключе необходимо называть именованные параметры
# Для того чтобы добавить ключ и пару через функция надо применять не двоеточие, а равно как будто что-то присваиваем

def info(value ,*types, name_author = 'Ilysha', **values): # # функция где в аргументе две звездочки, принимает неопределенное кол-во аргументов, создает словарь
    # всегда в аргументе функции сначала идет одна звездочка, потом две
    print('Тип', type(values))
    print("Аргумент", values)
    for key, value in values.items():
        print(key, value)
    print(types)
info('Пример использования аргументов всех типов', 2, 3, 5, 4, name='Ilya', cource='Python') # при создании словаря в вызове функции, в ключе необходимо называть именованные параметры
# Для того чтобы добавить ключ и пару через функция надо применять не двоеточие, а равно как будто что-то присваиваем

def my_sum(n, *args, txt = 'Сумма числе'):
    s = 0
    for i in range(len(args)):
        s += args[i] ** n
    print(f'{txt}:{s}')

my_sum(1, 1, 2, 3, 4, 5)
my_sum(2, 2, 3, 4, 5,txt='Сумма квадратов' )

# DZ 16
def single_root_words(root_word, *other_words): # определяем функцию с двумя аргументами (первый позиционный и второй *кортеж)
    same_words = [] # создание пустого списка
    root_word = root_word.lower() # объявляем, что root.world равен root.world.lower() преобразует аргумент в нижний регистр (название такое же так как переменные взаимозаменяемые)
    for i in other_words: # цикл перебора в котором переменная i временно принимает значение из списка
        if root_word in i.lower() or i.lower() in root_word: # проверка. если(if) root_word в(in) i.lower()
            # получается что мы проверяем есть ли слово root_word в индексе i, который при проверке преобразует слово в нижний регистр, но при в добавление в список сохранит изначальный регистр
            # так же проверяем и обратно
            same_words.append(i) # если есть совпадение, то добавляем слово хранящиеся в переменной i в список
    return same_words # возвращаем значение в список

result1 = single_root_words('rich', 'richiest', 'orichalcum', 'cheers', 'richies')
result2 = single_root_words('Disablement', 'Able', 'Mable', 'Disable', 'Bagel')
print(result1)
print(result2)

# Рекурсия — это цепочка вызовов функции сама собой, где каждое новое значение строится на основе предыдущего,
# пока не будет достигнут базовый случай.
def summa(n):
    # Определяем функцию summa, которая принимает один аргумент n.
    # Эта функция будет использовать рекурсию для вычисления суммы всех чисел от 1 до n включительно.
    if n == 1:  # Базовый случай
        # Если n равно 1, то мы достигли базового случая.
        # Базовый случай нужен для остановки рекурсии.
        # Здесь функция просто возвращает 1, потому что сумма от 1 до 1 — это 1.
        return 1
    else:  # Рекурсивный случай
        # Если n не равно 1, то мы выполняем рекурсивный вызов.
        # Сначала функция возвращает n (текущую величину), добавляя к результату вызова summa(n - 1).
        # summa(n - 1) вычисляет сумму чисел от 1 до n-1.
        return n + summa(n - 1)

# После определения функции вызовем её для демонстрации:
print(summa(2))
# Функция summa(2) выполнит следующее:
# 1. Проверит: n == 1? Нет, перейдёт в else.
# 2. Вернёт 2 + summa(1).
# 3. В summa(1) выполнится базовый случай, и вернётся 1.
# 4. Сложит 2 + 1, результат: 3.
# И напечатает результат (3).

# DZ 17
def get_multiplied_digits(number): # определяем функцию с одним аргументом
    str_number = str(number) # Преобразуем аргумент в строку
    first = int(str_number[0:1]) # сохраняем первое число в переменную first из переменyой str_number, предварительно перевели ее в int
    if len(str_number) > 1: # если длина строки больше 1, то возвращаем число умноженную на функцию со срезом
        return first * get_multiplied_digits(int(str_number[1:]))
    # Рекурсивный случай: вызываем функцию для оставшейся части числа (все цифры, кроме первой),
    # а результат умножаем на `first`.
    # Таким образом, постепенно умножаем первую цифру на произведение остальных цифр.
    elif len(str_number) == 1: # базовый случай число строки равно 1, то возвращаем first
    # Базовый случай рекурсии: если осталась только одна цифра, возвращаем её.
        return first

resultget = get_multiplied_digits(40203)
print(resultget)

# DZ GPT
def sum_of_digits(n):
    if n < 10:  # Базовый случай: число состоит из одной цифры
        return n
    else:  # Рекурсивный случай
        last_digit = n % 10  # Последняя цифра
        remaining_digits = n // 10  # Оставшиеся цифры
        return last_digit + sum_of_digits(remaining_digits)

print(sum_of_digits(45678))

def factorial(n):
    if n < 1:
        return 'Введите число большое одного'
    # Базовый случай: если n равно 1, факториал равен 1
    elif n == 1:
        return 1
    else:
        # Рекурсивный случай: n умножается на факториал (n-1)
        return n * factorial(n - 1)

# Пример вызова функции
print(factorial(4))
print(f'Факториал для 5 равен: {factorial(5)}')  #

'''Существует перечень функций, которые встречаются при попытке преобразовать один тип данных к другому:
#int() - целое число int(input()) # вводимый текст юзера преобразуется ва число
#float() - число с плавающей запятой
#bool() - логические значения
#str() - строки
#list() - список
#tuple() - кортеж
#dict() - словарь
#set() - множество'''

salary = [2300, 1800.80, 5000, 1234.02, 7500.12]
print(round(sum(salary) / len(salary), 2),'- средняя зарплата в компании') # функция sum() - находит сумму всех значений
                                                                 # функция len() - возвращает длину передаваемой последовательности
                                                                 # функция round() - работа с числами после точки,
                                                                 # возвращает число с определенным количеством цифр после точки
print(round(max(salary),2),'- максимальная зарплата в компании')          # функция max() - находит максимальное значение/элемент в переданной последовательности
print(round(min(salary),2),'- минимальная зарплата зарплата в компании')  # функция min() - находит минимальное значение/элемент в переданной последовательности

name_salary = ['Илья', 'Алина', 'Миша', 'Юля', 'Артем']

# zip - функция, которая позволяет объединять элементы из нескольких итерируемых объектов в один итерируемый объект
### zipped_name_salary = zip(name_salary, salary) ###
### print(zipped_name_salary) # если попытаемся вызвать саму переменную, то получим адрес объекта ###
### для того чтобы работать дальше с этой переменной, нам надо указать с чем мы хотим работать ###
### print(list(zipped_name_salary)) # в данном примере указываю, что я хочу работать со списком ###
### print(dict(zipped_name_salary)) # в данном примере указываю, что я хочу работать со словарем ###
zipped_name_salary = dict(zip(name_salary, salary)) # все это дело можно сразу обернуть словарем или другим итерируемом объектом
print(zipped_name_salary['Алина'], '- зарплата Алины') # вызываем переменную, которая уже является словарем.
# используем ключ, чтобы получиться значение

a = [True, False, False]
# Функция any() проверяет объект, его содержимое, то есть пробегает по элементам.
# При условии, что хотя бы один из элементов внутри объекта будет True, функция вернёт нам True,
# в противном случае вернёт False.
'''any - любой'''
print(any(a))
a = [False, False, False]
print(any(a))
# Если смотреть на числа, например, с точки зрения логических значений, то любые числа, кроме 0, будут давать True.
a = [1, 0, 0]
print(any(a))
# Если будут все нули, то и в ответе получим False
a = [0, 0, 0]
print(any(a))
# На строки мы смотрим с точки зрения наличия в ней символов. Если строка пустая, тогда False
# При наличии в строке хотя бы одного элемента, получим True
b = ''
print(any(b))
b = 'slovo'
print(any(b))
# функции all(), если все элементы True получаем True. Если хотя бы один элемент False - получаем False.
'''all - все'''
# Если хотя бы один элемент False - получаем False
a = [1, 1, 0]
print(all(a))
# Если все элементы True получаем True
a = [1, 1, 1]
print(all(a))

'''Интроспекция — это способность какого-либо объекта получить информацию об атрибутах и методах в процесс выполнения программы.'''

# Функция dir() возвращает список атрибутов и методов объекта.
# Если аргументом является объект, dir() выведет все доступные атрибуты и методы этого объекта.
# Если аргументом является модуль, dir() вернет список его функций, классов и переменных.
# Пример:
# dir(a) выведет список методов и атрибутов объекта 'a', в данном случае это список.
'''dir - справочник или список атрибутов'''
print(dir(a))  # Выведет список атрибутов и методов объекта 'a' (например, методы list)

# Функция isinstance() используется для проверки принадлежности объекта к определенному классу или типу данных.
# Она принимает два аргумента: объект, который нужно проверить, и класс или тип данных,
# к которому нужно проверить принадлежность.
## isinstance - (объект, тип данных) ## isinstance - (объект, (тип данных, тип данных, и т.д))
# Она возвращает True- Истина, если объект принадлежит классу, иначе False - Ложь.
'''isinstance - относится экземпляр, этот экземпляр, это экземпляр, этот пример'''
print(isinstance(b, str)) # выводим в консоль относится ли переменная b к классу str-строка
## Аналогичного результата можно добиться, если проверить через type равняется
print(type(b) == str) # тип переменной b равняется к классу str-строка
a = [1, 2, 3]
b = [1, 2, 3]
# Оператор «==» сравнивает значения объектов:
print(a == b) # равняется ли a и b
# Однако оператор «is»(является) проверяет идентичность объектов
print(a is b)
# Функция id() возвращает уникальный идентификатор для указанного объекта, то есть его адрес в памяти
'''id - идентификатор'''
print(id(a))
print(id(b))
c = b
print(b)
print(c)
print(id(b))
print(id(c))
# Однако оператор «is»(является) проверяет идентичность объектов
print(c is b)
# функцией Help() - если вы, допустим, забыли или нуждаетесь в помощи.
'''help - помощь'''
print(help(print))
# pass в Python — это особый оператор заглушки, который не выполняет никаких действий.
# Он находит свое применение в тех местах, где синтаксис языка требует наличие блока кода,
# но вы ещё не готовы прописывать его логику.'''
'''pass - пасс, пас, пропуск'''
def herlper1():
    '''Тут должно быть объяснение'''
    pass
'''В исходном коде Python строки документации заключаются в тройные кавычки и пишутся сразу под заголовком объекта.'''
# Извлекать строки документации можно двумя способами:
# Через встроенный для каждого объекта атрибут-переменную __doc__.
# С помощью встроенной в Python функции help, которая запускает интерактивную справочную систему.
print(herlper1.__doc__)
print(help(herlper1))

# Максимум в списке
def find_max(list_):
    max_ = list_[0]
    for i in list_:
        if i > max_:
            max_ = i
    return max_

print(find_max([20, 52, 12, 101, 15, -1, -88, 100]))

# Подсчёт четных чисел в списке
def count_even(list_):
    counter = 0
    list_kolvo =[]
    for i in list_:
        if i == 0:
            continue
        elif i % 2 == 0:
            counter += 1
            list_kolvo.append(i)
    print(list_kolvo)
    return counter

print(count_even([2, 2, 3, 4, 2, 1, 0]))

# Уникальный список
def unique(list_):
    new_list = []
    for i in list_:
        if i not in new_list: # если(if) не(not) в(in) списке(new_list)
            new_list.append(i)# то переменную i добавляем в список
    return new_list

print(unique([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]))

# DZ GPT
# Минимум в списке
def find_min(list_):
    min_ = list_[0]
    for i in list_:
        if i < min_:
            min_ = i
    return min_

print(find_min([20, 52, 12, 101, 15, -1, -88, 100]))

#Подсчёт нечётных чисел
def count_odd(list_):
    counter = 0
    for i in list_:
        if i == 0:
            continue
        if i % 2 != 0:
            counter += 1
    return counter

print(count_odd([2, 2, 3, 4, 2, 1, 0]))

# Уникальные числа (но в отсортированном порядке)
def unique_sorted(list_):
    new_unique = []
    for i in list_:
        if i not in new_unique:
            new_unique.append(i)
    new_unique.sort()
    return new_unique

print(unique_sorted([1, 5, 3, 1, 7, 2, 4, 5, 3, 2]))

#Сумма положительных чисел
def sum_positive(list_):
    sum_positive = 0
    for i in list_:
        if i > 0:
            sum_positive += i
    return sum_positive


print(sum_positive([-5, 10, 0, -3, 8, -2]))

#Числа больше среднего значения
def above_average(list_):
    new_above_average =[]
    list_1 = sum(list_)
    average = list_1 / len(list_)
    for i in list_:
        if i > average:
            new_above_average.append(i)
    return new_above_average

print(above_average([1, 2, 3, 4, 5, 6]))

#Удалить все отрицательные числа
def remove_negatives(list_):
    no_negatives = []
    for i in list_:
        if i >= 0:
            no_negatives.append(i)
    return no_negatives

print(remove_negatives([-5, 10, 0, -3, 8, -2]))

# Найти индексы чётных чисел
'''Не смог сам решить'''
def even_indices(list_):
    indices_ = []
    for i in range(len(list_)):  # Перебираем индексы списка
        if list_[i] % 2 == 0:  # Проверяем, чётное ли число на текущем индексе
            indices_.append(i)  # Добавляем индекс в результирующий список
    return indices_

print(even_indices([1, 2, 3, 4, 5, 6]))

#Умножить все элементы списка на заданное число
def multiply_list(list_, factor):
    multiply =[]
    for i in list_:
        k = factor * i
        multiply.append(k)
    return multiply

print(multiply_list([1, 2, 3], 3))

#Найти все элементы, которые встречаются более одного раза
'''Не смог сам решить'''
def find_duplicates(list_):
    duplicates_list = []
    seen = set()  # Для отслеживания уже встреченных элементов
    for i in list_:
        if i in seen and i not in duplicates_list:  # Если элемент уже был, но еще не добавлен в результат
            duplicates_list.append(i)
        else:
            seen.add(i)  # Запоминаем, что элемент встретился
    return duplicates_list

print(find_duplicates([1, 2, 3, 4, 5, 2, 4, 6, 7, 4, 8]))

#Перевёрнутый список
def reverse_list(list_):
    revers = []
    for i in list_:
        revers.append(i)
    revers = sorted(revers, reverse = True) # функция сортет
    return revers

#Синтаксис функции sorted():
# sorted(iterable, key=None, reverse=False)
# где:
## iterable: обязательный параметр, представляющий итерируемый объект или встроенную последовательность,
# элементы которого требуется отсортировать.
## key: необязательный параметр, представляющий функцию, которая определяет ключ сортировки.
# По умолчанию None, что означает сортировку по значениям элементов.
## reverse: необязательный параметр, определяющий порядок сортировки.
# Если - reverse=True, то сортировка будет производиться в обратном порядке (от большего к меньшему),
# а если reverse=False (по умолчанию), то сортировка будет производиться в прямом порядке (от меньшего к большему).

print(reverse_list([1, 2, 3, 4, 5]))

print(not [])
print(not [1, 2, 3])

# DZ 18
data_structure = [
    [1, 2, 3],
    {'a': 4, 'b': 5},
    (6, {'cube': 7, 'drum': 8}),
    "Hello",
    ((), [{(2, 'Urban', ('Urban2', 35))}])
]
def calculated_structure(data): # создаем функцию с позиционным аргументом
    total_sum = 0
    if isinstance(data, (int, float)): # если этот экземпляр(isinstance, объект, (тип данных, если их несколько-то в скобки)-True-Истина
        total_sum += data # то в переменную тоталсум прибавляем это значение и сохраняем
    elif isinstance(data, str): # иначе если этот экземпляр(isinstance, объект, строка)- True-Истина
        total_sum += len(data) # то в переменную тоталсум прибавляем и сохраняем длину строки
    elif isinstance(data,(list, set, tuple)): # иначе если этот экземпляр(isinstance, объект, (тип данных, тип данных) True-Истина
        for element in data: # цикл для elementa в data
            total_sum += calculated_structure(element) # рекурсивный вызов функции (в начале где иф)
    elif isinstance(data, dict): # иначе если этот экземпляр(isinstance, объект, (тип данных, тип данных)
        for key, value in data.items(): # цикл для словаря. так как в словаре два аргумента, то и временных переменной тоже две
                                        # метод .item позволяет получить ключ и значение
            total_sum += calculated_structure(key) # рекурсивный вызов функции для ключа (в начале где иф)
            total_sum += calculated_structure(value) # рекурсивный вызов функции для значения (в начале где иф)
    return total_sum # возвращаем в ответ total_sum

result = calculated_structure(data_structure) # переменная в которой функция и ее аргумент
print(result)

'''ЛОГИКА NOT(не)'''
mem = 'slovo'
if 's' in mem:
    print('s есть')
    # если буква С в слове
    # есть,правда
if 'b' in mem:
    print('s есть')
    # если буква Б в слове
    # нет, ложь
if 'k' not in mem:
    print('нет элемента k')
    # если буквы К нет в слове
    # нет, правда
if 's' not in mem:
    print('нет элемента s')
    # если буквы С нет в слове
    # есть, ложь

num = -5
if not num >= 0:
    print('число меньше или равно нулю,то оно отрицательное')
    # если число не меньше, равно нулю
if num >= 0:
    print('число больше нуля')
    # если число больше, равно нул.
#############################################

# Существует два вида импорта:
# 1. Абсолютный импорт
# Используется, чтобы явно указать полный путь к модулю, начиная с корня проекта.
# Это наиболее надёжный и читаемый способ импорта, так как он чётко показывает, откуда берётся модуль.
# Предположим, у вас есть следующая структура проекта:
#
# project/
# ├── main.py
# ├── package1/
# │   ├── module1.py
# │   └── module2.py

# Если вы хотите импортировать module1 из module2, используйте абсолютный импорт:
# # В module2.py
# from package1 import module1

# Если вы работаете в main.py и хотите импортировать module1:
# # В main.py
# from package1 import module1

# 2. Относительный.
# Относительный импорт — это использование конструкции «from» с применением точки или двоеточия и так далее
# Относительный импорт позволяет импортировать модули относительно текущего модуля.
# . — текущая директория.
# .. — на уровень выше.
# ... — на два уровня выше и так далее.

# С той же структурой проекта:
# Если вы хотите импортировать module1 из module2, используя относительный импорт:
# В module2.py
# from . import module1  # Импорт из текущей директории (package1)

# Если вы хотите импортировать module1 из другой вложенной папки:
# from ..package1 import module1  # Поднимаемся на уровень выше и импортируем module1

##### module4
# import module4_1 as m4_1 # импортируем модуль4_1 as(как) название, которе будет использоваться в будущем, при обращенье к модулю;-1
# # чтобы использовать функции, класса, переменные без префикса module4_1/m4_1
# from module4_1 import say_hello as sh #from(из) (объект) import (что импортируем/вытаскиваем) так же можно дать сокращенное название
#                           # после импорта можно указать *, что укажет на то, что мы хотим импортировать все
# '''В начале выполнения программы мы видим сообщение «Привет», потому что интерпретатор сначала импортирует второй модуль.
# Перед тем как завершить импорт, он считывает всю информацию из модуля, обрабатывает создание функций и переменных, и,
# ###конечно же, выполняет команду «#print»###. Это поведение сохраняется независимо от способа импорта:
# даже если мы импортируем только один элемент, например, переменную «a» из «module2»,
# интерпретатор всё равно выполнит весь код модуля при запуске. Мы по-прежнему видим сообщение «Привет»,
# поскольку соответствующая функция была выполнена.'''
# print(dir(m4_1)) # # Функция dir(). Эта функция позволяет получить информацию об атрибутах объекта
#
# print('Привет, здесь мы изучаем Модули и Пакеты, в данном уроке ты находишься на 4 модуле')
#
# # print(m4_1.a) # обращаемся к модулю4_1 через точку вызываем функцию или переменную из него
# # m4_1.say_hello()
# # say_hello()
#
# print(m4_1.__name__)

##### module4_1
# def say_hello():
#     print('Привет я из функции в 4 модуле')
#     return 'Ты использовал функцию из файла модуль4_1'
#
# def main():
#     a = 50
#     b = 100
#     print('Эээ')
#     print('123')
#
# if __name__ == '__main__':
#     main()
# #Когда файл запускается как основная программа, его __name__ становится '__main__'.
# #Когда файл импортируется как модуль, его __name__ будет содержать имя файла без расширения .py (например, 'myfile').
# #__name__ — это переменная, которая всегда содержит имя модуля (или '__main__', если это основной файл).
# #__main__ — это просто строка, которая означает, что файл был запущен как основной скрипт.
# ### ИТОГ ###
# #__name__ хранит имя текущего модуля. Когда файл запускается напрямую, его __name__ равно '__main__'.
# #__main__ — это специальное значение, которое используется для проверки, был ли файл запущен напрямую или импортирован.
# print(__name__)

#from modules import module4_1
##(from)из modules(тут указана папка) (import)импорт файл - здесь импорт всего файла
##(from)из modules(тут указана папка).файл (import)импорт (что импортируем(название функции и тд))
# from modules.module4_1 import say_hello as sh

# Так же если пакет содержит в себе модули, то лучше всего импортировать их через from(из) (пакет) импорт (модуль, модуль)

# DZ 19
from true_math import divide as tmd # из(from) модуля import (что импортируем) как(as) название к которому будем обращаться
from fake_math import divide as fmd # из(from) модуля import (что импортируем) как(as) название к которому будем обращаться

result1 = fmd(69, 3)
result2 = fmd(3, 0)
result3 = tmd(49, 7)
result4 = tmd(15, 0)

print(result1)
print(result2)
print(result3)
print(result4)

#CODEWARS 1
def likes(names):
    if not names:  # если не names, если names пуста
        return f"no one likes this"  # то возвращаем no one likes this
    elif len(
            names) == 1:  # если длина списка равняется 1, когда мы используем команду len для списка она показывает кол-во элементов в списке,
                          # а при указании индекса кол-во символов в элементе
        return f"{names[0]} likes this"  # выводим names с индексом 0, то есть первое имя, так как подсчет начинается с нуля, префикс f
    elif len(
            names) == 2:  # если длина списка равняется 2, когда мы используем команду len для списка она показывает кол-во элементов в списке
        return f"{names[0]} and {names[1]} like this"
    elif len(names) == 3:
        return names[0] + ', ' + names[1] + ' and ' + names[2] + ' like this' # вывод без префикса f
    elif len(names) >= 4:  #
        return f"{names[0]}, {names[1]} and {len(names) - 2} others like this"  # выводим names с индексом 0, names с индексом 1 и
                            # кол-во элементов{len(в списке) - 2} вычитаем 2 из кол-во элементов в списке так как уже указали двоих

print(likes([]))
print(likes(['Peter']))
print(likes(['Jacob', 'Alex']))
print(likes(['Max', 'John', 'Mark']))
print(likes(['Alex', 'Jacob', 'Mark', 'Max']))
print(likes(['Alex', 'Jacob', 'Mark', 'Max', 'Peter', 'Pacob', 'Jacob', 'Mark', 'Max', 'Peter', 'Pacob']))

#from modules import module4_1
##(from)из modules(тут указана папка) (import)импорт файл - здесь импорт всего файла

##(from)из modules(тут указана папка).файл (import)импорт (что импортируем(название функции и тд)) as(как) - принимает название функции/или модуля, когда мы будем к ней обращаться
# from modules.module4_1 import say_hello as sh

##### Пакет — это директория, которая по сути такая же, как и наша "modules".
##### Единственным отличием пакета от обычной папки является наличие внутри файла "__init__.py" с двойным подчеркиванием.
##### Когда мы создали файл "__init__.py", мы заметили, что на изображении нашей папки "modules" появился кружочек.
##### Этот кружочек обозначает, что наш модуль, или наша папка, теперь стала пакетом.

# Существует особенность: когда мы импортируем пакет или взаимодействуем с ним, код из файла "__init__.py" с двойным подчеркиванием
# начинает выполняться. Это происходит аналогично тому, как происходит выполнение кода при импорте какого-либо модуля,
# где вся информация из модуля считывается и выполняется. В случае с файлом "__init__.py" также считывается и выполняется код,
# содержащийся в этом файле.



import modules

print(modules)

# Размещение файла main.py внутри пакета допустимо, но это не всегда является лучшим подходом.
# Давайте разберём плюсы и минусы этого решения, чтобы понять, правильно ли вы сделали.
#
# Плюсы размещения main.py внутри пакета
# Компактность проекта:
#
# Если ваш проект небольшой, а логика программы тесно связана с этим пакетом, то хранение main.py внутри него удобно.
# Например, если весь проект связан только с package1, то main.py в его корне логично объединяет весь код.
# Локализация кода:
#
# Если вы планируете, что main.py используется только в контексте этого пакета (и не предполагается его вызов извне),
# то такое расположение может быть оправдано.


# Минусы размещения main.py внутри пакета
# Нарушение модульности:
#
# Обычно main.py используется как точка входа для всей программы. Его место, как правило, за пределами пакетов,
# чтобы он мог обращаться ко всем модулям и пакетам проекта.
#
# Например:
# project/
# ├── package1/
# │   ├── package2/
# │   │   ├── package3/
# │   │   │   ├── __init__.py
# │   │   │   ├── module2.py
# │   │   ├── __init__.py
# │   ├── __init__.py
# ├── main.py
# Такое расположение позволяет отделить основной запускной файл от реализации логики внутри пакетов.
#
# Сложность импорта:
# Если main.py находится внутри пакета, вам придётся работать с относительными импортами внутри пакета.
# Это может усложнить поддержку проекта, особенно если вы решите переместить точку входа позже.
# При расположении main.py вне пакета, вы можете использовать абсолютные импорты
# (например, from package1.package2.module import ...), что считается более читабельным и удобным.
#
# Неудобство масштабирования:
# Если проект будет расти, вам, возможно, потребуется добавлять другие модули и пакеты на одном уровне с package1.
# В таком случае, файл main.py внутри одного пакета уже не будет интуитивно подходить как общая точка входа.




# Если ваш проект небольшой и состоит из одного основного пакета, оставлять main.py внутри пакета — допустимо.
# Однако в профессиональной разработке чаще применяют следующую структуру:
#
# project/
# ├── package1/
# │   ├── package2/
# │   │   ├── package3/
# │   │   │   ├── __init__.py
# │   │   │   ├── module2.py
# │   │   ├── __init__.py
# │   ├── __init__.py
# ├── main.py
#
# Преимущества:
# Файл main.py является точкой входа для всей программы.
# Все пакеты и модули остаются отдельно, поддерживая модульность.
# Если проект вырастет, вам будет проще добавлять другие модули, например:
#
# project/
# ├── package1/
# ├── package2/
# ├── utilities/
# ├── main.py


# Метод .isdigit() возвращает True, если все символы в строке являются цифрами. Если нет, возвращается False.
# isdigit = is(является)digit(цифрой) - является цифрой

#CODEWARS 2
# Задача, даются PIN коды разной длины, надо сделать так, чтобы PIN код из 4 или 6 символов выдавало тру
# Остальное False. При этом надо учесть, чтобы True выдавало только когда в наборе цифры.
# Если 4 или 6 символов, но в них есть другие символы кроме цифр, то False
def validate_pin(pin):
    pin = str(pin.lower()) # преобразуем элементы в строку и в нижний регистр
    if "-" in pin or "+" in pin: # если 'символ' в pin(переменной) или если 'символ' в pin(переменной)
        return False # то возвращаем False
    if pin.isdigit() is True: # если pin.isdigit (is-является digit-цифрой) является True
        # Метод .isdigit() возвращает True, если все символы в строке являются цифрами. Если нет, возвращается False.
        if len(pin) == 4 or len(pin) == 6: # то если длина(len) pin == 4 или(or) длина(len) pin == 6
            return True # то возвращаем True
        else: # иначе
            return False # возвращаем False
    if pin.isdigit() is False: # если pin.isdigit (is-является digit-цифрой) является False
        return False # возвращаем False

print(validate_pin(22+3))
print(validate_pin(1234123))
print(validate_pin(123456))
print(validate_pin(-123))

#CODEWARS 3 (Почти решил сам)
def to_jaden_case(string):
    # Разбиваем строку на слова и приводим каждое слово к формату с заглавной буквой
    st = ' '.join(word.capitalize() for word in string.split()) # пока не очень разобрался с этими методами.
    return st

result = to_jaden_case("How can mirrors be real if our eyes aren't real")
print(result)

#CODEWAR 4(Не решил)
# Задача, даются элементы, при вводе которых требуется на выходе заменить символы на #, а остальные 4 оставить открытые.
def maskify(cc):
    if len(cc) <= 4:
        return cc
    # Если длина строки больше 4 символов:
    # 1. Вычисляем количество символов, которые нужно заменить на `#`:
    # Это `len(cc) - 4` — длина строки минус 4 символа, которые остаются неизменными.
    # 2. Создаём строку из символов `#` такой длины: `"#" * (len(cc) - 4)`.
    # 3. Берём последние 4 символа строки с помощью среза `cc[-4:]`.
    # 4. Складываем строку из `#` и последние 4 символа, чтобы получить маскированную строку.
    return "#" * (len(cc) - 4) + cc[-4:]

###########
import math

# from math import - если мы возьмем библиотеку «math» и импортируем все из нее, что произойдет с нашим «globals»?
# Обратите внимание, что здесь появилось огромное количество значений.


# ЗДЕСЬ ПРИМЕР ТОГО КАК ФУКНЦИЯ МОЖЕТ СЧИТЫВАТЬ ЗНАЧЕНИЕ ПЕРЕМЕННЫХ ИЗ ГЛОБАЛЬНОГО ПРОСТРАНСТВА
def square(x):
    # global a
# Сейчас «a» находится в другом пространстве имен, а не в глобальном.
    # Она находится в локальном пространстве имен, и с этим можно что-то делать.
    # Однако если мы хотим связать их, например, если мы хотим, чтобы наша функция «square» перезаписывала переменную «a»,
    # которая находится в другом пространстве имен, как это сделать внутри функции? На самом деле это очень просто.
    # Нам нужно добавить оператор «global» и указать, какие значения мы будем использовать из глобального пространства
    d = a ** 2 # По сути, функция обладает своим собственным пространством имен, которое называется локальным, и значение она будет брать из этого локального пространства.
    return d
               # Переменная d находится в локальном пространстве, то есть она существует только в функции
               # Но в глобальном пространстве, мы не можем взять значение из функции, так как оно создается только в функции.
               # Но функция может считывать значения(только чтение) из глобального пространства.

               # Если бы это происходило внутри функции, мы сначала смотрели бы на локальное пространство, потом на глобальное, и
               # только затем на встроенное. Такой порядок называется "изнутри наружу".
               # Таким образом, мы сначала обращаемся к нашему пространству имен, а затем к встроенному пространству имен.
a = 5 # БЕРЕТСЯ ЭТО ЗНАЧЕНИЕ # Переменная находится в глобальном пространстве $$$$$
# Когда мы передаем «a**2», это «a» берется из нашей основной программы.
# То есть, если внутри локального пространства имен ничего нет, мы обращаемся к другому пространству имен — глобальному.
# Этот процесс работает изнутри наружу: мы можем обращаться к глобальным переменным изнутри функции,
# но не можем извлекать значения из функции в нашу программу.

# Мы можем обращаться к глобальным переменным изнутри функции, но не можем извлекать значения из функции в нашу

# Важно не забывать, что у нас в функции есть свое собственное пространство имен.
# Если внутри функции не определено какое-то значение, мы будем пытаться найти его в других местах.
# Если значение определено, мы в первую очередь обращаемся к нему в локальном пространстве.

b = square(2)
print(a)
print(b)
# print(globals()) # Функция globals() возвращает словарь со значениями переменных, представляющий текущую глобальную область видимости модуля

# ПРИМЕР ТОГО КАК ФУНКЦИЯ ИЩЕТ ПЕРЕМЕННЫЕ - Объемлющая область видимости
# from package1.package2.module1 import * - из(from) (папка.папка.модуль) импорт(import) * - звездочка означает импорт всего модуля
d = 4 # нашла бы она ее, если бы ее здесь не было, а вверху у нас был бы импорт модуля
      # то функция начала бы искать d уже в модуле, в модуле она равна 11
def square1(x):
    d = x ** 2
    def even(x):
        nonlocal d # Указываем, что будем перезаписывать переменную d из внешней функции square1
        d = x / 2
        if d % 2 == 0: # в функции even проверка d % 2, она начинает искать значение d изнутри наружу, находит d в функции square1
                       # если бы переменной d не было в функции square1, она бы начала искать в глобальном пространстве
            print('Число четное')
        else:
            print('Число нечетное')
    even(x)
    return d
    # global - Если мы хотим использовать значение из глобального пространства имен в локальном, мы применяем команду «global».

# Вызов locals() внутри функции возвращает словарь с локальными переменными
# На уровне модуля: изменения словаря locals() могут влиять на глобальные переменные, так как он совпадает с globals().
# # На уровне модуля
# x = 5
# locals()['x'] = 10
# print(x)  # Вывод: 10

### области видимости - обычно с конца ###
# Встроенная
# Глобальная
# Объемлющая
# Локальная

b = square1(4)
print(b)

def public_function():
    return "I'm a public function."


def _private_function():
    return "I'm a private function."

__all__ = ['public_function']

# В этом примере __all__ — это список, который содержит имена всех объектов, доступных для импорта при использовании
# конструкции from (моймодуль) import *. В данном случае, если где-то в коде написать from (моймодуль) import *,
# будет импортирована только функция public_function, в то время как _private_function останется недоступной.
#
# Таким образом, __all__ определяет интерфейс модуля, который виден при импорте *.
# Это особенно полезно, когда нужно сделать некоторые функции или классы «приватными» или внутренними для модуля,
# чтобы они не могли быть использованы вне его.
#
# Важно отметить, что __all__ влияет только на поведение импорта *.
# Если импортировать объекты напрямую, например, from (моймодуль) import _private_function, то __all__ будет проигнорирован.

#CODEWAR 5
#Просто, учитывая строку слов, верните длину самого короткого слова (слов).
def find_short(s):
    short = len(s) # переменная содержит кол-во символов в аргументе
    for i in s.split(): # цикл i в s.split() в i будет временно помещаться одно слово
        p = len(i) # переменная p содержит в себе кол-во символов в i
        if p < short: # если p меньше short
            short = p # то short равняется p
    return short # возвращаем short

print(find_short('bitcoin take over the world maybe who knows perhaps'))

# DZ 20
def test_function():
    def inner_function():
        print('Я в области видимости функции test_function')
    inner_function()


test_function()
# inner_function() # ошибка такое имя не определено

nums = [5, 1 ,3, 8, 7, 0]

# Этот метод я больше всех понял(ну почти, но принцип понимаю и код тоже)
def bubble_sort(ls): # Сортировка пузырьком
    swapped = True  # Флаг, который показывает, происходили ли обмены элементов в этом проходе.
    while swapped:
        swapped = False  # Сбрасываем флаг, предполагая, что обменов больше не будет.
        for i in range(len(ls) - 1):  # Проходим по всем элементам списка (кроме последнего).
            if ls[i] > ls[i+1]:  # Если текущий элемент больше следующего: # работаем со списками #
                ls[i], ls[i + 1] = ls[i + 1], ls[i]  # Меняем их местами.
                swapped = True  # Устанавливаем флаг, чтобы показать, что произошёл обмен.

bubble_sort(nums)
print(nums)

nums_1 = [5, 1, 3, 8, 7, 2]

def selection_sort(ls): # Сортировка выбором
    for i in range(len(ls)):  # Проходим по всем элементам списка.
        lowest = i  # Предполагаем, что текущий элемент (ls[i]) — минимальный.
        for j in range(i + 1, len(ls)):  # Ищем минимальный элемент в оставшейся части списка.
            if ls[j] < ls[lowest]:  # Если нашли элемент меньше текущего минимального:
                lowest = j  # Запоминаем индекс этого элемента.
        ls[i], ls[lowest] = ls[lowest], ls[i]  # Меняем местами текущий элемент с минимальным.

selection_sort(nums_1)
print(nums_1)

nums_2 = [9, 3, 1, 7, 4, 2]

def insertion_sort(ls): # Сортировка вставкой
    for i in range(len(ls)):  # Начинаем с первого элемента, двигаемся вправо
        j = i - 1  # Инициализируем j, чтобы начинать проверку с элемента перед текущим
        key = ls[i]  # Текущий элемент, который нужно вставить на правильное место
        while ls[j] > key and j >= 0:  # Пока элементы слева больше, сдвигаем их
            ls[j + 1] = ls[j]  # Сдвигаем элементы вправо
            j -= 1  # Переходим к следующему элементу слева
        ls[j + 1] = key  # Вставляем текущий элемент на его правильное место

insertion_sort(nums_2)
print(nums_2)

from sortfunc_test.sortfunc import *

data_1 = list(map(int, input('Введите числа через пробел: ').split())) # 1 2 3 4 5

# Функция map() используется для применения функции к каждому элементу итерируемого объекта (например, списка или словаря)
# и возврата нового итератора для получения результатов.
# map(function, iterable)
# function — это функция, которую мы хотим применить. Она может быть как заранее определённой, так и анонимной (с использованием lambda).
# iterable — это итерируемый объект, к каждому элементу которого будет применяться функция.
# Если вы хотите получить результат в виде списка, вы должны явно преобразовать объект map в список с помощью функции list().
# Функция list() берёт любой итерируемый объект (например, результат map()) и создаёт из него список.


data_2 = list(map(int, input('Введите числа через пробел: ').split())) # 1 2 3 4 5
data_3 = list(map(int, input('Введите числа через пробел: ').split())) # 1 2 3 4 5

bubble_sort(data_1)
selection_sort(data_2)
insertion_sort(data_3)

print('Пузырьковая сортировка:', data_1)
print('Сортировка выбором:', data_2)
print('Сортировка вставкой:', data_3)

nums = [1, 2, 3, 4, 5]
squared = map(lambda x: x**2, nums)  # Применяем функцию x**2 к каждому элементу
print(list(squared))  # Преобразуем результат в список
# Вывод: [1, 4, 9, 16, 25]

words = ["hello", "world", "python"]
uppercased = list(map(str.upper, words))  # Применяем метод upper() к каждой строке
print(uppercased)
# Вывод: ['HELLO', 'WORLD', 'PYTHON']

# Генератор списка (или list comprehension) — это удобный и компактный способ создания новых списков в Python.
# [выражение for элемент in итерируемый_объект if условие]
# выражение — это операция или функция, которая применяется к каждому элементу.
# for элемент in итерируемый_объект — цикл, который перебирает элементы итерируемого объекта.
# if условие (необязательно) — фильтр, который определяет, включать элемент в итоговый список или нет.

nums = [1, 2, 3, 4, 5]
squared = [x**2 for x in nums]
print(squared)
# Вывод: [1, 4, 9, 16, 25]

nums = [1, 2, 3, 4, 5, 6]
even_nums = [x for x in nums if x % 2 == 0]
print(even_nums)
# Вывод: [2, 4, 6]

words = ["hello", "world", "python"]
uppercased = [word.upper() for word in words]
print(uppercased)
# Вывод: ['HELLO', 'WORLD', 'PYTHON']

# ЛЯМБДА
# lambda — это ключевое слово в Python, которое используется для создания анонимных функций (функций без имени)
# lambda аргументы: выражение
# lambda — ключевое слово, создающее функцию.
# аргументы — список аргументов, которые принимает функция (как в обычной функции).
# выражение — единственное выражение, которое вычисляется и возвращается.
# lambda x, y: x + y
# lambda — ключевое слово, которое говорит Python, что вы создаете анонимную функцию.
# x, y — это параметры функции. В данном случае, функция принимает два аргумента: x и y.
# x + y — это выражение, которое вычисляется и возвращается. Lambda-функции всегда возвращают результат выражения.
# add_lambda = lambda x, y: x + y
# Создает анонимную функцию, которая принимает два аргумента x и y.
# Возвращает их сумму (x + y).
# add_lambda(3, 5)
# Присваивается переменной add_lambda, которую можно использовать как обычную функцию.


global_var = 'я глобальная переменная'
print(global_var)


def local_func():
    # global global_var
    local_var = 'я локальная переменная'
    print(f'внутри функции {local_var}')
    print(f'внутри функция {global_var}')


def local_func1():
    global global_var
    global_var = 135623465
    print(global_var)
    local_var = 'я локальная переменная'
    print(f'внутри функции {local_var}')
    print(f'внутри функция {global_var}')

local_func()
local_func1()

try:
    print(local_var)
    # except:
    print('Ошибочка')
except NameError as e:
    print(f'Ошибочка {e}')


def outer_func():
    outer_var = 'Я переменная внешней функции'

    def inner_funk():
        inner_var = 'я переменная внутренней функции'
        print(f'Внутри внутренней функции {inner_var}')
        print(f'Внутри внутренней функции {outer_var}')

    inner_funk()
    print(f'Внутри внешней функции {outer_var}')

outer_func()


def outer_func_nonlocal():
    outer_var = 'Я переменная внешней функции1'

    def inner_funk_nonlocal():
        # nonlocal outer_var
        outer_var = 'Я измененная переменная внешней функции2'
        print(f'Внутри внутренней функции {outer_var}')

    inner_funk_nonlocal()
    print(f'Внутри внешней функции {outer_var}')

outer_func_nonlocal()

# try и except — это ключевые слова в Python, которые используются для обработки ошибок (исключений)
# try:
#     Код, который может вызвать исключение
# except ExceptionType:
#     Код, который выполняется, если произошло исключение указанного типа

## Простая обработка ошибки
# try:
#     num = int(input("Введите число: "))
#     print("Вы ввели:", num)
# except ValueError:
#     print("Это не число!")
# В блоке try выполняется код, который может вызвать ошибку.
# Если ошибка ValueError возникает (например, пользователь ввел текст вместо числа), выполняется блок except.

# Как это работает?
# try: Программа пытается выполнить код в этом блоке.
# except: Если во время выполнения блока try возникает ошибка (исключение), программа переходит к соответствующему блоку except.
# Если ошибок нет, блок except пропускается.

## Обработка нескольких типов ошибок
# try:
#     x = int(input("Введите число: "))
#     result = 10 / x
# except ValueError:
#     print("Ошибка: вы ввели не число.")
# except ZeroDivisionError:
#     print("Ошибка: деление на ноль невозможно.")
# Если пользователь вводит текст, сработает ValueError.
# Если пользователь вводит 0, сработает ZeroDivisionError.

## Общий except для всех ошибок
# Если не указывать тип ошибки, except поймает любое исключение:
# try:
#     x = int(input("Введите число: "))
#     result = 10 / x
# except:
#     print("Произошла ошибка!")

## Расширенный синтаксис
### ''else: Код, который выполняется, если ошибок не было.''
# try:
#     x = int(input("Введите число: "))
# except ValueError:
#     print("Ошибка!")
# else:
#     print("Всё прошло успешно!")
#
### ''finally: Код, который выполняется всегда (независимо от того, произошла ошибка или нет).''
# try:
#     x = int(input("Введите число: "))
# except ValueError:
#     print("Ошибка!")
# finally:
#     print("Программа завершена.")

##Полный блок
# try:
#     x = int(input("Введите число: "))
#     result = 10 / x
# except ValueError:
#     print("Ошибка: введено не число.")
# except ZeroDivisionError:
#     print("Ошибка: деление на ноль.")
# else:
#     print("Результат:", result)
# finally:
#     print("Выполнение завершено.")

# Краткий итог
# try — блок для кода, который может вызвать исключение.
# except — блок для обработки ошибок.
# else — выполняется, если ошибок не было.
# finally — выполняется всегда.

#CODEWAR 6 (Относительно сам решил)
# Вводятся число, которое потом показывает привычное нам время hh:mm:ss
def make_readable(seconds):
    seconds = int(seconds) # перевод строки в integer - число
    hh = seconds // 3600 # расчет часа- Здесь мы берём целую часть от деления секунд на 3600, что даёт количество часов.
    mm = (seconds % 3600) // 60 # расчет минут - Сначала берём остаток от деления секунд на 3600 (seconds % 3600), чтобы исключить часы. Затем делим этот остаток на 60, чтобы получить количество минут.
    ss = seconds % 60 # расчет секунд - Остаток от деления секунд на 60 даёт оставшиеся секунды.
    return f'{hh:02}:{mm:02}:{ss:02}' # # f-строка автоматически преобразует значения в строку. ':02' задаёт формат с двумя символами, дополняя недостающие нулями.

# : указывает, что начинается спецификатор формата.
# 02 означает, что длина значения будет не менее двух символов, а недостающие символы слева заполняются нулями.

'''Форматирование с помощью f-строк (f-strings)
Синтаксис:
f"{variable:format_spec}"
variable — переменная или выражение, значение которой нужно вставить.
format_spec — это спецификатор формата, который указывает, как отобразить значение.'''

# Спецификаторы формата:
# Спецификатор	            Описание	                         Пример
# :02	                    Дополнить до 2 символов с нулями	 5 → 05
# :03	                    Дополнить до 3 символов с нулями	 7 → 007
# .2f	                    Число с плавающей точкой, 2 знака	 3.14159 → 3.14
# >	                        Выравнивание вправо	                 "abc" → " abc"
# <	                        Выравнивание влево	                 "abc" → "abc "
# ^	                        Центрирование	                     "abc" → " abc "
# ,	                        Разделение числа запятыми	         1000000 → 1,000,000
# b	                        Двоичное представление	             5 → 101
# x	                        Шестнадцатеричное представление	     255 → ff

print(make_readable(3999))

#CODEWAR 7 (Сам решил)
#Учитывая массив целых чисел, верните новый массив, в котором каждое значение удвоено.
def maps(a):
    a_1 = [z * 2 for z in a] # новый список в нем генератор списка - с выражением z*2 цикл для(for) z in(в) списке(a)
    # Генератор списка: перебираем каждый элемент `z` из списка `a` и добавляем в новый список результат умножения `z` на 2.

    # В выражении[z * 2for z in a], временная переменная z:
    # Представляет текущий элемент списка a на каждой итерации цикла for
    # Используется в выражении z * 2, которое выполняется для каждого элемента
    return a_1

print(maps([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))


# key — это дополнительный параметр, который можно передать в функции, такие как max, min, sorted, и некоторые другие.
# Параметр key используется в:
# max(iterable, key=...) — находит максимальный элемент по указанному ключу.
# min(iterable, key=...) — находит минимальный элемент по указанному ключу.
# sorted(iterable, key=...) — сортирует элементы по указанному ключу.
# sorted(iterable, key=...) — сортирует элементы по указанному ключу.
# list.sort(key=...) — сортирует список "на месте".
#
# Синтаксис:
# max(iterable, key=function)
# min(iterable, key=function)
# sorted(iterable, key=function)
# пишем что находим, где находим, по какому ключу
#
# Примеры использования
# 1. max(iterable, key=function)
# Что находим? Максимальный элемент.
# Где находим? В переданном итерируемом объекте (iterable).
# По какому ключу? Ключ определяется функцией function, которая применяется к каждому элементу, чтобы вычислить "значение для сравнения".
# Пример:
words = ["apple", "banana", "cherry"]
longest_word = max(words, key=len)
print(longest_word)  # 'banana'
# Что находим? Самое длинное слово.
# Где находим? В списке words.
# По какому ключу? По длине каждого слова (функция len).

'''КЛАССЫ'''
# Объектно-ориентированное программирование (ООП) основывается на трёх ключевых принципах:
# 1) Наследование — этот принцип позволяет создавать новые классы на основе существующих,
# что даёт возможность расширять и изменять поведение базового класса, делая производные классы более уникальными.
# 2) Инкапсуляция — позволяет скрывать внутренние детали реализации класса от пользователей,
# предоставляя доступ только к необходимым элементам. Это способствует более безопасной работе и предотвращает случайные ошибки.
# 3) Полиморфизм — позволяет использовать объекты разных классов через единый интерфейс,
# что упрощает взаимодействие с ними и делает код более гибким.
'''Дополнительное объяснение:'''

# Что такое класс?
# Класс — это конструкция, которая описывает структуру и поведение объектов. Он содержит:

# Атрибуты — данные или свойства объекта (например, name).
# Методы — функции, которые определяют поведение объекта.
# Что такое объект?
# Объект (или экземпляр класса) — это конкретный "представитель" класса с уникальным набором атрибутов. В данном примере Ilya и Alina — это два разных объекта класса Human.

# Что делает __init__?
# __init__ (инициализатор) автоматически вызывается при создании нового объекта. Он помогает задать начальные значения атрибутов, используя аргументы, переданные при создании объекта.

# Почему используется self?

# self — это ссылка на текущий объект, который создаётся.
# Все атрибуты и методы объекта доступны через self.
# В инициализаторе self.name = name означает: "Создать атрибут name у текущего объекта и присвоить ему значение из аргумента name."
# Для создания класса достаточно указать ключевое слово class, после которого следует название класса (с большой буквы).

# Класс можно представить как шаблон или инструкцию, на основе которой создаются объекты (экземпляры).
# Каждый объект класса обладает характеристиками (атрибутами) и может выполнять определённые действия (методы).
# Классы позволяют объединять данные (атрибуты) и логику (методы) в одной структуре.

class Human:
    # Классовый атрибут — это переменная, которая принадлежит классу, а не его отдельным экземплярам.
    # Все экземпляры этого класса имеют доступ к классовым атрибутам, и изменения в классовом атрибуте
    # повлияют на все экземпляры, которые на него ссылаются.

    ## Таким образом, классовый атрибут 'head' доступен всем экземплярам, но 'name' и 'age' являются индивидуальными атрибутами, специфичными для каждого объекта.
    ## Это удобно, когда необходимо хранить информацию, которая относится ко всем объектам, а не к отдельным экземплярам.
    head = True # Это значение доступно всем объектам, созданным на основе класса Human.
    # Классовые атрибуты могут быть изменены и это изменение будет отражаться на всех объектах, созданных на основе этого класса

    ### Это знание помогает понять, как организовать данные и методы в классах, а также различать, какие атрибуты относятся к классам, а какие — к объектам.

    """Здесь обычно идет описание класса в тройных кавычках"""
    # Инициализатор класса (__init__) — это специальный метод, который вызывается автоматически при создании нового объекта.
    # Он используется для задания начальных значений атрибутов объекта.
    def __init__(self, name, age):
        # Атрибуты экземпляра #
        # self — ссылка на текущий экземпляр объекта. Она позволяет обращаться к атрибутам и методам объекта.
        # Атрибуты name и age инициализируются при создании объекта. Они становятся уникальными характеристиками каждого объекта.
        self.name = name # Устанавливаем значение атрибута name.
        self.age = age # Устанавливаем значение атрибута age.
        self.say_info()  # Вызов метода внутри конструктора (__init__). Это позволяет автоматически выводить информацию о созданном объекте.

    # Метод объекта, который выводит информацию об объекте в формате строки.
    def say_info(self):
        # self.name и self.age относятся к текущему экземпляру класса.
        print(f'Привет, меня зовут {self.name}, мне {self.age}')

    # Метод объекта, который увеличивает значение атрибута age на 1.
    def birthday(self): # метод при котором, использовании этого метода увеличивается возраст объекта/экземпляра
        self.age += 1 # Увеличиваем значение возраста (age) текущего объекта.
        print(f'У меня день рождения, мне теперь {self.age}')

    # Методы, содержащие двойное подчеркивание, называются специальными или магическими методами.
    # Также можно встретить другое название — dunder-методы, что является сокращением от фразы "double underscore"
    # (двойное нижнее подчеркивание). На данном занятии будет представлено несколько из этих магических методов.

    # Использование метода __len__() для определения длины массива в Python.
    # Метод __len__ всегда должен возвращать int
    def __len__(self):
        return self.age

    # destruct - деструктор
    # Это может происходить либо по завершении работы интерпретатора, когда все строки кода выполнены, либо при отсутствии ссылок на объект.
    # Для удаления объекта можно воспользоваться оператором '__del__', который активирует деструктор.
    def __del__(self):
        print(f'{self.name} ушел(а), но обещал(а) вернуться')
        # можно использовать pass для заглушки

    # Переопределение метода __bool__ позволяет задавать собственные условия для проверки "истинности" объектов класса.
    # В данном случае объект считается "истинным", если значение его атрибута age больше 18.

    # Метод __bool__ вызывается автоматически, когда объект участвует в условной проверке (например, if <объект>:).
    # Возвращаемое значение — True или False:
    # - True, если age > 18.
    # - False, если age <= 18.
    def __bool__(self):
        return self.age > 18

    # В Python существуют встроенные операторы (например, +, -, >, <, ==), которые имеют стандартное поведение для базовых типов данных.
    # Например:
    # - Числа: 5 > 3 вернёт True, а 7 < 2 вернёт False.
    # - Строки: "apple" < "banana" (лексикографическое сравнение).
    #
    # Однако мы можем переопределить стандартное поведение операторов для объектов пользовательских классов.
    # Этот процесс называется **перегрузкой операторов**.
    #
    # Это позволяет определять, как операторы работают с экземплярами классов, предоставляя свою логику.

    # Перегрузка оператора "<" (меньше чем).
    # Метод '__lt__()' (Lower Than) определяет, что должно происходить при использовании оператора "<" для объектов данного класса.
    # В данном примере: два объекта будут сравниваться на основе их атрибута 'age'.
    def __lt__(self, other):
        return self.age < other.age

    # Перегрузка оператора ">" (больше чем).
    # Метод '__gt__()' (Greater Than) определяет, что должно происходить при использовании оператора ">" для объектов данного класса.
    # В данном примере: два объекта будут сравниваться на основе их атрибута 'age'
    def __gt__(self, other):
        return self.age > other.age

    # Перезагрузка оператора "==" (равно).
    # Метод '__eq__()' (Equal) определяет, что должно происходить при использовании оператора "==" для объектов данного класса.
    # В данном примере: два объекта будут сравниваться на основе их атрибутов name == name и age == age
    def __eq__(self, other):
        return self.name == other.name and self.age == other.name


# ilya — это экземпляр (объект) класса Human.
# Переменная ilya — это объект (экземпляр) класса Human, созданный на основе его шаблона.
# Класс Human — это шаблон, описывающий свойства и поведение человека (атрибуты и методы).

# Чтобы создать объект, вы вызываете класс как функцию
# Создаём объект класса Human с именем 'Илья' и возрастом 24.
ilya = Human('Илья', 24)
# Переменная ilya представляет собой экземпляр класса Human и хранит информацию о конкретном человеке.

# Можно добавить атрибут объекту после его создания, даже если он не был определён в классе.
ilya.surname = 'Нефедов'

# Создаём второй объект класса Human с именем 'Алина' и возрастом 24.
alina = Human('Алина', 24)
liza = Human('Лиза', 13)

# Выводим значения атрибутов объектов.
# Атрибут name хранит имя объекта, age — возраст, а surname был добавлен вручную для объекта ilya.
print(ilya.name, ilya.surname, ilya.age)
print(alina.name, alina.age)

# Функция hasattr() проверяет существование атрибута в указанном объекте.
# hasattr - имеет атрибут
# hasattr(object, name)
# object: Объект, у которого вы хотите проверить наличие атрибут
# name: Строка, представляющая имя атрибута, метода

if hasattr(ilya, 'surname'):
    print(f'{ilya.surname}, Проверка функции hasattr')
else:
    print("У объекта нет атрибута surname.")

# Применяем метод birthday для объекта alina, чтобы увеличить её возраст на 1.
alina.birthday()

'''del ilya # при добавлении деструктора мы можем удалять объект через оператор del'''

# Вновь выводим информацию об объектах, используя метод say_info.
ilya.say_info()
alina.say_info()

print(f'Проверка: {ilya < alina}')
print(f'Проверка: {ilya > alina}')
print(f'Проверка: {ilya == alina}')

# При проверке if <переменная>: вызывается метод __bool__() объекта, на который ссылается переменная.
# Если метод возвращает True, код внутри блока if выполняется.
# Если метод возвращает False, выполняется блок else (если он есть)

# if ilya:  # Проверяем объект ilya. Метод ilya.__bool__() возвращает True или False в зависимости от возраста.
# Если ilya.age > 18, выполнится код в блоке if.
# Если ilya.age <= 18, выполнится блок else.

if ilya:
    print(f'{ilya.name} достиг совершеннолетия')
else:
    print(f'{ilya.name} не достиг совершеннолетия')
# Поведение аналогично: if alina: и if liza: проверяют истинность объектов.
# Метод __bool__ для каждого объекта (alina, liza) вызывает соответствующий атрибут age объекта
if alina:
    print(f'{alina.name} достиг совершеннолетия')
else:
    print(f'{alina.name} не достиг совершеннолетия')
# Вывод информации о совершеннолетии каждого объекта:
# - Если объект "истинный" (возраст больше 18), выводится сообщение о достижении совершеннолетия.
# - Если объект "ложный" (возраст 18 или меньше), выводится сообщение о несовершеннолетии.
if liza:
    print(f'{liza.name} достиг совершеннолетия')
else:
    print(f'{liza.name} не достигла совершеннолетия')

# Пример использования классового атрибута:
print(Human.head)  # Обращаемся к классовому атрибуту 'head' через сам класс.

# Изменяем классовый атрибут у объекта 'ilya'. Это создаст новый атрибут, который будет локальным для этого экземпляра.
ilya.head = False

# При проверке атрибутов сначала ищем в экземпляре. Если его нет, то ищем в классе.
# Поэтому у объекта 'ilya' будет свой атрибут 'head', а у 'alina' — классовый атрибут.
print(f'Если голова у Ильи - {ilya.head}, если ли голова у Алины - {alina.head}')  # Вывод: False (у Ilya) и True (по умолчанию у Alina)
# Важно: Если атрибут объекта не был изменён, то при проверке Python обратится к классовому атрибуту.

print(Human.__mro__) # Обратившись к атрибуту 'mro()', который отображает цепочку наследования для класса


'''Class_Method_New'''


class User:
    # __instance — это атрибут класса, который хранит ссылку на единственный экземпляр класса (если он уже был создан).
    # Используется для реализации паттерна Singleton (синглтон), где допускается только один объект данного класса.
    __instance = None

    # Метод __new__ отвечает за создание нового объекта.
    # cls — это ссылка на сам класс User, аналогично self для методов экземпляра.

    # Метод __new__ используется для контроля над процессом создания объектов.
    # Применяется в паттернах Singleton, работе с неизменяемыми типами,
    # создании кэша или при необходимости управлять доступом к объектам.
    def __new__(cls, *args, **kwargs):
        print(f'Я в нью')  # Этот вывод помогает понять, что метод __new__ был вызван.

        # Проверяем, существует ли уже экземпляр класса. Если он не создан, создаём его.
        if cls.__instance is None:
            # super().__new__(cls) вызывает родительский метод __new__, который создаёт объект.
            # В данном случае super() вызывает __new__ у родительского класса object, что создаёт новый объект.
            cls.__instance = super().__new__(cls)
            # Возвращаем единственный экземпляр класса.
        return cls.__instance

        # Метод __init__ отвечает за инициализацию созданного объекта.

    # self указывает на экземпляр объекта, который был возвращён методом __new__.
    def __init__(self, *args, **kwargs):
        print(f'Я в ините')  # Этот вывод помогает понять, что метод __init__ был вызван.

        # Сохраняем позиционные аргументы в атрибуте args объекта.
        self.args = args

        # Проходимся по именованным аргументам (kwargs).
        # Для каждого ключа-значения создаём атрибут объекта с соответствующим именем.
        for key, value in kwargs.items():
            setattr(self, key, value)  # setattr динамически создаёт атрибуты объекта.
            # Синтаксис функции setattr:
            # setattr(object, name, value)
            # object: Это объект, для которого вы хотите задать или изменить атрибут.
            # name: Это имя атрибута, которое вы хотите создать или изменить. Оно передается как строка (тип данных: str).
            # value: Это значение, которое будет присвоено атрибуту. Оно может быть любого типа данных.

            # setattr полезен, когда вам нужно создавать атрибуты в объекте динамически, например, когда вы не знаете заранее, какие именно атрибуты будут добавлены.

# __mro__ (Method Resolution Order) показывает порядок поиска методов.
# Он определяет, в каком порядке будут искаться методы в классе и его родителях.
print(User.__mro__)
# Вывод будет: (<class '__main__.User'>, <class 'object'>),
# так как User наследуется от object, это стандарт для Python классов.

other = [1, 2, 3, 4, 5]  # Позиционные аргументы, которые передаются в класс.
user = {'name': 'Artem', 'age': 24, 'gender': 'male'}  # Именованные аргументы (словарь), которые передаются в класс.

user1 = User(*other, **user)
# Создаётся объект класса User. В процессе выполнения происходит:
# 1. Вызов метода __new__:
#    - Если объекта не существует, создаётся новый экземпляр.
#    - Возвращается ссылка на экземпляр.
# 2. Вызов метода __init__:
#    - Инициализируется экземпляр, создаются атрибуты args и атрибуты из kwargs.

print(user1.args)
# Вывод: (1, 2, 3, 4, 5)
# Атрибут args содержит переданные позиционные аргументы, упакованные в кортеж.

print(user1.name)
# Вывод: 'Artem'
# Атрибут name был добавлен через именованные аргументы kwargs.

print(user1.age)
# Вывод: 24
# Аналогично name, атрибут age добавлен через kwargs.

print(user1.gender)
# Вывод: 'male'
# gender также добавлен через именованные аргументы kwargs.

print(dir(user1))
# Если аргументом является объект, dir() выведет все доступные атрибуты и методы этого объекта.

print(user1.__dict__)
# Атрибут __dict__ возвращает словарь всех изменяемых атрибутов объекта или класса.
# Это позволяет получить, добавить или изменить атрибуты объекта динамически.

class Example:
    def __new__(cls, *args, **kwargs):
        print("Я в __new__")
        print(f"args: {args}")     # Позиционные аргументы
        print(f"kwargs: {kwargs}") # Именованные аргументы
        return object.__new__(cls) # Создаём новый объект класса Example

    def __init__(self, first, second, third):
        print("Я в __init__")
        print(f"first: {first}")   # Первый позиционный аргумент
        print(f"second: {second}") # Именованный аргумент second
        print(f"third: {third}")   # Именованный аргумент third

# Создаём объект
ex = Example('data', second=25, third=3.14)

class Animal:  # Родительский класс Animal (основной класс, от которого будут наследоваться другие).
    def __init__(self, species):  # Метод инициализации (__init__), задающий вид животного.
        self.species = species  # Устанавливаем атрибут 'species' объекта равным переданному значению.
        print(f"Я животное, вид: {self.species}")  # Выводим сообщение с указанием вида животного.

class Dog(Animal):  # Дочерний класс Dog, который наследуется от родительского класса Animal.
    def __init__(self, name, species="Собака"):  # Метод инициализации с двумя параметрами: 'name' и 'species' (по умолчанию "Собака").
        # super() — встроенная функция Python для вызова методов родительского класса.
        # Синтаксис: super().method_name(arguments)
        # Здесь: super().__init__(species) вызывает метод __init__ класса Animal и передаёт ему аргумент 'species'.
        super().__init__(species)  # Инициализируем атрибут 'species' с помощью конструктора родительского класса.
        self.name = name  # Устанавливаем атрибут 'name' объекта равным переданному значению.
        print(f"Моё имя: {self.name}")  # Выводим сообщение с указанием имени собаки.

# Создаём объект класса Dog с именем "Шарик" (по умолчанию 'species' будет "Собака").
dog = Dog("Шарик")


# DZ 21
class House:  # Создаем класс House (Дом)

    houses_history = []  # Атрибут класса House - пустой список, который будет хранить историю всех домов.

    # Метод __new__ — это специальный метод, который вызывается перед методом __init__.
    # Его задача — создать и вернуть новый объект.
    # Он принимает класс (cls) как первый аргумент, а также любые дополнительные аргументы,
    # переданные при создании объекта.
    # Важно, чтобы метод __new__ возвращал новый экземпляр класса, потому что этот экземпляр
    # затем будет передан в метод __init__ для инициализации.
    def __new__(cls, *args, **kwargs):
        cls.houses_history.append(args[0])  # Добавляем значение нулевого индекса из args (например, имя дома)
        # В этом случае предполагается, что первым аргументом будет имя дома.
        # Этот список хранит все дома, созданные с использованием класса House.

        # Вызов родительского метода __new__ у базового класса object.
        # Метод __new__ создаёт новый экземпляр объекта, который будет использоваться в программе.
        # Мы передаем управление методу __new__ родительского класса object для создания объекта.
        return object.__new__(cls)  # Создает новый экземпляр объекта, возвращая его.

    def __init__(self, name, number_of_floors): # инициализация. self - ссылка на саму себя, атрибуты: name - название, number_of_floors - номер этажа
        self.name = name # устанавливаем значение атрибута name = name
        self.number_of_floors = number_of_floors # устанавливаем значение атрибута number_of_floors = number_of_floors

    def go_to(self, new_floor): # метод в классе
        if new_floor > self.number_of_floors or new_floor < 1: # Если new_floor больше чем self.number_of_floors или меньше 1
            return print('Такого этажа не существует') # возвращаем Такого этажа не существует
        else: # иначе
            for i in range(1, new_floor + 1): # для(for) i в(in) range(1, new_floor + 1)
                                              # range(start, stop, step) - stop не включительный
                print (i)

    def __len__(self): # метод __len__ возвращает длину массива, всегда int
        return self.number_of_floors # возвращаем номер/длину этажей

    # Перегрузка оператора "str()" (представление объекта в виде строки).
    # Метод __str__ является специальным методом, предназначенным для представления строкового представления объекта.
    # Метод '__str__()' определяет, как объект будет выглядеть при вызове функции str() или print().
    def __str__(self):
        return f'Название: {self.name}, кол-во этажей {self.number_of_floors}'

    # Деструктор - уничтожение объекта.
    # Этот метод вызывается, когда объект уничтожается или когда на него больше не остаётся ссылок.
    def __del__(self):
        print(f'{self.name} снесен, но он останется в истории')
        # Здесь можно освободить ресурсы или выполнить другие действия перед уничтожением объекта.
        # Например, можно добавить запись в журнал или очистить какие-то внешние ресурсы.
        # Для заглушки можно использовать pass, если не требуется выполнять дополнительные действия.

    # Перезагрузка оператора "==" (равно).
    # Метод '__eq__()' (Equal) определяет, что должно происходить при использовании оператора "==" для объектов данного класса.
    # В данном примере: два объекта будут сравниваться на основе их атрибутов number_of_floors == number_of_floors
    # Функция isinstance() используется для проверки принадлежности объекта к определенному классу или типу данных.
    ## isinstance - (объект, (тип данных)) - выдает true(истина) или false(ложь)
    def __eq__(self, other):
        if isinstance(other, House):
            return self.number_of_floors == other.number_of_floors

    # Перегрузка оператора "<" (меньше чем).
    # Метод '__lt__()' (Lower Than) определяет, что должно происходить при использовании оператора "<" для объектов данного класса.
    # В данном примере: два объекта будут сравниваться на основе их атрибута 'age'
    def __lt__(self, other):
        if isinstance(other, House):
            return self.number_of_floors < other.number_of_floors

    # Перегрузка оператора "<=" (меньше или равно).
    # Метод '__le__()' (Lower or Equal) определяет, что должно происходить при использовании оператора "<=".
    # В данном примере: проверяется, меньше или равен атрибут 'age' у одного объекта по сравнению с другим.
    def __le__(self, other):
        if isinstance(other, House):
            return self.number_of_floors <= other.number_of_floors

    # Перегрузка оператора ">" (больше чем).
    # Метод '__gt__()' (Greater Than) определяет, что должно происходить при использовании оператора ">".
    # В данном примере: два объекта сравниваются на основе их атрибута 'number_of_floors', проверяя, больше ли он.
    def __gt__(self, other):
        if isinstance(other, House):
            return self.number_of_floors > other.number_of_floors

    # Перегрузка оператора ">=" (больше или равно).
    # Метод '__ge__()' (Greater or Equal) определяет, что должно происходить при использовании оператора ">=".
    # В данном примере: проверяется, больше или равен атрибут 'number_of_floors' у одного объекта по сравнению с другим.
    def __ge__(self, other):
        if isinstance(other, House):
            return self.number_of_floors >= other.number_of_floors

    # Перегрузка оператора "!=" (не равно).
    # Метод '__ne__()' (Not Equal) определяет, что должно происходить при использовании оператора "!=".
    # В данном примере: проверяется, различаются ли значения атрибута 'number_of_floors' у двух объектов.
    def __ne__(self, other):
        if isinstance(other, House):
            return self.number_of_floors != other.number_of_floors

    # Перегрузка оператора "+" (сложение).
    # Метод '__add__()' (Addition) определяет, что должно происходить при использовании оператора "+".
    # В данном примере: добавляется целочисленное значение к атрибуту 'number_of_floors' текущего объекта.
    # Если переданный параметр не является целым числом, метод ничего не делает.
    def __add__(self, value):
        # Проверяем, является ли переданное значение целым числом.
        if isinstance(value, int):
            # Добавляем значение к атрибуту 'number_of_floors' текущего объекта.
            self.number_of_floors += value
            # Возвращаем текущий объект, чтобы можно было использовать результат в цепочке операций.
            return self

    # Перегрузка оператора "+" (сложение) с правым операндом.
    # Метод '__radd__()' вызывается, если объект класса находится справа от оператора "+".
    # В данном примере: если value является числом (int), то метод возвращает сумму атрибута 'number_of_floors' текущего объекта и value.
    # Использование: число + объект
    def __radd__(self, value):
        if isinstance(value, int):
            self.number_of_floors += value # Добавляем значение к атрибуту 'number_of_floors' текущего объекта.
            return self # возвращаем текущий объект

    # Перегрузка оператора "+=" (сложение с присваиванием).
    # Метод '__iadd__()' определяет поведение при использовании оператора "+=".
    # В данном примере: если value является числом (int), то метод изменяет значение атрибута 'number_of_floors' текущего объекта, увеличивая его на value.
    # После этого возвращает текущий объект (self), чтобы оператор "+=" работал корректно.
    # Использование: объект += число
    def __iadd__(self, value):
        if isinstance(value, int):
            self.number_of_floors += value  # Добавляем значение к атрибуту 'number_of_floors' текущего объекта.
            return self  # возвращаем текущий объект

    ### НЬАНСЫ ПРИ РАБОТЕ С АРИФМИТИЧЕСКИМИ ОПЕРАТОРАМИ  ###
    # Если ваша цель — Добавление значения к атрибуту объекта и изменение объекта:
    # def __add__(self, value):
    #     if isinstance(value, int):
    #         self.number_of_floors += value  # Сохраняем результат сложения в атрибуте
    #         return self  # Возвращаем текущий объект

    # Если ваша цель — Возвращение результата сложения, не изменяя объект:
    # def __add__(self, value):
    #     if isinstance(value, int):
    #         return self.number_of_floors + value  # Возвращаем результат сложения

    # ПРИМЕР ОСТАЛЬНЫХ АРИФМЕТИЧЕСКИХ ОПЕРАТОРОВ
            # ПРИЧМЕЧАНИЕ #
            # Да, если добавить i к названию метода
            # Использовать __iadd__ вместо __add__, это изменяет поведение оператора так, чтобы он работал как оператор присваивания с арифметикой (+=).
        # Перегрузка оператора "+" (сложение).
        # Метод '__add__()' определяет, что должно происходить при использовании оператора "+".
        # В данном примере: складываются значения атрибута 'атрибут' двух объектов.

        # Перегрузка оператора "-" (вычитание).
        # Метод '__sub__()' (Subtraction) определяет, что должно происходить при использовании оператора "-".
        # В данном примере: вычитается значение атрибута 'атрибут' одного объекта из другого.

        # Перегрузка оператора "*" (умножение).
        # Метод '__mul__()' (Multiplication) определяет, что должно происходить при использовании оператора "*".
        # В данном примере: значения атрибута 'атрибут' двух объектов перемножаются.

        # Перегрузка оператора "/" (деление).
        # Метод '__truediv__()' (True Division) определяет, что должно происходить при использовании оператора "/".
        # В данном примере: значение атрибута 'атрибут' одного объекта делится на значение другого.

        # Перегрузка оператора "//" (целочисленное деление).
        # Метод '__floordiv__()' (Floor Division) определяет, что должно происходить при использовании оператора "//".
        # В данном примере: выполняется целочисленное деление значений атрибута 'атрибут'.

        # Перегрузка оператора "%" (остаток от деления).
        # Метод '__mod__()' (Modulo) определяет, что должно происходить при использовании оператора "%".
        # В данном примере: вычисляется остаток от деления значений атрибута 'атрибут' двух объектов.

        # Перегрузка оператора "**" (возведение в степень).
        # Метод '__pow__()' (Power) определяет, что должно происходить при использовании оператора "**".
        # В данном примере: значение атрибута 'атрибут' одного объекта возводится в степень, равную значению другого.


# h1 = House('ЖК Горский', 18)
# h2 = House('Домик в деревне', 2)
#
# print(f'{h1.name, h1.number_of_floors}') # я про этот принт
# h1.go_to(10)
# print(f'{h2.name, h2.number_of_floors}') # я про этот принт
# h2.go_to(10)

# __str__
# print(h1) # получаем srt представление об объекте # то есть принт выше мы можем не использовать, чтобы получить информацию, мы уже добавили метод, который это делает
# print(h2) # получаем srt представление об объекте
#
# # __len__
# print(len(h1)) # len возвращает длину объекта (в данном случаи номер/длину этажей)
# print(len(h2)) # len возвращает длину объекта (в данном случаи номер/длину этажей)
#
# h1 = House('ЖК Эльбрус', 10)
# h2 = House('ЖК Акация', 20)
#
# print(h1)
# print(h2)
#
# print(h1 == h2) # __eq__
#
# h1 = h1 + 10 # __add__
# print(h1)
# print(h1 == h2)
#
# h1 += 10 # __iadd__
# print(h1)
#
# h2 = 10 + h2 # __radd__
# print(h2)
#
# print(h1 > h2) # __gt__
# print(h1 >= h2) # __ge__
# print(h1 < h2) # __lt__
# print(h1 <= h2) # __le__
# print(h1 != h2) # __ne__

h1 = House('ЖК Эльбрус', 10)
print(House.houses_history)
h2 = House('ЖК Акация', 20)
print(House.houses_history)
h3 = House('ЖК Матрёшки', 20)
print(House.houses_history)

# Удаление объектов
del h2
del h3

print(House.houses_history)

# DZ 21
class House:  # Создаем класс House (Дом)

    houses_history = []  # Атрибут класса House - пустой список, который будет хранить историю всех домов.

    # Метод __new__ — это специальный метод, который вызывается перед методом __init__.
    # Его задача — создать и вернуть новый объект.
    # Он принимает класс (cls) как первый аргумент, а также любые дополнительные аргументы,
    # переданные при создании объекта.
    # Важно, чтобы метод __new__ возвращал новый экземпляр класса, потому что этот экземпляр
    # затем будет передан в метод __init__ для инициализации.
    def __new__(cls, *args, **kwargs):
        cls.houses_history.append(args[0])  # Добавляем значение нулевого индекса из args (например, имя дома)
        # В этом случае предполагается, что первым аргументом будет имя дома.
        # Этот список хранит все дома, созданные с использованием класса House.

        # Вызов родительского метода __new__ у базового класса object.
        # Метод __new__ создаёт новый экземпляр объекта, который будет использоваться в программе.
        # Мы передаем управление методу __new__ родительского класса object для создания объекта.
        return object.__new__(cls)  # Создает новый экземпляр объекта, возвращая его.

    def __init__(self, name, number_of_floors): # инициализация. self - ссылка на саму себя, атрибуты: name - название, number_of_floors - номер этажа
        self.name = name # устанавливаем значение атрибута name = name
        self.number_of_floors = number_of_floors # устанавливаем значение атрибута number_of_floors = number_of_floors

    # Деструктор - уничтожение объекта.
    # Этот метод вызывается, когда объект уничтожается или когда на него больше не остаётся ссылок.
    def __del__(self):
        print(f'{self.name} снесен, но он останется в истории')
        # Здесь можно освободить ресурсы или выполнить другие действия перед уничтожением объекта.
        # Например, можно добавить запись в журнал или очистить какие-то внешние ресурсы.
        # Для заглушки можно использовать pass, если не требуется выполнять дополнительные действия.

    def go_to(self, new_floor): # метод в классе
        if new_floor > self.number_of_floors or new_floor < 1: # Если new_floor больше чем self.number_of_floors или меньше 1
            return print('Такого этажа не существует') # возвращаем Такого этажа не существует
        else: # иначе
            for i in range(1, new_floor + 1): # для(for) i в(in) range(1, new_floor + 1)
                                              # range(start, stop, step) - stop не включительный
                print (i)

    def __len__(self): # метод __len__ возвращает длину массива, всегда int
        return self.number_of_floors # возвращаем номер/длину этажей

    # Перегрузка оператора "str()" (представление объекта в виде строки).
    # Метод __str__ является специальным методом, предназначенным для представления строкового представления объекта.
    # Метод '__str__()' определяет, как объект будет выглядеть при вызове функции str() или print().
    def __str__(self):
        return f'Название: {self.name}, кол-во этажей {self.number_of_floors}'

    # Перезагрузка оператора "==" (равно).
    # Метод '__eq__()' (Equal) определяет, что должно происходить при использовании оператора "==" для объектов данного класса.
    # В данном примере: два объекта будут сравниваться на основе их атрибутов number_of_floors == number_of_floors
    # Функция isinstance() используется для проверки принадлежности объекта к определенному классу или типу данных.
    ## isinstance - (объект, (тип данных)) - выдает true(истина) или false(ложь)
    def __eq__(self, other):
        if isinstance(other, House):
            return self.number_of_floors == other.number_of_floors

    # Перегрузка оператора "<" (меньше чем).
    # Метод '__lt__()' (Lower Than) определяет, что должно происходить при использовании оператора "<" для объектов данного класса.
    # В данном примере: два объекта будут сравниваться на основе их атрибута 'age'
    def __lt__(self, other):
        if isinstance(other, House):
            return self.number_of_floors < other.number_of_floors

    # Перегрузка оператора "<=" (меньше или равно).
    # Метод '__le__()' (Lower or Equal) определяет, что должно происходить при использовании оператора "<=".
    # В данном примере: проверяется, меньше или равен атрибут 'age' у одного объекта по сравнению с другим.
    def __le__(self, other):
        if isinstance(other, House):
            return self.number_of_floors <= other.number_of_floors

    # Перегрузка оператора ">" (больше чем).
    # Метод '__gt__()' (Greater Than) определяет, что должно происходить при использовании оператора ">".
    # В данном примере: два объекта сравниваются на основе их атрибута 'number_of_floors', проверяя, больше ли он.
    def __gt__(self, other):
        if isinstance(other, House):
            return self.number_of_floors > other.number_of_floors

    # Перегрузка оператора ">=" (больше или равно).
    # Метод '__ge__()' (Greater or Equal) определяет, что должно происходить при использовании оператора ">=".
    # В данном примере: проверяется, больше или равен атрибут 'number_of_floors' у одного объекта по сравнению с другим.
    def __ge__(self, other):
        if isinstance(other, House):
            return self.number_of_floors >= other.number_of_floors

    # Перегрузка оператора "!=" (не равно).
    # Метод '__ne__()' (Not Equal) определяет, что должно происходить при использовании оператора "!=".
    # В данном примере: проверяется, различаются ли значения атрибута 'number_of_floors' у двух объектов.
    def __ne__(self, other):
        if isinstance(other, House):
            return self.number_of_floors != other.number_of_floors

    # Перегрузка оператора "+" (сложение).
    # Метод '__add__()' (Addition) определяет, что должно происходить при использовании оператора "+".
    # В данном примере: добавляется целочисленное значение к атрибуту 'number_of_floors' текущего объекта.
    # Если переданный параметр не является целым числом, метод ничего не делает.
    def __add__(self, value):
        # Проверяем, является ли переданное значение целым числом.
        if isinstance(value, int):
            # Добавляем значение к атрибуту 'number_of_floors' текущего объекта.
            self.number_of_floors += value
            # Возвращаем текущий объект, чтобы можно было использовать результат в цепочке операций.
            return self

    # Перегрузка оператора "+" (сложение) с правым операндом.
    # Метод '__radd__()' вызывается, если объект класса находится справа от оператора "+".
    # В данном примере: если value является числом (int), то метод возвращает сумму атрибута 'number_of_floors' текущего объекта и value.
    # Использование: число + объект
    def __radd__(self, value):
        if isinstance(value, int):
            self.number_of_floors += value # Добавляем значение к атрибуту 'number_of_floors' текущего объекта.
            return self # возвращаем текущий объект

    # Перегрузка оператора "+=" (сложение с присваиванием).
    # Метод '__iadd__()' определяет поведение при использовании оператора "+=".
    # В данном примере: если value является числом (int), то метод изменяет значение атрибута 'number_of_floors' текущего объекта, увеличивая его на value.
    # После этого возвращает текущий объект (self), чтобы оператор "+=" работал корректно.
    # Использование: объект += число
    def __iadd__(self, value):
        if isinstance(value, int):
            self.number_of_floors += value  # Добавляем значение к атрибуту 'number_of_floors' текущего объекта.
            return self  # возвращаем текущий объект

    ### НЬАНСЫ ПРИ РАБОТЕ С АРИФМИТИЧЕСКИМИ ОПЕРАТОРАМИ  ###
    # Если ваша цель — Добавление значения к атрибуту объекта и изменение объекта:
    # def __add__(self, value):
    #     if isinstance(value, int):
    #         self.number_of_floors += value  # Сохраняем результат сложения в атрибуте
    #         return self  # Возвращаем текущий объект

    # Если ваша цель — Возвращение результата сложения, не изменяя объект:
    # def __add__(self, value):
    #     if isinstance(value, int):
    #         return self.number_of_floors + value  # Возвращаем результат сложения

    # ПРИМЕР ОСТАЛЬНЫХ АРИФМЕТИЧЕСКИХ ОПЕРАТОРОВ
            # ПРИЧМЕЧАНИЕ #
            # Да, если добавить i к названию метода
            # Использовать __iadd__ вместо __add__, это изменяет поведение оператора так, чтобы он работал как оператор присваивания с арифметикой (+=).
        # Перегрузка оператора "+" (сложение).
        # Метод '__add__()' определяет, что должно происходить при использовании оператора "+".
        # В данном примере: складываются значения атрибута 'атрибут' двух объектов.

        # Перегрузка оператора "-" (вычитание).
        # Метод '__sub__()' (Subtraction) определяет, что должно происходить при использовании оператора "-".
        # В данном примере: вычитается значение атрибута 'атрибут' одного объекта из другого.

        # Перегрузка оператора "*" (умножение).
        # Метод '__mul__()' (Multiplication) определяет, что должно происходить при использовании оператора "*".
        # В данном примере: значения атрибута 'атрибут' двух объектов перемножаются.

        # Перегрузка оператора "/" (деление).
        # Метод '__truediv__()' (True Division) определяет, что должно происходить при использовании оператора "/".
        # В данном примере: значение атрибута 'атрибут' одного объекта делится на значение другого.

        # Перегрузка оператора "//" (целочисленное деление).
        # Метод '__floordiv__()' (Floor Division) определяет, что должно происходить при использовании оператора "//".
        # В данном примере: выполняется целочисленное деление значений атрибута 'атрибут'.

        # Перегрузка оператора "%" (остаток от деления).
        # Метод '__mod__()' (Modulo) определяет, что должно происходить при использовании оператора "%".
        # В данном примере: вычисляется остаток от деления значений атрибута 'атрибут' двух объектов.

        # Перегрузка оператора "**" (возведение в степень).
        # Метод '__pow__()' (Power) определяет, что должно происходить при использовании оператора "**".
        # В данном примере: значение атрибута 'атрибут' одного объекта возводится в степень, равную значению другого.


# h1 = House('ЖК Горский', 18)
# h2 = House('Домик в деревне', 2)
#
# print(f'{h1.name, h1.number_of_floors}') # я про этот принт
# h1.go_to(10)
# print(f'{h2.name, h2.number_of_floors}') # я про этот принт
# h2.go_to(10)

# __str__
# print(h1) # получаем srt представление об объекте # то есть принт выше мы можем не использовать, чтобы получить информацию, мы уже добавили метод, который это делает
# print(h2) # получаем srt представление об объекте
#
# # __len__
# print(len(h1)) # len возвращает длину объекта (в данном случаи номер/длину этажей)
# print(len(h2)) # len возвращает длину объекта (в данном случаи номер/длину этажей)
#
# h1 = House('ЖК Эльбрус', 10)
# h2 = House('ЖК Акация', 20)
#
# print(h1)
# print(h2)
#
# print(h1 == h2) # __eq__
#
# h1 = h1 + 10 # __add__
# print(h1)
# print(h1 == h2)
#
# h1 += 10 # __iadd__
# print(h1)
#
# h2 = 10 + h2 # __radd__
# print(h2)
#
# print(h1 > h2) # __gt__
# print(h1 >= h2) # __ge__
# print(h1 < h2) # __lt__
# print(h1 <= h2) # __le__
# print(h1 != h2) # __ne__

h1 = House('ЖК Эльбрус', 10)
print(House.houses_history)
h2 = House('ЖК Акация', 20)
print(House.houses_history)
h3 = House('ЖК Матрёшки', 20)
print(House.houses_history)

# Удаление объектов
del h2
del h3

print(House.houses_history)

# КЛАСС С ПРИМЕНЕНИЕМ __new__

class User:
    # __instance — это атрибут класса, который хранит ссылку на единственный экземпляр класса (если он уже был создан).
    # Используется для реализации паттерна Singleton (синглтон), где допускается только один объект данного класса.
    __instance = None

    # Метод __new__ отвечает за создание нового объекта.
    # cls — это ссылка на сам класс User, аналогично self для методов экземпляра.

    # Метод __new__ используется для контроля над процессом создания объектов.
    # Применяется в паттернах Singleton, работе с неизменяемыми типами,
    # создании кэша или при необходимости управлять доступом к объектам.
    def __new__(cls, *args, **kwargs):
        print(f'Я в нью')  # Этот вывод помогает понять, что метод __new__ был вызван.

        # Проверяем, существует ли уже экземпляр класса. Если он не создан, создаём его.
        if cls.__instance is None:
            # super().__new__(cls) вызывает родительский метод __new__, который создаёт объект.
            # В данном случае super() вызывает __new__ у родительского класса object, что создаёт новый объект.
            cls.__instance = super().__new__(cls)
            # Возвращаем единственный экземпляр класса.
        return cls.__instance

        # Метод __init__ отвечает за инициализацию созданного объекта.

    # self указывает на экземпляр объекта, который был возвращён методом __new__.
    def __init__(self, *args, **kwargs):
        print(f'Я в ините')  # Этот вывод помогает понять, что метод __init__ был вызван.

        # Сохраняем позиционные аргументы в атрибуте args объекта.
        self.args = args

        # Проходимся по именованным аргументам (kwargs).
        # Для каждого ключа-значения создаём атрибут объекта с соответствующим именем.
        for key, value in kwargs.items():
            setattr(self, key, value)  # setattr динамически создаёт атрибуты объекта.
            # Синтаксис функции setattr:
            # setattr(object, name, value)
            # object: Это объект, для которого вы хотите задать или изменить атрибут.
            # name: Это имя атрибута, которое вы хотите создать или изменить. Оно передается как строка (тип данных: str).
            # value: Это значение, которое будет присвоено атрибуту. Оно может быть любого типа данных.

            # setattr полезен, когда вам нужно создавать атрибуты в объекте динамически, например, когда вы не знаете заранее, какие именно атрибуты будут добавлены.

# __mro__ (Method Resolution Order) показывает порядок поиска методов.
# Он определяет, в каком порядке будут искаться методы в классе и его родителях.
print(User.__mro__)

# Вывод будет: (<class '__main__.User'>, <class 'object'>),
# так как User наследуется от object, это стандарт для Python классов.

other = [1, 2, 3, 4, 5]  # Позиционные аргументы, которые передаются в класс.
user = {'name': 'Artem', 'age': 24, 'gender': 'male'}  # Именованные аргументы (словарь), которые передаются в класс.

user1 = User(*other, **user)
# Создаётся объект класса User. В процессе выполнения происходит:
# 1. Вызов метода __new__:
#    - Если объекта не существует, создаётся новый экземпляр.
#    - Возвращается ссылка на экземпляр.
# 2. Вызов метода __init__:
#    - Инициализируется экземпляр, создаются атрибуты args и атрибуты из kwargs.

print(user1.args)
# Вывод: (1, 2, 3, 4, 5)
# Атрибут args содержит переданные позиционные аргументы, упакованные в кортеж.

print(user1.name)
# Вывод: 'Artem'
# Атрибут name был добавлен через именованные аргументы kwargs.

print(user1.age)
# Вывод: 24
# Аналогично name, атрибут age добавлен через kwargs.

print(user1.gender)
# Вывод: 'male'
# gender также добавлен через именованные аргументы kwargs.

print(dir(user1))
# Если аргументом является объект, dir() выведет все доступные атрибуты и методы этого объекта.

print(user1.__dict__)
# Атрибут __dict__ возвращает словарь всех изменяемых атрибутов объекта или класса.
# Это позволяет получить, добавить или изменить атрибуты объекта динамически.

class Example:
    def __new__(cls, *args, **kwargs):
        print("Я в __new__")
        print(f"args: {args}")     # Позиционные аргументы
        print(f"kwargs: {kwargs}") # Именованные аргументы
        return object.__new__(cls) # Создаём новый объект класса Example

    def __init__(self, first, second, third):
        print("Я в __init__")
        print(f"first: {first}")   # Первый позиционный аргумент
        print(f"second: {second}") # Именованный аргумент second
        print(f"third: {third}")   # Именованный аргумент third

# Создаём объект
ex = Example('data', second=25, third=3.14)

class Animal:  # Родительский класс Animal (основной класс, от которого будут наследоваться другие).
    def __init__(self, species):  # Метод инициализации (__init__), задающий вид животного.
        self.species = species  # Устанавливаем атрибут 'species' объекта равным переданному значению.
        print(f"Я животное, вид: {self.species}")  # Выводим сообщение с указанием вида животного.

class Dog(Animal):  # Дочерний класс Dog, который наследуется от родительского класса Animal.
    def __init__(self, name, species="Собака"):  # Метод инициализации с двумя параметрами: 'name' и 'species' (по умолчанию "Собака").
        # super() — встроенная функция Python для вызова методов родительского класса.
        # Синтаксис: super().method_name(arguments)
        # Здесь: super().__init__(species) вызывает метод __init__ класса Animal и передаёт ему аргумент 'species'.
        super().__init__(species)  # Инициализируем атрибут 'species' с помощью конструктора родительского класса.
        self.name = name  # Устанавливаем атрибут 'name' объекта равным переданному значению.
        print(f"Моё имя: {self.name}")  # Выводим сообщение с указанием имени собаки.

# Создаём объект класса Dog с именем "Шарик" (по умолчанию 'species' будет "Собака").
dog = Dog("Шарик")

###

class Database:
    # Класс для управления базой данных пользователей

    def __init__(self):
        # Инициализация объекта класса Database
        # Создаётся пустой словарь для хранения данных пользователей
        self.data = {}

    def add_user(self, username, password):
        # Метод добавления пользователя в базу данных
        # Аргументы: username (логин), password (пароль)
        # Добавляет в словарь self.data новую пару ключ-значение
        # username — ключ, password — значение
        self.data[username] = password


class User:
    """
    Класс пользователя, содержащий атрибуты: логин и пароль
    Проверяет пароль на длину (8+), наличие заглавной буквы и цифры.
    """
    def __init__(self, username, password, password_confirm):
        # Инициализация объекта класса User
        # Аргументы: username (логин), password (пароль), password_confirm (подтверждение пароля)
        self.username = username  # Присваиваем логин атрибуту объекта
        # Проверяем, что пароль содержит длину в +8 символов и хотя бы одну заглавную букву и хотя бы одну цифру.
        # len(password) >= 8 - проверяет длину пароля больше или равно 8 символам
        # any(i.isupper() for i in password) — проверяет, есть ли хотя бы одна заглавная буква в строке:
        #     - i.isupper() возвращает True для каждого символа, который является заглавной буквой.
        #     - any() возвращает True, если хотя бы один символ строки является заглавной буквой.
        # any(i.isdigit() for i in password) — проверяет, есть ли хотя бы одна цифра в строке:
        #     - i.isdigit() возвращает True для каждого символа, который является цифрой.
        #     - any() возвращает True, если хотя бы один символ строки является цифрой.
        # Если три условия выполняются, продолжаем проверку и сравниваем пароль с подтверждением.
        if len(password) >= 8 and any(i.isupper() for i in password) and any(i.isdigit() for i in password):
            if password == password_confirm:
                self.password = password
        else:
            print('Пароль должен содержать не менее 8 символов, одну цифру и одну заглавную букву')



# Основной блок программы
# Этот блок выполняется только если скрипт запускается напрямую, а не импортируется
if __name__ == '__main__':
    # Создается объект 'database', в котором создается экземпляр класса Database.
    database = Database()
    while True:
        # \n — символ новой строки. При выводе переводит текст на следующую строку. Используется для форматирования текста.
        choice = int(input('Приветствую! Выберите действие: \n1 - Вход\n2 - Регистрация\n'))
        if choice == 1:
            # Вход пользователя
            login = input('Введите логин: ')
            password = input('Введите пароль: ')
            if login in database.data:
                if password == database.data[login]:
                    print(f'Вход выполнен, {login}')
                    break
                else:
                    print('Неверный пароль')
            else:
                print('Пользователь не найден')
        if choice == 2:
            # Регистрация пользователя
            # Создаём объект класса User, используя ввод пользователя
            user = User(
                input('Введите логин: '),  # Запрашиваем у пользователя логин
                password := input('Введите пароль: '),  # Запрашиваем у пользователя пароль
                password2 := input('Повторите пароль: ')  # Запрашиваем подтверждение пароля
            )
        # Моржовый оператор (:=) позволяет одновременно присваивать и возвращать значение.
        # Используется для сокращения кода и удобства работы внутри выражений.
        # Не работает в глобальном пространстве имен.

        # Пример использования:
        # 1. Присваивание внутри условия:
        # if (n := len(value)) > 5:  # Присваивает len(value) переменной n и сразу проверяет условие
        #     print(f"Длина строки: {n}")

        # 2. Упрощение циклов:
        # while (line := input("Введите строку: ")) != "exit":  # Присваивает результат input переменной line
        #     print(f"Вы ввели: {line}")
        # Добавляем нового пользователя в базу данных
        # В качестве аргументов передаём логин и пароль объекта user
            if password != password2:
                print('Пароли не совпадает, попробуй еще раз')
                continue
                #exit()
        # Функция exit() — это встроенная функция Python, предназначенная для завершения работы программы.
        # exit(code)
        # Параметр code (опционально): числовой код возврата, который сообщает операционной системе о результате завершения программы.
        # 0 — успешное завершение (по умолчанию).
        # Любое ненулевое значение — ошибка.
            database.add_user(user.username, user.password)

        # Печатаем содержимое словаря self.data
        print(database.data)
        # Атрибут __dict__ возвращает словарь всех изменяемых атрибутов объекта или класса.
        # Это позволяет получить, добавить или изменить атрибуты объекта динамически.
        print(database.__dict__)
        # __mro__ (Method Resolution Order) показывает порядок поиска методов.
        # Он определяет, в каком порядке будут искаться методы в классе и его родителях.
        print(Database.__mro__)


# DZ 22
# Комментарии добавлял GPT #
from time import sleep

# Класс пользователя
class User:
    def __init__(self, nickname, password, age):
        self.nickname = nickname  # Имя пользователя
        self.password = hash(password)  # Хэшированный пароль для безопасности
        self.age = age  # Возраст пользователя

    # Метод __repr__()
    # __repr__(self)
    #
    # Описание:
    # Метод __repr__() используется для создания строкового представления объекта.
    # Это представление предназначено для отладки и демонстрации объекта. Когда объект выводится
    # или преобразуется в строку, вызывается метод __repr__().
    # Если метод __repr__() реализован, он заменяет стандартное представление объекта (которое обычно
    # выглядит как адрес в памяти) на более осмысленную строку, которая может быть использована для
    # восстановления объекта.
    # Идеально, если строка, возвращаемая __repr__(), может быть использована для воссоздания объекта.

    def __repr__(self):
        return f'{self.nickname}, {self.password}, {self.age}'


# Класс видео
class Video:
    def __init__(self, title, duration, time_now=0, adult_mode=False):
        self.title = title  # Название видео
        self.duration = duration  # Продолжительность видео в секундах
        self.time_now = time_now  # Текущее время просмотра видео
        self.adult_mode = adult_mode  # Флаг возрастного ограничения

    def __repr__(self):
        return f'{self.title}'


# Основной класс приложения
class UrTube:
    def __init__(self):
        self.users = []  # Список зарегистрированных пользователей
        self.videos = []  # Список добавленных видео
        self.current_user = None  # Текущий пользователь

    def __repr__(self):
        return f'{self.users}, {self.videos}, {self.current_user}'

    # Авторизация пользователя
    def log_in(self, nickname, password):
        pas = hash(password)  # Хэшируем введённый пароль
        for i in self.users:  # Цикл используется для проверки учетных данных.
                              # Переменная `i` принимает значения объектов класса `User`, чтобы сравнить `nickname` и `password` с вводимыми данными.
                              # Мы можем обращаться к атрибутам класса `User`, так как в `self.users` хранятся его объекты.
            if nickname == i.nickname and pas == i.password:  # Проверяем совпадение логина и пароля
                self.current_user = nickname  # Устанавливаем текущего пользователя
                print(f'Пользователь {nickname} вошел в аккаунт')

    # Регистрация пользователя
    def register(self, nickname, password, age):
        # Проверяем, существует ли пользователь с таким никнеймом
        if any(p.nickname == nickname for p in self.users):  # Используем цикл для проверки существования пользователя.
                                                             # Переменная `p` принимает значения объектов класса `User` из списка `self.users`.
                                                             # Мы можем обращаться к их атрибутам (например, `p.nickname`), так как `self.users` хранит экземпляры класса `User`.
            print(f'Юзер {nickname} уже существует')
        else:
            obj = User(nickname, password, age)  # Создаём нового пользователя
            self.users.append(obj)  # Добавляем его в список пользователей
            self.current_user = nickname  # Устанавливаем текущего пользователя
            print(f'Пользователь {nickname} вошел в аккаунт')

    # Выход из аккаунта
    def log_out(self):
        self.current_user = None  # Убираем текущего пользователя

    # Добавление видео
    def add(self, *other): # *other - создает кортеж
        self.videos.extend(other)  # Добавляем в список наш кортеж
        return self.videos

        # Поиск видео по ключевому слову

    def get_videos(self, other):
        value = other.lower()  # Приводим ключевое слово к нижнему регистру для удобства поиска
        get_videos1 = []  # Создаём список для подходящих видео
        for x in self.videos:  # Цикл перебирает объекты `Video` в списке `self.videos`.
                               # Переменная `x` принимает значения каждого объекта видео, добавленного в список.
                               # Мы можем обращаться к атрибутам класса `Video` (например, `x.title`), так как в `self.videos` хранятся экземпляры этого класса.
            if value in x.title.lower():  # Проверяется, содержится ли ключевое слово (`value`) в названии текущего видео (`x.title`).
                # Название видео также приводится к нижнему регистру для корректного поиска без учёта регистра.
                get_videos1.append(x.title)  # Добавляем название видео в список, если условие выполняется
        return get_videos1  # Возвращаем список найденных видео

    # Просмотр видео
    def watch_video(self, film):
        if not self.current_user:  # Если пользователь не авторизован
            print('Войдите в аккаунт')
            return
        for i in self.videos:  # Цикл перебирает все объекты `Video`, добавленные в список `self.videos`.
                               # Переменная `i` последовательно принимает каждое видео.
                               # Мы можем обращаться к атрибутам класса `Video`, так как в `self.videos` хранятся его объекты.
            if film in i.title:  # Если найдено видео с указанным названием
                for k in self.users:  # Цикл используется для проверки текущего пользователя.
                                      # Переменная `k` принимает значения объектов класса `User`, чтобы определить, есть ли возрастные ограничения на видео.
                                      # Мы можем обращаться к атрибутам объектов класса `User`, так как в `self.users` хранится список экземпляров этого класса.
                    if k.nickname == self.current_user and i.adult_mode:  # Если видео имеет ограничение 18+
                        # Проверяется, является ли текущий пользователь (`self.current_user`) тем же,
                        # кого представляет объект `k` из списка `self.users`.
                        # Это нужно, чтобы проверить ограничения именно для активного пользователя.
                        # Одновременно проверяется, включено ли возрастное ограничение для видео (`i.adult_mode`).
                        # Условие выполняется, если текущий пользователь совпадает с `k`, и видео предназначено для взрослых.
                        if k.age < 18:  # Проверяем возраст пользователя
                            # Если видео имеет ограничение для взрослых, проверяется возраст пользователя (`k.age`).
                            # Если возраст пользователя меньше 18 лет, доступ к видео блокируется.
                            # Пользователь получает сообщение о том, что он не может просмотреть видео.
                            print(f'Вам нет 18 лет для просмотра видео "{i.title}"')
                            return
                print(f'Воспроизводится видео: {i.title}')  # Начинаем воспроизведение
                for l in range(i.time_now, i.duration):  # Цикл, эмулирующий воспроизведение видео. Итерации проходят от текущего времени `i.time_now` до полной продолжительности `i.duration`.
                    sleep(1)  # Пауза в 1 секунду на каждом шаге симулирует проигрывание кадра.
                    i.time_now += 1  # Увеличиваем текущее время воспроизведения на 1 секунду.
                    print(f"Время: {i.time_now} сек")  # Выводим текущее время.
                print(f'Конец видео')  # Сообщаем о завершении воспроизведения
                i.time_now = 0  # Сбрасываем текущее время просмотра
                return
        print(f'Видео не найдено, повторите поиск')


# Создание экземпляра приложения
ur = UrTube()

# Создание объектов видео
v1 = Video('Лучший язык программирования 2024 года', 200)
v2 = Video('Для чего девушкам парень программист?', 10, adult_mode=True)

# Добавление видео
ur.add(v1, v2)

# Проверка поиска
print(ur.get_videos('лучший'))  # Ищем видео с ключевым словом "лучший"
print(ur.get_videos('ПРОГ'))  # Ищем видео с ключевым словом "ПРОГ"

# Попытка просмотра без авторизации
ur.watch_video('Для чего девушкам парень программист?')

# Регистрация и авторизация пользователей
ur.register('vasya_pupkin', 'lolkekcheburek', 13)
ur.watch_video('Для чего девушкам парень программист?')  # Попытка просмотра видео с ограничением
ur.register('test_mou_test', 'dlgkokLKDFJo2354F', 14)
ur.watch_video('Для чего девушкам парень программист?')
# ur.watch_video('Лучший язык программирования 2024 года') # воспроизводится
ur.register('urban_pythonist', 'iScX4vIJClb9YQavjAgF', 25)
ur.watch_video('Для чего девушкам парень программист?')  # Просмотр успешен

# Проверка входа в другой аккаунт
ur.register('vasya_pupkin', 'F8098FM8fjm9jmi', 55)
print(ur.current_user)  # Текущий пользователь

# Попытка воспроизведения несуществующего видео
ur.watch_video('Лучший язык программирования 2024 года!')


'''НАСЛЕДОВАНИЕ КЛАССОВ'''

# На самом деле символ нижнего подчеркивания и двойного нижнего подчеркивания в Python имеет очень широкий спектр применения
# Например, нижнее подчеркивание перед именем делает это имя "защищённым" (protected),
# предполагая его использование только внутри класса и его подклассов. Это особенно актуально для импортов.

class _Human:
    head = True  # Публичный атрибут: доступен для чтения и записи вне класса.
    _legs = True  # Защищённый атрибут: предполагается его использование только внутри класса и подклассов.
    __arms = True  # Приватный атрибут: недоступен напрямую из дочерних классов или экземпляров.
    # Символ двойного нижнего подчеркивания создаёт "обфускацию" имени (name mangling),
    # автоматически добавляя перед именем атрибута имя класса (например, _Human__arms).

    # Метод say_hello() логично вынести в родительский класс, так как он общий для всех людей.
    # Дочерние классы, такие как Student и Teacher, автоматически наследуют его.
    # Это позволяет использовать метод say_hello() для всех дочерних классов без необходимости его переопределения.
    def say_hello(self):
        print(f'Привет')

    # Метод about() демонстрирует доступ к атрибутам разных уровней "защищённости":
    # публичным (head), защищённым (_legs) и приватным (__arms).
    def about(self):
        print(self.head)  # Доступ к публичному атрибуту.
        print(self._legs)  # Доступ к защищённому атрибуту.
        print(self.__arms)  # Доступ к приватному атрибуту через обфусцированное имя (_Human__arms).

    # Конструктор (__init__) в родительском классе.
    # Если у дочернего класса не определён свой __init__, будет использоваться этот метод.
    # Важно: self в данном контексте ссылается на экземпляр дочернего класса,
    # поэтому вызовы методов и доступ к атрибутам могут быть переопределены в подклассе.
    def __init__(self):
        if hasattr(self, 'about'):  # Проверка на наличие метода about у текущего экземпляра.
            self.about()  # Вызов метода about(). Если метод переопределён в подклассе, вызовется версия подкласса.

# Класс Human является базовым (родительским) классом.
# Класс Student является дочерним (подклассом) класса Human.
# Дочерний класс наследует атрибуты и методы родительского класса.
# Если в дочернем классе вызывается метод или атрибут, сначала проверяется его наличие внутри дочернего класса.
# Если метод или атрибут не найден, поиск продолжается в родительском классе.
class Student(_Human):
    head = False  # Атрибут head переопределён в дочернем классе Student.
    # Дочерний класс может добавлять собственные методы и атрибуты, которых нет в родительском классе.

class Teacher(_Human):
    pass  # Заглушка pass означает, что класс Teacher пока не добавляет ничего нового к родительскому классу.

# Принцип DRY (Don’t Repeat Yourself, "не повторяйся"):
# Наследование позволяет избежать дублирования кода, предоставляя общий функционал в родительском классе.
# Например, метод say_hello() определён только в классе Human, но доступен и для Student, и для Teacher.

student = Student()  # Создаём экземпляр класса Student.
teacher = Teacher()  # Создаём экземпляр класса Teacher.
human = _Human()  # Создаём экземпляр класса Human.

# Метод say_hello() вызывается у объектов дочерних классов,
# но фактически он определён в родительском классе Human.
student.say_hello()  # Вывод: Привет
teacher.say_hello()  # Вывод: Привет

# Дочерний класс Student переопределяет атрибут head.
# Значение head для экземпляра класса Student берётся из дочернего класса, а не из родительского.
print(student.head)  # Вывод: False

# Атрибут head для экземпляра класса Human берётся из родительского класса Human.
print(human.head)  # Вывод: True

# Метод about() демонстрирует доступ к атрибутам класса на разных уровнях "защищённости".
human.about()  # Доступ к head, _legs, __arms (через name mangling).
student.about()  # Доступ к head, _legs, __arms (унаследованный метод).

# Метод dir() показывает все доступные атрибуты объекта, включая те, которые создаются через обфускацию (name mangling).
print(dir(human))
print(dir(student))
print('---')

# Доступ к приватному атрибуту __arms осуществляется через обфусцированное имя (_Human__arms).
print(student._Human__arms)  # Вывод: True
print(teacher._Human__arms)  # Вывод: True

# Доступ к приватному атрибуту напрямую вызовет ошибку.
# print(human.__arms)  # Ошибка: AttributeError: '_Human' object has no attribute '__arms'.



class Parent:
    def __init__(self):
        self._protected = "I am protected"
        self.__private = "I am private"

    def show(self):
        print(self._protected)
        print(self.__private)

class Child(Parent):
    def access_attributes(self):
        print(self._protected)  # Доступен
        # print(self.__private)  # Ошибка: 'Child' object has no attribute '__private'

parent = Parent()
print(parent._protected)  # Доступ извне (но не рекомендуется)
# print(parent.__private)  # AttributeError

child = Child()
child.access_attributes()

# Name mangling для приватных атрибутов:
# Name Mangling:
# Python автоматически изменяет имя приватного атрибута, добавляя имя класса перед ним.
# Например, __private в классе Parent станет _Parent__attribute.
print(parent._Parent__private)  # Работает, но использовать крайне нежелательно

# Вывод:
# Используйте _attribute для защищённых переменных, которые могут понадобиться подклассам.
# Используйте __attribute для полного сокрытия данных и предотвращения конфликтов.



# DZ 23 (Сделал Сам, Комментарии писал GPT)
# Класс Animal (Животное)
class Animal:
    alive = True  # Атрибут, указывающий на то, жив ли объект (по умолчанию True)
    fed = False  # Атрибут, указывающий на то, накормлено ли животное (по умолчанию False)

    def __init__(self, name):
        self.name = name  # Инициализация имени животного

    def eat(self, food):
        # food — это объект, переданный в метод eat
        # Когда мы передаем объект p1 (например, цветок), он является экземпляром класса Flower.
        # Класс Flower наследует атрибут edible от родительского класса Plant.
        # Поэтому, когда мы обращаемся к food.edible, Python ищет атрибут в объекте p1 (класс Flower),
        # а если его нет, ищет его в родительском классе Plant (где edible по умолчанию False).

        if food.edible is True:
            print(f'{self.name} съел {food.name}')  # Если еда съедобна, животное ест
            self.fed = True  # Животное становится накормленным
        if food.edible is False:
            print(f'{self.name} не стал есть {food.name}')  # Если еда несъедобна, животное не ест
            self.alive = False  # Животное умирает

# Класс Plant (Растение)
class Plant:
    edible = False  # Растения по умолчанию не съедобны. Этот атрибут будет унаследован всеми классами,

    # которые наследуют от Plant, если они не переопределят его.

    def __init__(self, name):
        self.name = name  # Инициализация имени растения

# Классы-наследники Animal
class Mammal(Animal):  # Млекопитающие (наследуют от Animal)
    pass

class Predator(Animal):  # Хищники (наследуют от Animal)
    pass

# Классы-наследники Plant
class Flower(Plant):  # Цветок (не съедобен)
    pass

class Fruit(Plant):  # Плод (съедобен)
    edible = True  # Плоды переопределяют edible и делают его True (съедобным)

# Создаем объекты
a1 = Predator('Волк с Уолл-Стрит')  # Хищник
a2 = Mammal('Хатико')  # Млекопитающее
p1 = Flower('Цветик семицветик')  # Цветок (несъедобный)
p2 = Fruit('Заводной апельсин')  # Плод (съедобный)

# Выводим имена объектов
print(a1.name)  # Вывод: Волк с Уолл-Стрит
print(p1.name)  # Вывод: Цветик семицветик

# Проверяем начальные состояния животных
print(a1.alive)  # Вывод: True (живое)
print(a2.fed)  # Вывод: False (не накормленное)

# Волк (хищник) пытается съесть цветок (несъедобный)
a1.eat(p1)  # Вывод: Волк с Уолл-Стрит не стал есть Цветик семицветик
# Здесь, так как объект p1 — это экземпляр класса Flower, и класс Flower наследует атрибут edible от Plant,
# то при вызове p1.edible возвращается значение False, и Волк не ест цветок, умирает.

# Хатико (млекопитающее) пытается съесть апельсин (съедобный)
a2.eat(p2)  # Вывод: Хатико съел Заводной апельсин
# Здесь, так как объект p2 — это экземпляр класса Fruit, и класс Fruit переопределяет атрибут edible на True,
# при вызове p2.edible возвращается значение True, и Хатико ест апельсин.

# Проверяем состояние после еды
print(a1.alive)  # Вывод: False, так как Волк умер (не стал есть несъедобное)
print(a2.fed)  # Вывод: True, так как Хатико съел съедобное и стал накормленным

# DZ 24
class Vehicle:
    # Константные (постоянные) значения в Python принято писать полностью в верхнем регистре (капсом).
    # Этот список доступных цветов скрыт, потому что он является приватным.
    __COLOR_VARIANTS = ['blue', 'red', 'green', 'black', 'white']

    def __init__(self, owner, __model, __engine_power, __color):
        # Конструктор (инициализация объекта):
        # self.owner - открытый атрибут, доступен всем.
        self.owner = str(owner)  # Владелец транспортного средства.

        # Приватные атрибуты (доступны только внутри класса или через методы):
        self.__model = str(__model)  # Модель транспортного средства.
        self.__engine_power = int(__engine_power)  # Мощность двигателя.
        self.__color = str(__color)  # Цвет транспортного средства.

        # Здесь `self.__model` используется для сохранения приватного атрибута модели.
        # self ссылается на конкретный экземпляр класса, созданный в момент вызова конструктора.
        # Когда мы используете self внутри метода класса, self всегда ссылается на конкретный экземпляр этого класса, на котором был вызван метод.
        # vehicle1.get_model()  # Здесь self — это vehicle1 == Здесь self — это vehicle1

    # Геттеры: методы, позволяющие безопасно получать значения приватных атрибутов.
    # Они защищают данные от прямого доступа и позволяют добавлять логику при их вызове.
    def get_model(self):
        print(f'Модель: {self.__model}')

    def get_horsepower(self):
        print(f'Мощность двигателя: {self.__engine_power}')

    def get_color(self):
        print(f'Цвет: {self.__color}')

    # Общий метод для вывода всей информации об объекте.
    def print_info(self):
        self.get_model()
        self.get_horsepower()
        self.get_color()
        print(f'Владелец: {self.owner}')

    # Сеттеры: методы, позволяющие безопасно изменять значения приватных атрибутов.
    # Они помогают контролировать, какие данные могут быть назначены, и проверять их корректность.
    def set_color(self, new_color):
        # Метод для изменения цвета транспортного средства.
        # Проверяет, соответствует ли новый цвет списку доступных цветов (__COLOR_VARIANTS).
        for x in self.__COLOR_VARIANTS:
            if new_color.lower() == x.lower():  # Сравнение нового цвета без учёта регистра.
                self.__color = x  # Если цвет найден в списке, он назначается объекту.
                return  # Оператор return завершает выполнение метода, чтобы предотвратить вывод ошибки.
        else:
            # Если цвет не найден в списке, выводится сообщение об ошибке.
            print(f'Нельзя сменить цвет на {new_color}')

class Sedan(Vehicle):
    # Константа с ограничением количества пассажиров в седане.
    __PASSENGERS_LIMIT = 5

# Создаём экземпляр класса Sedan с определёнными атрибутами.
vehicle1 = Sedan('Fedos', 'Toyota Mark II', 500, 'blue')

# Изначальные свойства объекта выводятся через print_info().
vehicle1.print_info()

# Пытаемся сменить цвет на недопустимый, затем на допустимый.
vehicle1.set_color('Pink')  # Этот цвет не доступен в __COLOR_VARIANTS, поэтому будет ошибка.
vehicle1.set_color('BLACK')  # Этот цвет доступен, поэтому изменение произойдёт.

# Изменяем владельца напрямую через открытый атрибут owner.
vehicle1.owner = 'Vasyok'

# Проверяем обновлённые свойства объекта через print_info().
vehicle1.print_info()

#print(Vehicle._Vehicle__model) # Напрямую обратиться нельзя
# print(f'{vehicle1._Vehicle__model}') # Через name mangling:
                                     # Можно вручную обратиться к атрибуту, указав его преобразованное имя:

# В Python приватные атрибуты обозначаются с помощью двойного нижнего подчёркивания (__attribute).
# Это делает их недоступными напрямую за пределами класса. Но внутри самого класса (включая геттеры, сеттеры или другие методы) мы можем к ним обращаться.

# Почему? Потому что геттеры и сеттеры являются частью класса, и внутри методов класса всё ещё используется объект self,
# который "знает" о своих собственных атрибутах, включая приватные.

class Example:
    def __init__(self, value):
        self.__private_value = value  # Приватный атрибут

    def get_value(self):  # Геттер
        return self.__private_value

    def set_value(self, new_value):  # Сеттер
        self.__private_value = new_value

obj = Example(42)
print(obj.get_value())  # Доступ через геттер
obj.set_value(100)      # Изменение через сеттер
print(obj.get_value())

#Здесь геттер и сеттер позволяют безопасно получать и изменять значение приватного атрибута __private_value.

'''НАСЛЕДОВАНИЕ МЕТОД super()'''

# super() используется для автоматического вызова методов родительских классов в порядке MRO (Method Resolution Order).
# Это упрощает работу с множественным наследованием, избегая жесткой привязки к конкретным родительским классам.
# MRO определяет порядок поиска методов в цепочке наследования.
# Когда использовать super():
# - Когда необходимо объединить поведение нескольких родительских классов.
# - Когда нужно обеспечить правильный порядок вызова методов, особенно в случае множественного наследования.
# - Когда хочется избежать дублирования кода, не вызывая методы родительских классов вручную.
# - Когда порядок наследования может изменяться, и нужно гарантировать правильную работу программы.

# В классе Human вызов super() позволяет вызвать методы следующих классов по MRO, обеспечивая правильный порядок и логику.
class Human:
    def __init__(self, name, group):
        self.name = name
        super().__init__(group)  # Вызывает конструктор следующего класса по MRO
        super().about()  # Вызов метода about() из следующего класса в цепочке MRO

    def info(self):
        print(f'Привет, меня зовут {self.name}')


class StudentGroup:
    def __init__(self, group):
        self.group = group

    def about(self):
        print(f'{self.name} учится в группе {self.group}')


# Класс Student использует множественное наследование, и super() помогает правильно вызвать методы из обоих родительских классов.
# Использование super() гарантирует, что конструкторы и методы родительских классов будут вызваны в правильном порядке.
class Student(Human, StudentGroup):
    def __init__(self, name, place, group):
        super().__init__(name, group)  # Вызов конструкторов классов Human и StudentGroup по MRO
        self.place = place
        super().info()  # Вызов метода info() из класса Human

        # В коде:
        # 1. При вызове super().__init__(name, group) Python сначала вызывает конструктор
        #    класса Human, затем переходит к следующему классу (StudentGroup) по MRO.
        # 2. При вызове super().info() Python вызывает метод info() из класса Human,
        #    так как он идет первым в MRO.
        #
        # Использование super() в этом контексте позволяет:
        # - Автоматически управлять порядком вызова методов, избегая жесткой привязки
        #   к классу.
        # - Избегать дублирования кода и поддерживать гибкость при изменении порядка
        #   наследования.
        # - Сохранять устойчивость к изменениям в структуре классов.

student = Student('Алина', 'Урбан', 'Питон 1')

# Вывод MRO можно проверить с помощью метода mro(), который показывает, в каком порядке Python будет искать методы:
print(Student.mro())  # Проверка порядка MRO: [Student, Human, StudentGroup, object]

# Когда используется super(), Python автоматически находит методы по порядку в MRO, делая код более гибким и поддерживаемым.
# MRO гарантирует правильный порядок вызовов методов и предотвращает проблемы при изменении порядка наследования.



#####
# Пример, когда стоит использовать super():
# Предположим, у вас есть два родительских класса,
# которые выполняют схожие действия, но вы хотите объединить их поведение в дочернем классе:

class Parent1:
    def greet(self):
        print("Hello from Parent1")

class Parent2:
    def greet(self):
        print("Hello from Parent2")

class Child(Parent1, Parent2):
    def greet(self):
        # Вызов greet() из обоих родителей через super()
        super().greet()

child = Child()
child.greet()
# Здесь super() используется для вызова метода greet() в соответствии с MRO, а не напрямую указывая Parent1.greet() или Parent2.greet().
# Если изменится порядок наследования, super() автоматически будет вызывать метод из следующего класса в MRO, что гарантирует правильное поведение.

# Когда не обязательно использовать super():
# Если в вашем классе нет множественного наследования, то использование super() не дает особых преимуществ.
# В этом случае можно прямо вызывать методы родительского класса.

# Когда вам нужно жестко контролировать, какой родительский класс будет вызван.
# В таких случаях вы можете явно указать класс, например, Parent1.method(self).
# В общем случае, для множественного наследования и при необходимости гарантировать правильный порядок вызова методов, использование super() — это лучший подход.

# Однако, важность такого класса заключается в том, что он управляет тем, как методы из родительских классов вызываются и комбинируются,
# особенно через использование super() и MRO (Method Resolution Order).

# Определяем класс A с методом method()
class A:
    def method(self):
        print("Метод из A")  # Этот метод будет найден в классе A

# Определяем класс B с методом method()
class B:
    def method(self):
        print("Метод из B")  # Этот метод будет найден в классе B
        # Нет вызова super(), поэтому поиск не продолжится в A

# Определяем класс C, который наследует B и A
class C(B, A):  # Порядок наследования: сначала B, затем A
    def method(self):
        print("Метод из C")  # Этот метод будет найден в классе C
        super().method()  # Вызов super() продолжит поиск метода в следующем классе по MRO

c = C()
c.method()  # Этот вызов будет искать метод по цепочке MRO (C -> B)

# Ожидаемый вывод:
# Метод из C
# Метод из B

# Важные моменты:
# 1. Класс C вызывает метод method() из своего родителя по порядку MRO (сначала из B, затем из A).
# 2. В классе B нет вызова super(), поэтому поиск метода не продолжится в A.
# 3. Метод из A не будет вызван, так как в B не было вызова super() для продолжения поиска.

# MRO и super() помогают избежать проблем, связанных с изменением порядка наследования,
# гарантируя правильный порядок вызова методов.
# Класс с множественным наследованием управляет логикой вызова методов из разных классов,
# но не является «главным» в контексте всей программы.



# Определяем класс A с методом method()
class A:
    def method(self):
        print("Метод из A")  # Этот метод будет найден в классе A

# Определяем класс B с методом method()
class B:
    def method(self):
        print("Метод из B")  # Этот метод будет найден в классе B
        super().method()  # Вызов super() продолжит поиск метода в следующем классе по MRO

# Определяем класс C, который наследует B и A
class C(B, A):  # Порядок наследования: сначала B, затем A
    def method(self):
        print("Метод из C")  # Этот метод будет найден в классе C
        super().method()  # Вызов super() продолжит поиск метода в следующем классе по MRO

c = C()
c.method()  # Этот вызов будет искать метод по цепочке MRO (C -> B -> A)

# Вывод MRO для класса C
print(C.mro())  # Выведет: [<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>]

# Важные моменты:
# 1. В классе C вызывается super().method(), что приводит к вызову метода из B (следующий класс в MRO).
# 2. В классе B есть вызов super().method(), который продолжает поиск метода в классе A.
# 3. В MRO порядок наследования C -> B -> A гарантирует, что метод из A будет вызван, если super() используется в B.

# MRO и super() помогают избежать проблем, связанных с изменением порядка наследования,
# гарантируя правильный порядок вызова методов.
# Класс с множественным наследованием управляет логикой вызова методов из разных классов,
# но не является «главным» в контексте всей программы.

# DZ 25
from random import randint  # Импортируем функцию randint для генерации случайных чисел.

# Базовый класс для всех животных
class Animal:
    live = True  # Класс-атрибут: указывает, что животные живые.
    sound = None  # Атрибут звука, который переопределяется в дочерних классах.
    _DEGREE_OF_DANGER = 0  # Приватный атрибут: степень опасности животного.

    def __init__(self, speed, _cords=[0, 0, 0]):
        # Инициализация объекта: задаём скорость и начальные координаты.
        self._cords = [0, 0, 0]  # Приватные координаты животного: X, Y, Z.
        self.speed = speed  # Скорость передвижения животного.

    def move(self, dx, dy, dz):
        # Метод для передвижения животного.
        self._cords[0] = dx * self.speed  # Перемещение по оси X с учётом скорости.
        self._cords[1] = dy * self.speed  # Перемещение по оси Y с учётом скорости.
        if dz < 0:
            # Если животное пытается уйти под землю, выводим сообщение и прекращаем выполнение.
            print('Слишком глубоко, я не могу нырнуть')
            return
        else:
            self._cords[2] = dz * self.speed  # Перемещение по оси Z (вверх).

    def get_cords(self):
        # Метод для получения текущих координат животного.
        print(f'X:{self._cords[0]}, Y:{self._cords[1]}, Z:{self._cords[2]}')

    def attack(self):
        # Метод для атаки: проверяем степень опасности животного.
        if self._DEGREE_OF_DANGER >= 5:
            print(f'Острожно, я тебя атакую 0_0')  # Если степень опасности высокая, животное атакует.
        else:
            print(f'Извините, я мирный')  # Если степень опасности низкая, животное мирное.

    def speak(self):
        # Метод для воспроизведения звука животного.
        print(f'{self.sound}')


# Класс птиц, наследуется от Animal.
class Bird(Animal):
    beak = True  # Класс-атрибут: у птиц есть клюв.

    def lay_eggs(self):
        # Метод для откладывания яиц.
        ran1_4 = randint(1, 4)  # Генерируем случайное число от 1 до 4.
        print(f'Вот (есть) {ran1_4} яйца для тебя')  # Сообщаем, сколько яиц снесено.


# Класс водных животных, наследуется от Animal.
class AquaticAnimal(Animal):
    _DEGREE_OF_DANGER = 3  # Водные животные имеют среднюю степень опасности.

    def dive_in(self, dz):
        # Метод для погружения в воду.
        dz = abs(dz)  # Берём модуль значения глубины, чтобы избежать отрицательных чисел.
        self._cords[2] -= dz  # Уменьшаем координату Z (погружаемся вниз).
        if self._cords[2] < 0:
            # Если координата Z становится меньше 0, устанавливаем её на 0.
            self._cords[2] = 0
        self.speed /= 2  # Скорость животного уменьшается вдвое при погружении.


# Класс ядовитых животных, наследуется от Animal.
class PoisonousAnimal(Animal):
    _DEGREE_OF_DANGER = 8  # Ядовитые животные имеют высокую степень опасности.


# Утконос, класс множественного наследования от Bird, PoisonousAnimal и AquaticAnimal.
class Duckbill(Bird, PoisonousAnimal, AquaticAnimal):
    sound = "Click-click-click"  # Звук, издаваемый утконосом.

    def __init__(self, speed):
        # Конструктор утконоса: передаём скорость в конструктор родительских классов.
        super().__init__(speed)

    def dive_in(self, dz):
        # Переопределение метода погружения.
        super().dive_in(dz)

    def lay_eggs(self):
        # Переопределение метода откладывания яиц.
        super().lay_eggs()

    def attack(self):
        # Переопределение метода атаки.
        super().attack()

    def speak(self):
        # Переопределение метода воспроизведения звука.
        super().speak()

    def move(self, dx, dy, dz):
        # Переопределение метода перемещения.
        super().move(dx, dy, dz)

    def get_cords(self):
        # Переопределение метода получения координат.
        super().get_cords()


# Создаём экземпляр класса Duckbill с заданной скоростью.
db = Duckbill(10)
print(db.live)  # Проверяем, жив ли объект (класс-атрибут из Animal).
print(db.beak)  # Проверяем, есть ли у утконоса клюв (класс-атрибут из Bird).
db.speak()  # Утконос издаёт свой звук (переопределённый метод).
db.attack()  # Проверяем, атакует ли утконос (метод учитывает степень опасности).
db.move(1, 2, 3)  # Перемещаем утконоса по координатам X, Y, Z.
db.get_cords()  # Получаем текущие координаты утконоса.
db.dive_in(60)  # Утконос ныряет на 60 единиц глубины.
db.get_cords()  # Проверяем координаты после погружения.
db.lay_eggs()  # Утконос откладывает яйца.
print(Duckbill.mro())



# Когда дочерний класс наследует атрибуты и методы родительского класса через super(), он получает доступ ко всем этим атрибутам и методам.
# В приведённом примере атрибут self.items, инициализированный в родительском классе Parent, становится доступным в дочернем классе Child.

class Parent:
    def __init__(self, items):
        self.items = items  # Присваиваем переданный список атрибуту self.items

class Child(Parent):
    def __init__(self, items):
        super().__init__(items)  # Вызываем конструктор Parent
        self.items.append("Added in Child")  # Изменяем список, добавляя элемент

# Создаём список и передаём его в дочерний класс
items_list = ["Item1", "Item2"]
child_instance = Child(items_list)

print(child_instance.items)  # ['Item1', 'Item2', 'Added in Child']
print(items_list)            # ['Item1', 'Item2', 'Added in Child']

# DZ 26
import math  # Импортируем модуль math для выполнения математических операций, таких как вычисление корня.

# Базовый класс для геометрических фигур
class Figure:
    sides_count = 0  # Класс-атрибут: задаёт количество сторон фигуры (по умолчанию 0).

    def __init__(self, __color, __sides):
        # Конструктор класса принимает цвет фигуры и её стороны.
        # Цвет (RGB) сохраняется как список, стороны — как список длины сторон.
        self.__sides = list(__sides)  # Приватный атрибут: список длин сторон.
        self.__color = [*__color]  # Приватный атрибут: цвет фигуры (RGB).
        self.filled = True  # Атрибут заполненности фигуры (по умолчанию True).

    def check(self):
        # Метод проверяет количество сторон фигуры.
        # Если количество сторон соответствует sides_count, возвращает их.
        # Если количество сторон меньше, создаёт список сторон длиной sides_count со значением 1.
        l = 0
        if len(self.__sides) == self.sides_count:  # Проверка количества сторон.
            for i in self.__sides:  # Перебираем стороны.
                self.__sides = []  # Обнуляем список сторон.
                self.__sides.append(i)  # Добавляем текущую сторону.
                return self.__sides
        else:
            # Если количество сторон меньше, создаём новый список сторон с длиной sides_count.
            self.__sides = []
            while l < self.sides_count:  # Заполняем список сторонами длиной 1.
                self.__sides.append(1)
                l += 1
            return self.__sides

    def get_color(self):
        # Метод возвращает текущий цвет фигуры (RGB).
        return self.__color

    def __is_valid_color(self, r, g, b):
        # Приватный метод проверяет корректность переданного цвета (RGB).
        # Цвет должен быть в диапазоне 0-255 для каждого из значений r, g, b.
        if isinstance(r, int) and isinstance(g, int) and isinstance(b, int):
            if 0 <= r <= 255 and 0 <= g <= 255 and 0 <= b <= 255:
                # Если цвет корректен, обновляем атрибут __color.
                self.__color = [r, g, b]
                return self.__color
        return self.__color  # Если цвет некорректен, возвращаем текущий.

    def set_color(self, r, g, b):
        # Публичный метод для изменения цвета фигуры.
        # Делегирует проверку валидности метода __is_valid_color.
        self.__is_valid_color(r, g, b)

    def __is_valid_sides(self, *args):
        # Приватный метод для проверки длин сторон.
        # Возвращает True, если все стороны больше 0 и их количество соответствует текущему.
        for i in args:
            if i > 0 and len(args) == len(self.__sides):
                return True
        return False

    def get_sides(self):
        # Метод возвращает текущие стороны фигуры.
        return self.__sides

    def __len__(self):
        # Специальный метод, возвращающий периметр фигуры (сумму всех сторон).
        j = 0
        for i in self.__sides:  # Перебираем стороны и суммируем их длины.
            j += i
        return j

    def set_sides(self, *new_sides):
        # Метод устанавливает новые стороны фигуры.
        # Проверяет, чтобы количество сторон соответствовало sides_count.
        if len(new_sides) == self.sides_count:
            self.__sides = list(new_sides)
            return self.__sides
        return self.__sides


# Класс для круга, наследуется от Figure
class Circle(Figure):
    sides_count = 1  # У круга считается только одна сторона (диаметр).

    def __init__(self, __color, *__sides):
        # Конструктор класса. Передаём цвет и диаметр в родительский класс.
        super().__init__(__color, __sides)  # Вызываем конструктор Figure.
        super().check()  # Проверяем корректность количества сторон.
        storona = __sides[0]  # Извлекаем первую сторону (диаметр круга).
        self.__radius = int(storona) * 3.14 / 1  # Вычисляем радиус.

    def get_square(self):
        # Метод возвращает площадь круга (π * r²).
        sq = 3.14 * self.__radius ** 2
        return sq


# Класс для треугольника, наследуется от Figure
class Triangle(Figure):
    sides_count = 3  # У треугольника всегда три стороны.

    def __init__(self, __color, *__sides):
        # Конструктор класса. Передаём цвет и длины сторон в родительский класс.
        super().__init__(__color, __sides)
        super().check()  # Проверяем корректность количества сторон.

    def get_square(self):
        # Метод возвращает площадь треугольника по формуле Герона.
        p = (self.__sides[0] + self.__sides[1] + self.__sides[2]) / 2  # Полупериметр.
        s = math.sqrt(p * (p - self.__sides[0]) * (p - self.__sides[1]) * (p - self.__sides[2]))  # Площадь.
        return s


# Класс для куба, наследуется от Figure
class Cube(Figure):
    sides_count = 12  # У куба 12 рёбер.

    def __init__(self, __color, *__sides):
        # Конструктор класса. Принимает цвет и длину стороны куба.
        x = len(__sides)  # Определяем количество переданных сторон.
        if x == 1:
            # Если передана одна сторона, создаём список из 12 одинаковых сторон.
            self.__sides = list(__sides)
            for i in self.__sides:
                self.__sides = []
                l = 0
                while l < self.sides_count:
                    self.__sides.append(i)
                    l += 1
                super().__init__(__color, self.__sides)
        else:
            # Если передано больше сторон, используем их напрямую.
            super().__init__(__color, __sides)
            super().check()

    def get_volume(self):
        # Метод возвращает объём куба (ребро³).
        return self.__sides[0] ** 3


# Примеры использования:
# Создаём круг с цветом (200, 200, 100) и диаметром 10.
circle1 = Circle((200, 200, 100), 10)
# Создаём куб с цветом (222, 35, 130) и длиной ребра 6.
cube1 = Cube((222, 35, 130), 6)
# Изменяем цвет круга.
circle1.set_color(55, 66, 77)
print(circle1.get_color())  # Новый цвет круга.
# Пытаемся установить некорректный цвет куба.
cube1.set_color(300, 70, 15)
print(cube1.get_color())  # Цвет куба не изменился.
# Пытаемся установить некорректные стороны для куба.
cube1.set_sides(5, 3, 12, 4, 5)
print(cube1.get_sides())  # Стороны куба не изменились.
# Устанавливаем новую сторону круга.
circle1.set_sides(15)
print(circle1.get_sides())
# Выводим периметр круга.
print(len(circle1))
# Выводим объём куба.
print(cube1.get_volume())
# Выводим площадь круга.
print(circle1.get_square())
print('------------------------------------')
circle2 = Circle((200, 200, 100), 15, 10)
print(circle2.get_sides())
triangle = Triangle((200, 200, 100), 10, 6)
print(triangle.get_sides())
cube2 = Cube((200, 200, 100), 9)
print(cube2.get_sides())
print(cube2.get_volume())
cube3 = Cube((200, 200, 100), 12)
print(cube3.get_sides())
print(cube3.get_volume())
print(cube3.__len__())

'''Строки байты и кодировка'''
# === Работа с таблицей ASCII ===
# ASCII (American Standard Code for Information Interchange) содержит символы с числовыми кодами от 0 до 127.

# Пример: используя функцию `ord`, мы можем получить числовой код символа.
print(ord('h'))  # Вывод: 104 (числовое представление символа 'h' в таблице ASCII)

# Преобразование строки в список числовых кодов ASCII.
a = 'hello'
chars = []
for i in a:
    chars.append(ord(i))
print(chars)  # Вывод: [104, 101, 108, 108, 111]

# Синтаксис функции `ord`:
# ord(char: str) -> int
# Возвращает числовой код символа в Unicode (или ASCII, если символ в пределах ASCII).
# Параметр:
# - `char` (str): одиночный символ.
# Возвращает:
# - (int): числовой код символа.

# === Работа с функцией chr ===
# Чтобы преобразовать числовой код обратно в символ, используем функцию `chr`.
print(chr(104))  # Вывод: 'h'

# Восстановление строки из списка числовых кодов.
s = ''
for i in chars:
    s += chr(i)
print(s)  # Вывод: 'hello'

# Синтаксис функции `chr`:
# chr(code: int) -> str
# Возвращает символ, соответствующий числовому коду.
# Параметр:
# - `code` (int): числовой код символа (в пределах Unicode).
# Возвращает:
# - (str): символ.

# === Вывод всех символов таблицы ASCII ===
for i in range(128):
    print(chr(i), end=' ')  # Вывод всех символов таблицы ASCII от 0 до 127.

# === Работа с таблицей Unicode ===
# Unicode — это универсальный стандарт кодирования символов, включающий более 2 миллионов символов.
# Охватывает символы множества языков, а также специальные и технические символы.

# Пример вывода первых 1500 символов Unicode.
for i in range(1, 1500):
    print(chr(i), end=' ')  # Вывод символов с кодами от 1 до 1499.

# === Работа с байтами ===
# Байты (тип данных `bytes`) — это представление строк или символов в двоичном (или шестнадцатеричном) формате.
bb = b''  # Создание пустого объекта типа `bytes`.

# Пример работы с символом «h».
# Используем функцию `ord` для получения числового кода символа.
# Затем преобразуем его в шестнадцатеричный формат с помощью функции `hex`.
print(hex(ord('h')))  # Вывод: '0x68' (шестнадцатеричное представление кода символа 'h')

# Создание байтовой строки.
bb = b'\x68'  # Префикс `\x` обозначает шестнадцатеричный формат. Код '0x68' символа 'h' записан как '\x68'.
print(type(bb))  # Вывод: <class 'bytes'> (тип данных — байты)
print(bb)        # Вывод: b'h' (байтовое представление символа 'h')

# Если вы хотите выполнить декодирование (преобразование из bytes обратно в строку),
# нужно явно вызвать метод `.decode()`:
decoded = bb.decode()
print(decoded)  # Вывод: 'h' (декодированный символ)

# Декодирование байтов полезно, когда вам нужно работать с текстовым представлением данных,
# изначально сохранённых в формате байтов.

# === Дополнительная информация о методах encode и decode ===
# Метод `encode`:
#   Синтаксис: `str.encode(encoding="utf-8", errors="strict")`
#   Описание: Преобразует строку в байты с использованием указанной кодировки (по умолчанию UTF-8).
#   Аргументы:
#     - `encoding` (str, необязательный):
#         Кодировка, используемая для преобразования строки в байты.
#         По умолчанию используется 'utf-8'.
#         Примеры кодировок: 'ascii', 'utf-16', 'latin-1', и другие.
#     - `errors` (str, необязательный):
#         Способ обработки ошибок при преобразовании:
#         - 'strict' (по умолчанию): выбрасывает исключение при ошибке.
#         - 'ignore': игнорирует символы, которые нельзя закодировать.
#         - 'replace': заменяет некорректные символы на '?' или другой маркер.
#   Возвращает: Объект типа `bytes`.

# Метод `decode`:
#   Синтаксис: `bytes.decode(encoding="utf-8", errors="strict")`
#   Описание: Преобразует объект `bytes` в строку с использованием указанной кодировки (по умолчанию UTF-8).
#   Аргументы:
#     - `encoding` (str, необязательный):
#         Кодировка, используемая для декодирования байтов.
#         По умолчанию используется 'utf-8'.
#         Примеры кодировок: 'ascii', 'utf-16', 'latin-1', и другие.
#     - `errors` (str, необязательный):
#         Способ обработки ошибок при преобразовании:
#         - 'strict' (по умолчанию): выбрасывает исключение при ошибке.
#         - 'ignore': игнорирует символы, которые нельзя декодировать.
#         - 'replace': заменяет некорректные символы на '?' или другой маркер.
#   Возвращает: Объект типа `str`.

# Пример кодирования и декодирования строки:
utf8_string = 'Привет, мир!'  # Строка на русском языке.
utf8_bytes = utf8_string.encode('utf-8')  # Кодируем строку в байты.
print(utf8_bytes)  # Вывод: b'\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82, \xd0\xbc\xd0\xb8\xd1\x80!'

# Декодирование обратно в строку.
decoded_string = utf8_bytes.decode('utf-8')
print(decoded_string)  # Вывод: 'Привет, мир!'

# === Кодировка UTF-8 ===
# UTF-8 (8-битная форма преобразования Unicode) совместима с ASCII:
# - Символы ASCII занимают 1 байт.
# - Символы, выходящие за пределы ASCII, занимают 2–4 байта.
# UTF-8 широко используется благодаря поддержке всех символов Unicode и экономии памяти.
