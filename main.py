import this # импорт Дзен питона
print("Hello World") # =str-string строка

print(type(5)) # тип числа =int-integer - целое число
print(type(2.1)) # тип числа =float число с плавающей запятой
print(type("Stro4ka")) # тип данных =str-string строка

# concatenate - связывает, сцепляет, соединяет оператор +, но одинаковые объекты
# запятая в командах "," говорит о том, что элемент закончился и сейчас будет другой

print(78 % 33) # сколько в число 78 помещается число 33 получим остаток от этого/остаток от деления
print(78 / 33) # деление с плавающей запятой =float
print(78 // 33) # деление с ответом без запятой =int-integer
print(7 % 7) # сколько в число 7 поместится число 7, если поместилось, то это 0

print(5 ** 3) # степень

#boolean - тип данных "примитивно" да-нет, истина-ложь # если функция возвращает true/false, то это можно использовать в ветвлениях или функция(не точно)
print(type(True),type(False))
print(5 == 5, 5 > 2, 3 < 1, 5 != 5, 5 != 4) # == - они равны?, != - они не равны?

'''команда and= и, or= или'''

# and= и - если все условия с двух сторон равны, то все выражения считаются истинными
# and= и - чтобы получить «True», должны быть истинны оба выражения
'СТРОГИЙ ОПЕРАТОР'
print(5 == 5 and 5 != 5)
print(10 == 10 and 6 > 3)

# or= или - выражение ложно, если оно с двух сторон ложно, если одно из них истинное, то все выражения истинно
# or= или, чтобы получить «True» достаточно, чтобы истинным было хотя бы одно.
'НЕ СТРОГИЙ ОПЕРАТОР'
print(5 == 5 or 5 != 5)
print(5 > 6 or 6 > 7 )

# Перевод данных в другой тип. Текстовую пятерку перевел в число и также наоборот в строку. Код расшифровывается справа налево.
print(type(int("5")))
print(type(str(5)))

## DZ 1
# 1st program
print(9 ** 0.5 * 5)
# 2nd program
print(9.99 > 99.98 or 1000 != 1000.1)
# 3rd program
print(2 * 2 + 2 == 2 * (2 + 2))
# 4th program
print(int(float ('123.456')* 10 % 10))

# Функция abs в Python возвращает абсолютное значение числа. Таким образом результат всегда положительный.
# На вход функция принимает: целые числа; числа с плавающей точкой; комплексные числа.
# Пример работы функции:
# abs(-20) # => 20
# abs(-20.5) # => 20.5
# abs(3 + 4j) # => 5.0


# Динамическая типизация - это смена типа данных в переменной
# Оператор = присваивает переменной (прим. Name) тип данных, то есть переменная name ссылается на значение Urban
# Получается, что правый объект присваивает себе некую переменную(левое значение), которую в дальнейшем можно использовать
name1 = 'Urban'
print(name1, type(name1))
name1 = 5
print(name1, type(name1))
name1 = 2.2
print(name1, type(name1))

name01 = 5
name01 = 6
print(name01 + name01) # Запомнит он последний объект привязанный к одной переменной

## DZ 2
name = 'Ilya'
print(name, type(name))
age = 24
print(age,type(age))
age = age + 24
print(age,type(age))
is_student = True
print(is_student, type(is_student))

# Переменная - хранит в себе информацию к которой мы можем обращаться в дальнейшей работе
# Важно, чтобы переменная носила осмысленное название и была эксклюзивной (не была названа другой командой)
# Snake case - название переменной пишется через нижнее подчеркивание (для читаемости и быстрого понимания) - data_of_brith
# Camel case - название переменной пишется с заглавной буквы (каждое слово) - dataOfBrith
## Мне больше понравился стиль snake case, в дальнейшем иногда можно путать ноль и букву О

a, b, c = 1, 2, 3 # Множественное присваивание - присвоить сразу несколько значений в одной строке
print(c + b * a)

a =  b = c = 67 # Каскадное присваивание - то есть a = b = c, а все перечисленные переменные содержат объект int-integer 67
print(a + b + c)

d = list ('Begin') # Преобразование строки в список по символам - (пока не знаю для чего)
print(d)

list1 = [5, 3, 1] # Множественное присваивание со списками (Пока не очень понимаю для чего это)
a, b, c = list1

# DZ 3
completed_dz = 12 # Выполнено заданий
hours_spent = 1.5 # Время на одно задание
name_cource = 'Python' # Название курса
time_one_job = int (completed_dz / hours_spent) # Время на выполнение одного задания

print("Курс:", name_cource,",","Затраченное время на одно задание:", hours_spent,",","Среднее время на выполнения одного задания:", time_one_job, "ч.")

name = "IlyaNefedov"
print('Hello, ' * 2 + name) # Дублирование строки через оператор *

# Индексация строки у каждой строки есть свой порядковый индекс начинается он с нуля
# Так же можно выводить и последнюю букву начиная с -1 (последняя буква), -2 (предпоследняя буква) и так далее.
print(name [0]) # нулевой индекс принимается как первая буква и так далее
print(name [-1]) # индекс со знаком минус выводит буквы с конца
print(name [0:5]) # срез строки последний элемент не выводится, то есть получается 0 - 4 (в данном случае)
print(name [0:8:2]) # 0 начало, 8 конец, 2 шаг # выведет нам с 0 индекса по 8 (не включительно) с шагом 2
# Так же мы можем пропускать начальное и последние значение
print(name [:11]) # мы пропустили первое значение, но указали конечное, он сам понял, что не указанное это начало
print(name [:5]) # мы пропустили первое значение, но указали конечное, он сам понял, что не указанное это начало
print(name [0:]) # мы указали первое, но не указали конечное, поэтому для него конечное это конец строки
print(name [4:]) # мы указали первое, но не указали конечное, поэтому для него конечное это конец строки
print(name [::-1]) # срез с конца строки с шагом 1, мы не указали начальное и конечно, поэтому эти значения равны началу и концу строки
print(name [::1]) # срез с начала строки с шагом 1, мы не указали начальное и конечно, поэтому эти значения равны началу и концу строки
print(name [-1:-10:-2]) # срез с конца строки, но в начале, до 10 индекса с шагом два, обратный порядок

cc = "HelloWorld"
# Индексация строки:
#  H  e  l  l  o  W  o  r  l  d
#  0  1  2  3  4  5  6  7  8  9  (прямые индексы)
# -10 -9 -8 -7 -6 -5 -4 -3 -2 -1 (отрицательные индексы)

print(cc[-4:])  # Результат: "orld"

# DZ 4
example = 'AnString'
print(example [0]) # Первый символ в строке
print(example [-1]) # Последний символ в строке с использованием обратного индекса
print(example [3:]) # Вторая половина строки с нечетным кол-во букв
print(example [::-1]) # Слово наоборот
print(example [::2]) # Каждый второй индекс в строке с использованием шага

##name = input('Введите свое имя: ') # команда input говорит о том, что пользователю нужно ввести данные с клавиатуры
##current_data = 2024 # год на данный момент
##data_of_brith = int (input ('Ваш год рождения: ')) #год рождения юзера, команда int, которая преобразует ВВОД в число
### тк как изначально ВВОДИМЫЕ ДАННЫЕ имеют класс str-string строка
##age = current_data - data_of_brith # год на данный момент минус год рождения юзера
##print ('Добро пожаловать,',name) # выводи приветствия и имя юзера
##print ('В этом году вам исполнилось',age, 'года/лет' ) # выводит строку сколько лет исполнилось юзеру и переменную age
#^^^^ обычная программа, которая считает возраст юзера (без месяца и дня)


print('я строка в нижнем регистре'.replace('строка','человек'))
#заменили слово строка на человек
print('я строка в нижнем регистре'.replace('строка','Человек').replace('я','В').replace(' ','-'))
#замена нескольких слов в строке
print('я строка в нижнем регистре'.replace(' ','.')) #заменили символ ПРОБЕЛ ( ) на символ ТОЧКУ
# Метод .upper() - переводит текст в Верхний регистр
# Метод .lower() - переводит текст в Нижний регистр
# Метод .replace('что заменить','на что заменить') - заменяет выбранное слово на другое
# Метод .isdigit() возвращает True, если все символы в строке являются цифрами. Если нет, возвращается False.
# isdigit = is(является)digit(цифрой) - является цифрой

# Метод .title() делает каждую первую букву слова заглавной, при этом все остальные буквы переводятся в нижний регистр

# Метод .istitle() Вернёт True , если в строке хотя бы один символ или все слова в строке начинаются с заглавных букв, иначе — False .

# isupper() — метод строки, который проверяет, является ли все символы строки заглавными буквами.
# Он возвращает True, если все символы в строке (кроме символов, которые не являются буквами)
# находятся в верхнем регистре. Если хотя бы один символ в строке не является заглавным,
# метод вернет False.

# # Проверяем, что пароль содержит хотя бы одну заглавную букву и хотя бы одну цифру.
#         # any(i.isupper() for i in password) — проверяет, есть ли хотя бы одна заглавная буква в строке:
#         #     - i.isupper() возвращает True для каждого символа, который является заглавной буквой.
#         #     - any() возвращает True, если хотя бы один символ строки является заглавной буквой.
#         # any(i.isdigit() for i in password) — проверяет, есть ли хотя бы одна цифра в строке:
#         #     - i.isdigit() возвращает True для каждого символа, который является цифрой.
#         #     - any() возвращает True, если хотя бы один символ строки является цифрой.
#         # Если оба условия выполняются, продолжаем проверку и сравниваем пароль с подтверждением.
#         if any(i.isupper() for i in password) and any(i.isdigit() for i in password):

# === Метод .split() ===
# Метод `.split()` разбивает строку на подстроки, используя заданный разделитель, и возвращает список этих подстрок.

# === Синтаксис ===
# str.split(sep=None, maxsplit=-1)

# === Аргументы ===
# 1. sep (str, необязательный):
#    - Разделитель, по которому будет происходить разбиение строки.
#    - Если не указан или указан как None, строка разбивается по пробельным символам
#      (пробел, перевод строки, табуляция и другие).
#    - Если строка начинается или заканчивается разделителем, пустые строки в начале или конце списка
#      не добавляются.
#    - Если строка состоит только из разделителей, результатом будет пустой список.
#
# 2. maxsplit (int, необязательный):
#    - Определяет максимальное количество разбиений.
#    - Если указано -1 (по умолчанию), строка разбивается на все возможные подстроки.
#    - Если maxsplit > 0, разбиение останавливается после указанного количества разбиений,
#      и оставшаяся часть строки добавляется в конец списка как единственная подстрока.

# === Возвращаемое значение ===
# - list: Список подстрок, полученных в результате разбиения строки.

# === Примеры использования ===

# Пример 1. Разбиение по пробелу (по умолчанию)
text = "Hello World! Welcome to Python."
result = text.split()
print(result)
# Вывод: ['Hello', 'World!', 'Welcome', 'to', 'Python.']

# Пример 2. Разбиение по определённому разделителю
text = "apple,orange,banana,grape"
result = text.split(",")
print(result)
# Вывод: ['apple', 'orange', 'banana', 'grape']

# Пример 3. Ограничение количества разбиений (maxsplit)
text = "apple orange banana grape"
result = text.split(" ", 2)
print(result)
# Вывод: ['apple', 'orange', 'banana grape']

# Пример 4. Разбиение по отсутствующему разделителю
text = "apple,orange,banana,grape"
result = text.split(";")
print(result)
# Вывод: ['apple,orange,banana,grape']

# Пример 5. Разбиение строки с пустой строкой
text = "   "
result = text.split()
print(result)
# Вывод: []

# Пример 6. Разбиение строки с концами разделителей
text = " apple,orange,banana,grape, "
result = text.split(",")
print(result)
# Вывод: [' apple', 'orange', 'banana', 'grape', ' ']

# Пример 7. Сохранение каждого слова в отдельную переменную
text = "apple orange banana"
# Метод split разделяет строку на три слова
word1, word2, word3 = text.split()
print(word1)  # Вывод: apple
print(word2)  # Вывод: orange
print(word3)  # Вывод: banana

# Пример 8. Использование maxsplit для контроля разбиений:
text = "apple orange banana grape"
word1, word2, remaining = text.split(" ", 2)
print(word1)      # Вывод: apple
print(word2)      # Вывод: orange
print(remaining)  # Вывод: banana grape

# === Особенности ===
# - Если sep=None, метод игнорирует ведущие и конечные пробелы.
# - Для сложного разбиения можно использовать регулярные выражения (метод re.split()).

#DZ 5
##my_string = input ('Введите произвольный текст:') # ввод текста в формате данных str
##print('Кол-во символов в строке:',len(my_string)) # функция len подсчитывает кол-во элементов
##print(my_string .upper()) # изменяем текст на верхний регистр
##print(my_string .lower()) # изменяем текст на нижний регистр
##print(my_string .replace(' ', '')) # удалям ПРОБЕЛЫ на ничего
##print(my_string [0:1]) # вывод первого символа в строка
##print(my_string [-1]) # вывод последнего символа в строке
#Здесь должен быть текст посвященный университету урбан

# СПИСКИ
# list_
food = ['apple', 'coco', 'banana', 'cherry', 2] # в квадратных скобках хранятся элементы списка
# то есть у каждого элемента есть порядковый номер он же - индекс
print(food[3]) # нумерация начинается с нуля, как и любой индекс
food [0] = 'beef'# замена нулевого индекса(то есть первого слова) на другое слово
food [2] = 2024 # замена второго индекса(то есть третьего слова) на другой элемент
# списки изменяемые, то есть их можно менять
print(food)
# функция len подсчитывает кол-во элементов, если элементы будут в списке она посчитает сколько элементов в списке

food.append(True)  # Добавляем элемент True в конец списка.
# Метод append(присоединить/добавить) добавляет только один элемент в конец списка.
# Если нужно сохранить список или кортеж как отдельный объект, используйте append.
# Синтаксис: list.append(элемент).
# .append - присоединить/добавить

food.append('pear')  # Добавляем строку 'pear' в конец списка.
# Элемент может быть любым типом данных (число, строка, булевое значение и т.д.).

food.extend('True')  # Добавляем строку 'True'. Каждый символ добавляется как отдельный элемент.
# Результат: food = [..., 'T', 'r', 'u', 'e'].

food.extend(['True', 2, 'Foll'])  # Добавляем элементы списка ['True', 2, 'Foll'] в конец.
# Результат: food = [..., 'T', 'r', 'u', 'e', 'True', 2, 'Foll'].
# Синтаксис: list.extend(iterable)
# Когда мы добавляем элементы с помощью метода extend, он не создает вложенный список или кортеж.
# Вместо этого он добавляет элементы из переданного итерируемого объекта (например, списка или кортежа) по одному.
# - Если iterable — строка: каждый символ строки добавляется как отдельный элемент.
# - Если iterable — список или кортеж: все элементы добавляются по одному.
# - Если iterable — множество: элементы добавляются в произвольном порядке.
# - Если iterable — словарь: добавляются только ключи.
# .extend - продлить/расширить

# Отличие append от extend:
# - append добавляет объект целиком как один элемент: my_list.append([4, 5]) -> [..., [4, 5]].
# - extend распаковывает объект и добавляет его элементы по одному: my_list.extend([4, 5]) -> [..., 4, 5].
# Если нужно добавить строку или список как один элемент, используйте append.

food.remove('cherry')  # Удаляем первый найденный элемент 'cherry' из списка.
# Метод remove удаляет первый элемент с указанным значением.
# Если элемента нет, возникает ошибка ValueError.

print("beef" in food) # командой in(в) можно проверять если элемент в списке
print('beeed' in food)
# данную команду можно расшифровывать как - если ли "слово (in) в списке?"
print('coco' not in food) # командой not in(не в) можно проверить отсутствие элемента в списке
print('peaar' not in food)
# данную команду можно расшифровывать как - "слово не в списке"?
print(food [-1::-1]) # так же мы можем проводить индексация со списком
print(food)

#Как копировать список:
# С помощью метода copy:
# new_list = original_list.copy()
#
# С помощью среза [:]:
# new_list = original_list[:]
#
# С помощью функции list:
#
# new_list = list(original_list)
# Все эти способы создают новый список, независимый от оригинала.

# Кортеж
# tuple - (тайпл) - кортеж - неизменяемый список, может содержать разные типы данных, так же как и список
# тот же самый список, но не изменяемый. нельзя изменить, удалить, добавить
# так же можно хранить в кортеже список
# class "tuple" - кортеж
tuple0 = (1, 2, 3, 4) + (9, 7, 8)
tuple1 = ('string', 'apple', 1, 5, True) # разные типы данных
tuple2 = ('beef', 'classic', ['dream', 'mono', 1, 3]) # так же можно хранить в кортеже список
print(tuple0)
print(tuple1)
print(tuple2)
tuple2[2][0] = 'bag' # в кортеже можно изменять ТОЛЬКО, что уже изменяется - то есть список в квадратных скобках
print(tuple2)
tuple3 = ("dragon",) * 3 # ВАЖНО, если КОРТЕЖ содержит один элемент, то он должен заканчиваться запятой, иначе мы не получим кортеж
# так же можно умножать
print(tuple3)
print(type(tuple3))

# DZ 6
immutable_var = ('string', 'm-track', 'gaming', 1, 2, 3, True, False, ['apple', 'cherry', 'coco'])
print(immutable_var)
immutable_var [8][0] = 'alesis' # кортеж не изменяется, если в нем нет изменяемых данных (к таким относятся типы данных как список)
print(immutable_var)

mutable_list = ['glass', 'long', 'bridge', 1, 5, 10, True]
print(mutable_list)
mutable_list.append('self-mish') # добавили элемент
mutable_list.extend('delete') # добавили элемент по разбиванию на символы
mutable_list.extend(['insert' ,'end']) # если добавлять два элемента команда идентична .append
print(mutable_list)
mutable_list .remove('bridge') # удалили элемент
print(mutable_list)

# Словарь, пара, есть ключ и значение. Изменяемый тип данных .class "dict"
phone_book = {'Ilya':89524460977,'Gaben':30685006988, 'Alina':[89108845077,321], 'Spam':89005558085}
# работает это следующим образом 'КЛЮЧ' : 'ЗНАЧЕНИЕ', 'КЛЮЧ' : 'ЗНАЧЕНИЕ'
# на месте ключа не может быть измененных данных, но в значение может быть и список
print(phone_book)
# если нам нужен элемент, то мы должны с помощью [] указать ключ
# print ('HOMEP:', phone_book['Ilya'])
phone_book['Ilya'] = 89524444444 # мы можем изменять ЗНАЧЕНИЕ обращаясь к ключу
print(phone_book)
phone_book['Misha'] = 89107798734 # если мы обращаемся к несуществующему ключу и пробуем его изменить, он его создает
print(phone_book)
del phone_book['Spam'] # оператор del удаляет данные привязанные к ключу
print(phone_book)
phone_book.update( # обновляем список, то есть вводим в него новые данные
    {'Anton' : 89203219876,
     'Vova' :  89556498718}
    )
# метод .update обновляет словарь - вставляет в него новые данные
print(phone_book)
print(phone_book.get('Gaben')) # метод .get позволяется ПОЛУЧИТЬСЯ значение по ключу
print(phone_book.get('Spam')) # метод .get лучше, чем обращение, так как не создает данные, а покажет none - пусто, ничего
print(phone_book.get('Spam', 'Такого ключа не существует'))# так же мы можем поменять значение none на свое через (запятую) после ключа
print(phone_book)
# phone_book.pop('Vova') # так мы удаляем ключ со значением (удаляет один ключ со значением)
# метод .pop удаляет ключ со значением, а если мы укажем переменную, то мы как бы извлечем/перенесем ключ со значением в переменную
delete_phone_book = phone_book.pop('Vova')
print(delete_phone_book)
# list_one = [1,2,3] #,a = list_one.pop(1), print (a) ,print (list_one)# тоже самое можно проделывать со списком
print(phone_book)
print(phone_book.keys()) # метод .keys позволяет получить список ключей
print(phone_book.values()) # метод .keys позволяет получить список значений
print(phone_book.items()) # метод .item позволяет получиться ключ и значение

# Множество class "set"
# Особенность множества в том, что хранит оно только уникальные значения, то есть повторных данных быть не может и упорядочивает данные
set_ = {1, 2, 3, 4, 5, 5, 1, 3, 'StringAll', (1, 2, 3, 4, 9, 1)} # может хранить как числа, так и строки, так и кортеже (при списках выдает ошибку)
# при том что кортеж может хранить в себе повторяющие файлы
set_.discard(1,) # удаление первого элемента (не путать с индексом) удаляет по одному
# метод .discard() удаляет элемент из множества
print(set_)
list_1 = [1, 2, 3, 4, 4, 2, 1] # список
list_1 = set(list_1) # список перевели в множество
print(list_1)
list_1.discard(1) # метод .discard удаление элемента, в скобках указывается сам элемент, если такого элемента нет, то ошибки не будет
list_1.remove(2) # удаление элемента, в скобках указывается сам элемент, если такого элемента нет, то выдаст ошибку
# метод .discard от .remove отличаются тем, что дискард не выдаст ошибку при удалении, если такого элемента не будет
print(list_1)
# метод .pop работает по такому же принципу, что в списках и кортежах
# метод .add добавляет элемент в множество (один элемент)
list_1.add(17)
list_1.add(12)
print(list_1)

# DZ 7
my_dict = {'Ilya':2000, 'Alina':1999, 'Egor':1998} # Словарь с именами и год рождения
print(my_dict)
print(my_dict.get('Egor')) # запрос данных с помощью ключа, метод .get
print(my_dict.get('Misha','Данных нет')) # запрос данных с помощью ключа, метод .get, так как данных нет он выдает none
# но после ключа через запятую можно указать, текст при отсутствии данных
my_dict['Nikita'] = 1987 # если мы обращаемся к несуществующему ключу, то он создает его
my_dict['Artem'] = 1974 # а так мы могли изменить значение по ключу
print(my_dict)
deleted_my_dict = my_dict.pop('Egor') # методом .pop мы можем удалить элемент, но если мы присвоим ему переменную, то значение сохранится в переменную
print(deleted_my_dict) # вывод в консоль удаленного элемента и сохраненного в переменную
del my_dict['Artem'] # оператор del удаляет элемент по ключу

# Оператор del в Python является мощным инструментом для удаления объектов.
# Он позволяет удалять переменные, элементы списка, части списка и даже целые списки.

print(my_dict)

my_set = {'beef', 'apple', 1, 2, 4, 5, 6, 2 ,4, 3, 'apple'} # множество состоящие из разных типов данных
print(my_set)
my_set.add('cherry') # метод .add добавляет элемент в множество
my_set.add(10) # метод .add добавляет элемент в множество
print(my_set)
my_set.remove('beef') # метод .remove удаляет элемент в множестве (указать сам элемент)
print(my_set)

# DZ 8
grades = [[5, 3, 3, 5, 4], [2, 2, 2, 3], [4, 5, 5, 2], [4, 4, 3], [5, 5, 5, 4, 5]]
students = {'Johnny', 'Bilbo', 'Steve', 'Khendrik', 'Aaron'}
avg_scores = {} # пустой словарь для среднего балла
names = list(students) # преобразуем множество в список
names.sort() # в алфавитном порядке методом .sort
avg_scores.update(
    {names[0]:sum(grades[0]) / len(grades[0]), names[1]:sum(grades[1]) / len(grades[1])})
avg_scores.update(
    {names[2]:sum(grades[2]) / len(grades[2]), names[3]:sum(grades[3]) / len(grades[3])})
avg_scores.update(
    {names[4]:sum(grades[4]) / len(grades[4])})
# Обновили список следующим образом
# {Имя[Индекс]:Сумма.sum (НазваниеСписка[Индекс]/Кол-во символов.len(НазваниеСписка[Индекс])}
# функция sum сумма чисел
# функция len кол-во символов
print(avg_scores)

# DZ 1 GPT
grades = {
    'Lily': {'math': [4, 3, 5], 'english': [5, 4, 4], 'history': [3, 4]},
    'James': {'math': [5, 5, 4], 'english': [3, 4, 3], 'history': [4, 5]}
}
avg_scores_by_subject = {} # пустой словарь
avg_scores_by_subject.update(
    {"lily":{'math':sum(grades['Lily']['math']) / len(grades['Lily']['math']),
             'english':sum(grades['Lily']['english']) / len(grades['Lily']['english']),
             'history':sum(grades['Lily']['history']) / len(grades['Lily']['history'])}}
)
avg_scores_by_subject.update(
    {"James":{'math':sum(grades['James']['math']) / len(grades['James']['math']),
             'english':sum(grades['James']['english']) / len(grades['James']['english']),
             'history':sum(grades['James']['history']) / len(grades['James']['history'])}}
)

print(avg_scores_by_subject)
print(grades['Lily']['english']) # выводим оценки по предмету 'english' для 'Lily' из словаря grades(слева направо читается код)

# DZ 9
print('Hi,PyCharm and Urban') # вывод текста в консоль
x = 43 # присваиваем переменной х значение 43
y = 32 # присваиваем переменной y значение 43
print(x * y) # вывод в консоль переменной x * y
print('End line') # вывод текста в консоль

name = input('Введите ваше имя: ')
# if(если) переменная (name) равняется значению 'веденных в кавычках'
# то выводится строка которая в этом блоке прописана с помощью табуляции
# двоеточие в конце служит для конца условия
# принимает только одно условие
if name == 'Илья':
    print(f'Добро пожаловать юный падаван, {name} ')
# elif это сокращение от else if - иначе если
elif name == 'Алина':
    print(f'Добро пожаловать юный падаван, {name} ')
# else - иначе. Сразу ставится двоеточие
else:
    print(f'Привет, {name}')

number = int(input('Введите число: '))
# if(если) остаток от деления на 3 равен 0, выводим Fizz
if number % 5 == 0  and number % 3 == 0:
    print('FizzBuss')
elif number % 3 == 0:
    print('Fizz')
elif number % 5 == 0:
    print('Buss')
else:
    print('Программе не нравится число')
# if(если) переменная (name) равняется значению 'веденных в кавычках'
# elif это сокращение от else if - иначе если
# else(иначе) сразу ставится двоеточие

'''if — проверяет первое условие.
elif (сокращение от else if) — проверяет следующие условия, если предыдущее условие ложно.
else — выполняет блок кода, если все предыдущие условия ложны.'''

'''Cуществует негласное правило при формировании условий: когда имеются несколько условий, самое маловероятное или самое сложное следует поместить в начало'''
# elif это сокращение от else if - иначе если
'СТРОГИЙ ОПЕРАТОР'
# and= и - если все условия с двух сторон равны, то все выражения считаются истинными
# and= и - чтобы получить «True», должны быть истинны оба выражения
'НЕ СТРОГИЙ ОПЕРАТОР'
# or= или - выражение ложно, если оно с двух сторон ложно, если одно из них истинное, то все выражения истинно
# or= или, чтобы получить «True» достаточно, чтобы истинным было хотя бы одно.

# DZ 10
first = int(input('Введите 3 целых числа: '))
second = int(input('Введите 3 целых числа: '))
third = int(input('Введите 3 целых числа: '))
if first == second == third: # if(если) first равняется second равняется third то выводим 3, то три значения равны
    print(3)
elif first == second or second == third or first == third: # здесь получается надо нам получиться одну истину, чтобы получить значение 2
    print(2)
else: # иначе если не одно число не равно, то получаем ноль
    print(0)

'''Ctrl + Alt + L''' # сборка кода по пеп8, pep8

# DZ 2 GPT
a = int(input('Введите одно число: '))
b = int(input('Введите одно число: '))
c = int(input('Введите одно число: '))
d = int(input('Введите одно число: '))
if a == b == c == d:
    print(4)
elif a == b == c or a == b == d or b == c == d or a == c == d:
    print(3)
elif a == b or a == c or a == d or b == c or b == d or c == d:
    print(2)
else:
    print(0)


'''while - до тех пор, пока, это значит, что до тех пор, пока условие, вводимое while, 
истинное, тело цикла продолжит выполняться, при этом количество итераций заранее не известно 
(в отличие от циклов с оператором for).'''

while True:
    number = int(input('Введите число: '))
    if number % 2 == 0:
        print('Число четное')
        break
        # break - завершает выполнение цикла полностью
        # Используется, для выхода из цикла, как только выполнено нужное условие
    else:
        print('Число нечетное')

# continue - пропускает текущую итерацию цикла и переходит к следующей
 # Используется, для перехода к следующей итерации, если выполнено нужное условие

# Пример с тройкой
# GPT Пример работы "continue"
i = 1
while i <= 5:
    if i == 1:
        i += 1  # увеличиваем i перед continue, чтобы избежать зацикливания
        continue  # Пропускаем вывод 1 и переходим к следующей итерации
    print(i)
    i += 1


while True:
    number = int(input('Введите число: '))

# Проверка на отрицательное число
    if number < 0:
        print('Число отрицательное. Введите положительное число.')
        continue # Возвращаемся к началу цикла, чтобы снова запросить ввод

    # Проверка на четность
    if number % 2 == 0:
        print('Число четное')
        break # Завершаем цикл, если число четное
    else:
        print('Число нечетное')

'''# break - завершает выполнение цикла полностью
# Используется, для выхода из цикла, как только выполнено нужное условие

# continue - пропускает текущую итерацию цикла и переходит к следующей
# Используется, для перехода к следующей итерации, если выполнено нужное условие
# Обычно ставится в начале, когда нужно сразу пропустить текущую итерацию цикла, если выполнено определенное условие
# Важно заметить, что continue можно ставить в любом месте цикла, в зависимости от логики программы
# Главное, чтобы оно выполняло свою задачу — пропускать текущую итерацию и переходить к следующей'''

# DZ 10
my_list = [42, 69, 322, 13, 0, 99, -5, 9, 8, 7, -6, 5]
my_list_index = 0 # начальный индекс для списка my_list
while my_list_index < len(my_list): # цикл идет до того момента пока индекс меньше длины списка
    if my_list[my_list_index] < 0: # если элемент списка меньше 0
        break # то цикл заканчивается, тк встретили отрицательно число
    elif my_list[my_list_index] > 0: # иначе если элемент списка больше 0
        print(my_list[my_list_index]) # вывод его в консоль
    my_list_index += 1 # увеличиваем индекс, чтобы перейти к следующему элементу списка
    # Увеличение индекса должно быть вне блоков if или elif, потому что мы хотим, чтобы индекс увеличивался в любом случае после каждого прохода цикла,
    # Независимо от того, выполнилось ли условие в if или elif.

'''В Python квадратные скобки [] — это стандартный синтаксис для индексации (обращения к элементам коллекций). 
Когда ты пишешь my_list[my_list_index], ты говоришь программе: 
"Возьми элемент списка my_list, который находится на позиции, указанной в переменной my_list_index."'''

# DZ GTP 3
numbers = [2, 7, 18, 5, 6, 12, 9, 22, 4, 15, 10]
numbers_index = 0
while numbers_index < len(numbers):
    if numbers[numbers_index] > 20:
        break
    if numbers[numbers_index] == 10:
        numbers_index += 1
        continue
    if numbers[numbers_index] % 2 == 0:
        print(numbers[numbers_index])
    numbers_index += 1
print('123')

# DZ 4 GPT
temps = [16, 22, 20, 14, 26, 18, 9, 23, 15] # температура
temps_index = 0
while temps_index < len(temps):
    if temps[temps_index] < 10:
        break
    if temps[temps_index] == 20:
        temps_index += 1
        continue
    if 15 <= temps[temps_index] <= 25:
        print(temps[temps_index])
    temps_index += 1

# for (название переменной), как правило, ее называют «i», «j» или «k»
# данные переменные будут существовать только в переделе цикла
# for(для)(переменной) in(в) "последовательность"

for i in 1, 2, 3, 4:
    print(i)
list_ = ['hello', 'world', 'party']
for i in list_:
    if i == 'party':
        list_.remove(i)
print(list_)

# Функция range в Python создаёт последовательность чисел.
# range(start, stop, step)
# start (необязательный):
# Начальное значение последовательности.
# По умолчанию равно 0.
#
# stop (обязательный):
# Конечное значение последовательности (не включается в результат).
#
# step (необязательный):
# Шаг изменения последовательности.
# Может быть положительным или отрицательным.
# По умолчанию равно 1.
## Выше описана работа функции с числами

# Функция len() используется для получения длины (количества элементов) объектов, таких как:
# Списки (list),
# Кортежи (tuple),
# Строки (str),
# Словари (dict),
# Множества (set),
# И другие коллекции (например, пользовательские классы, если у них определён метод __len__).

# Функция hash(object) используется для получения хеш-значения объекта.
# object: объект, для которого нужно вычислить хеш.
# Этот объект должен быть неизменяемым (например, строки, числа, кортежи и другие типы, которые поддерживают хеширование).

# Чтобы работать с индексами в последовательностях (например, списках), range и len — это стандартный способ в Python.

list_ = ['hello', 'world', 'party']
for i in range(len(list_)):
    print(list_[i]) # вывод на экран каждого элемента по отдельности
    list_[i] = 'vince'
    print(list_[i]) # замена каждого элемента на другой

list_2 = [2, 4 ,8, 9, 1, 19]
sum_ = 0
for i in range(len(list_2)):
    sum_ += list_2[i]
print(sum_)

for i in range(1, 11): # start, end, step # i - 1
    for j in range(1, 11): # j - 1
        print(f'{i} x {j} = {i*j}')
# первый цикл с переменной i создается со значением 1
# дальше внутренний цикл с переменной j со значением 1
# пока цикл for с переменной j не дойдет до 10, то цикл for с переменной i не поменяется и так по кругу

dict_ = {'a': 1, 'b': 2, 'c': 3}
for i in dict_:
    print(i, dict_[i])

dict_1 = {'a': 1, 'b': 2, 'c': 3}
for i, k in dict_1.items():
    print(i, k)

# DZ GPT
numbers = [10, 15, 20, 25, 30, 35, 40, 45, 50]
even_numbers = []
odd_numbers = []
for i in range(len(numbers)):
    # Цикл for перебирает индексы списка numbers, начиная с 0 и заканчивая (длина списка - 1).
    # Функция range(len(numbers)) создаёт последовательность чисел от 0 до len(numbers) - 1.
    # На каждой итерации переменная i принимает текущее значение из этой последовательности.
    # Таким образом, i указывает на индекс текущего элемента в списке numbers.
    # Переменная i временная и меняется на каждом новом круге цикла, пока не переберёт все индексы.
    ### Итерация - повторение
    n = numbers[i] # n — это текущее число из списка `numbers`, с которым мы сейчас работаем
    if n % 2 == 0: #  Если остаток от деления числа `n` на 2 равен 0, то оно четное
        even_numbers.append(n) # Добавляем `n` в список четных чисел
    else: # Иначе, если число не делится на 2 без остатка, оно нечетное
        odd_numbers.append(n) # Добавляем `n` в список нечетных чисел
print('Even', even_numbers)
print('Odd', odd_numbers)

numbers = [3, 10, 15, 18, 20, 21, 25, 30, 33, 35, 40, 45, 50, 60]
divisible_by_3 = []
divisible_by_5 = []
for i in range(len(numbers)):
    n = numbers[i]
    if n % 3 == 0:
        divisible_by_3.append(n)
    if n % 5 == 0:
        divisible_by_5.append(n)
print(divisible_by_3)
print(divisible_by_5)

numbers = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
even_numbers = []
greater_than_ten = []

for k in (numbers):
    # k = numbers[i]
    if k % 2 == 0:
        even_numbers.append(k)
    if k > 10:
        greater_than_ten.append(k)

print(even_numbers)
print(greater_than_ten)

numbers = [23, 45, 12, 67, 89, 34, 54, 23, 90, 123, 78, 56]
odd_numbers = [] # нечетные
even_numbers = [] # четные
for q in numbers:
    if q % 2 == 0:
        even_numbers.append(q)
    else:
        odd_numbers.append(q)
print(odd_numbers)
print(even_numbers)
print(sum(odd_numbers))
print(sum(even_numbers))

numbers = [30, 45, 60, 23, 70, 81, 90, 100, 125, 150, 170, 200]
divisible_by_5 = []
divisible_by_3_and_5 =[]
greater_than_50 =[]
for b in range(len(numbers)):
    z = numbers[b]
    if z % 5 == 0 and z % 3 == 0:
        divisible_by_3_and_5.append(z)
    if z % 5 == 0:
        divisible_by_5.append(z)
    if z > 50:
        greater_than_50.append(z)

print(divisible_by_5)
print(divisible_by_3_and_5)
print(greater_than_50)

numbers = [23, 45, 60, 70, 81, 100, 150, 170, 200, 55, 30, 9, 12]
even_numbers = [] # четные
odd_numbers = [] # нечетные
divisible_by_3_and_5 = []
numbers.sort()
for p in range(len(numbers)):
    u = numbers[p]
    if u % 3 == 0 and u % 5 == 0:
        divisible_by_3_and_5.append(u)
    if u % 2 == 0:
        even_numbers.append(u)
    else:
        odd_numbers.append(u)
print(numbers)
print(even_numbers)
print(odd_numbers)
print(divisible_by_3_and_5)
print(len(even_numbers))
print(len(odd_numbers))
print(sum(divisible_by_3_and_5))

# DZ 11
# Исходный список чисел от 1 до 15
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]

# Пустые списки для хранения простых и не простых чисел
primes_ = []      # Сюда добавим простые числа
not_primes = []   # Сюда добавим числа, которые не являются простыми

# Основной цикл: перебираем каждое число из списка numbers
for i in range(len(numbers)):
    is_prime = True     # Переменная-флаг: изначально считаем, что число простое
    n = numbers[i]      # Текущее число из списка, которое будем проверять

    # Вложенный цикл: проверяем, есть ли делители у числа n
    # (перебираем делители от 2 до n-1)
    for k in range(2, n):
        if n % k == 0:    # Если n делится на k без остатка, то:
            is_prime = False  # Меняем флаг на False, значит, число не простое
            break            # Прерываем вложенный цикл, так как нашли делитель

    # После проверки числа на простоту добавляем его в соответствующий список
    if is_prime and n > 1:     # Если число простое и больше 1
        primes_.append(n)      # Добавляем его в список простых чисел
    elif n > 1:                # Если число не простое и больше 1
        not_primes.append(n)   # Добавляем его в список не простых чисел

# Выводим списки простых и не простых чисел
print("Primes:", primes_)
print("Not Primes:", not_primes)

# def имя_функции (аргументы):
#     тело_функции
#     return результат
# Здесь:
# имя_функции ― название, с помощью которого можно вызывать функцию в коде;
# аргументы ― значения, которые функция принимает на вход. Это поле может быть пустым;
# тело_функции ― набор инструкций, которые выполняются при вызове;
# результат ― значения, которые функция возвращает при завершении работы.

# def (от англ. define — определить, обозначить)
# То есть, мы как бы определяем функцию. Так же, как и с переменными, по названию функции мы должны понимать ее назначение.
# Рассмотренная ниже функция – это самая простая функция, которую можно встретить - обычная.
# Но функции можно разделить на несколько видов: обычные, принимающие, возвращающие и анонимные.
# Обычная функция
def say_hello():
    print('Hello')

say_hello()

def say_hello(name):
    print('Hello', name)

say_hello(name)

# Принимающая функция
# Поскольку функция принимающая (какое-то значение), у нее есть параметр, в момент вызова функции мы обязательно должны передать этот параметр ей
def say_hello(name): # def - определить say_hello (аргумент)
    print('Hello,', name)

say_hello('Ilya')
say_hello('Alina')
say_hello('Gaben')

import random # библиотека рандом

# .randint(3, 20) метод randint генерирует случайное число от - до
# .choice(объект) метод choice генерирует случайное число из объекта

# Возвращающая функция
# Оператор return используется в функциях для возвращения данных после выполнения работы самой функции.
def lottery(): # определяем лотерея
    tickets = [1, 2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10] # в которой содержится список от 1 до 10 # импорт библиотеки рандом
    win = random.choice(tickets) # переменная содержащая в себе рандом из списка tickets
    return win # Возврат win
# После команды return функция прекращает выполнять дальнейшие команды.
# Давайте попробуем вызвать нашу функцию. В ответе ничего не видим.


print(lottery()+lottery())

# Когда мы пишем просто lottery(), функция выполняется, выбирает случайное значение, но затем сразу прекращает работу и возвращает значение,
# которое просто "зависает" в памяти, так как никуда не передано. Если мы хотим увидеть это значение,
# нам нужно вывести его на экран (через print) или сохранить в переменную.
#
# Оба варианта — с print и с присвоением переменной — имеют свои особенности и подойдут для разных ситуаций:
#
# print(lottery()): Этот способ сразу выводит результат на экран, что полезно для быстрой проверки, например, чтобы увидеть результат в консоли.
#
# win = lottery(): Этот вариант сохраняет значение, и мы можем использовать его в дальнейшем коде, повторно к нему обращаться, или, как в примере,
# складывать результаты нескольких запусков функции.

# Но на самом деле возвращающие функции на месте своего вызова оставляют после себя какое-то значение.
# Мы можем поступить так, создать переменную и сохранить в нее вызов функции.
win = lottery() + lottery()
print(win)
print('----')

def lottery(mon, thue): # определяем лотерея
    tickets = [1, 2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10] # в которой содержится список от 1 до 10 # импорт библиотеки рандом
    win1 = random.choice(tickets) # переменная содержащая в себе рандом из списка tickets
    tickets.remove(win1)
    win2 = random.choice(tickets) # переменная содержащая в себе рандом из списка tickets
    return win1, win2 # Возврат win
win1, win2 = lottery('mon', 'thue')
print(win1, win2)
print('----')

# Если мы не знаем сколько параметров будет принимать функция, мы можем написать, например, «*args» для обычных параметров и «**kwargs» для именованных.
def lottery(*args, **kwargs): # определяем лотерея
    tickets = [1, 2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10] # в которой содержится список от 1 до 10 # импорт библиотеки рандом
    win1 = random.choice(tickets) # переменная содержащая в себе рандом из списка tickets
    tickets.remove(win1)
    win2 = random.choice(tickets) # переменная содержащая в себе рандом из списка tickets
    print(*args)
    return win1, win2 # Возврат win
win1, win2 = lottery(1, 2, 3, 4, 5, 6, 7 ,8 ,9 ,10)
print(win1, win2)
print('----')

# Параметры по умолчанию
# Но в случае с нашей функцией нам необязательно передавать параметры, если мы запустим программу, то увидим,
# что компьютер вывел «2» и «True» (Рис.21). Потому что тут были заданы параметры по умолчанию.
def test(a = 2, b = True):
    print(a, b)

test(False, 22)
test([1, 3])
# В ответе мы видим наш список и все то же «True». То есть наш список встал на место параметра «а» и распаковался, как один объект.
# Чтобы распаковать его так, чтобы каждый элемент встал на соответствующее какому-то параметру место, нам нужно поставить звездочку перед списком.
# Чтобы распаковать словарь, нужно поставить две звездочки.
test(*[1, 3])

# DZ 11
def get_matrix(n, m, value): # определяем функцию get_matrix с тремя параметрами
    matrix = [] # создаем пустой список для хранения матрицы
    for i in range(n): # цикл создает n строк в матрице
        matrix.append([]) # добавляем пустой список как новую строку
        for k in range(m): # добавляет m элементов в каждую строку
            matrix[i].append([value]) # вставляем значение value в текущую строку i
    return matrix # возврат данных в список
result1 = get_matrix(2, 2, 10) #
result2 = get_matrix(3, 5, 42) #
result3 = get_matrix(4, 2, 13) #
print(result1)
print(result2)
print(result3)

# DZ 12
# Сначала генерируем случайное число от 3 до 20
one_stone = random.randint(3, 20)
# Печатаем это случайное число, чтобы увидеть, что получилось
print(one_stone)
print('-------')
# Переменная для хранения результата
result = ''
# Два вложенных цикла: первый перебирает все значения от 1 до (one_stone-1),
# второй — от (i+1) до one_stone, чтобы не повторять одинаковые пары
for i in range(1, one_stone - 1):
    for j in range(i + 1, one_stone):  # j начинается с i+1, чтобы не повторять (i, i)
        sum_j_i = i + j  # Считаем сумму текущей пары (i + j)
        # Проверяем, делится ли число one_stone на эту сумму
        if one_stone % sum_j_i == 0:
            result += str(i) + str(j) + ' '  # Если делится, добавляем пару в результат

# Печатаем все найденные пары в строковом виде, убираем лишний пробел в конце
print(result.strip()) # strip(), чтобы удалить пробелы в конце строки

'''Существует несколько видов пространства имен:
Локальное пространство имен
Глобальное пространство имен
Встроенное пространство имен'''

'''Встроенное пространство имен включает в себя имена каких-либо встроенных функций. 
Локальное представляет собой имена, которые мы используем внутри каких-либо функций, которые мы используем и создаем самостоятельно. 
Глобальное пространство имен включает в себя все, что есть в нашей программе, исключая лишь локальное пространство.
в Python переменные, определённые вне функций, автоматически доступны внутри функций, если они только читаются, а не изменяются'''


# Глобальное пространство
z = 5
x = 10


def printer():
    # То что, находится в функции - называется локальным пространством имен
    # Часть, которая находится внутри функции, и является локальным пространством имен
    # Переменные «c» и «d» существуют до тех пор, пока функция не завершит свою работу
    ### Если нам нужно использовать глобальную переменную в функции то пишем global
    global z, x
    c = 110
    d = 220
    z = 'Str'
    x = 'Str 2'
    # В свою очередь есть такая особенность, что к глобальному пространству имен мы можем обращаться напрямую из локального
    # Сделаем для себя пояснение, что «c» и «d» у нас local, а «z» и «x» это global
    print(c, d, 'local')
    print(z, x, 'global')
 # При запуске программы мы видим, что теперь даже после завершения функции используются значения, присвоенные переменным внутри нее.
 # Таким образом во время вызова функции мы переопределили значения переменных «z» и «x» из глобального пространства имен.

printer()
print(z, x)

# DZ 13
calls = 0 # переменная со значением 0
def count_call(): # определяем count_call с пустым аргументом
    global calls # используем глобальную переменную, которая сохранена вне функции
    calls += 1 # прибавляем и сохраняем значение в переменную call
    return calls # возвращаем измененное значение в переменную calls
def string_info(string): # определяем string_info с принимающим аргументом
    count_call() # используем функцию count_call для подсчета вызова остальных функция
    tiple1_info_str = (len(string), string.upper(), string.lower()) # создаем кортеж, подсчитываем кол-во элементов в string(принимающем аргументе)
    print(tiple1_info_str) # выводим в консоль кортеж

def is_contains(string, list_to_search): # определяем is_contains с двумя принимающими аргументами
    count_call() # используем функцию count_call для подсчета вызова остальных функция
    string = string.lower() # создаем переменную в которой аргумент переводится в нижний регистр, так как переменные взаимозаменяемые даем такое же название
    new_list_to_search = [z.lower() for z in list_to_search] # Интересная строка. Создаем новый список, в котором элементы из списка list_to_search
                                                             # Преобразуются в нижний регистр
                                                             # Цикл
                                                             # Для каждого элемента в списке list_to_search переменная z временно принимает
                                                             # значение этого элемента, и к нему применяется метод lower(), чтобы привести строку к нижнему регистру.

    if string in new_list_to_search: # если аргумент есть в списке
        print(True) # то выводим в консоль значение True
    else: # иначе
        print(False) # выводим False

string_info('Capybara')
string_info('Armageddon')
is_contains('Urban', ['ban', 'BaNaN', 'urBAN']) # Urban ~ urBAN
is_contains('cycle', ['recycling', 'cyclic']) # No matches
print(calls)

def print_param(a = 1, b = 2, c = 3): # параметры по умолчанию, то есть если мы вызываем функция и не задаем ей параметры, он берет те, что написаны в аргументах
    print(a,b ,c)

print_param(12,3, 4) # так же мы можем переопределять параметры
print_param(c ='String') # так же мы можем указать, что хотим изменить конкретный параметр, при этом если не указывать другие параметры, то они будут взяты из параметров по умолчанию
print_param(c = 3, a = "StringSSS", b = True) # так же мы можем давать параметры в разнобой и другие типы данных

def print_param1(*, a ,b ,c):# Существует также способ конкретно указать, что параметр будет именованным. Нужно поставить знак «*» перед этим параметром.
    print(a, b ,c)
print_param1(a = 1,b = 3,c = 4)

def func_with_params(a, b = 2, c = 11):
    print(a + b + c)

func_with_params(3) # так же если в функции первое значение не по умолчанию, а следующие по умолчанию, то мы можем вызвать функцию и передать ей первое значение, а второе подставится само
func_with_params(3, 10) # но мы так же можем переопределять и второе значение
func_with_params(3)
func_with_params(3)

def func_with_params1(a, b = 2, c = []): # Значения параметров создаются не в момент, когда мы вызываем функцию, а создаются при её определении.
    c.append(a)
    print(c)
# Если запустим, то увидим, что эти значения, которые мы передаем, добавляются не в новый список, а в уже существующий
# Этот список был создан в момент определения функции func_with_params, и каждый вызов просто добавляем, в уже существующий список, новый элемент.
func_with_params1(3)
func_with_params1(3)
func_with_params1(3)
# Если нам необходимо избежать такого, например, работать в моменте, мы можем в “с” указать значение по умолчанию “None” и в функции проверить, что если “с”- “None”,
# Тогда мы говорим, что “с” будет списком, и в этот список добавим “а”, потом выведем этот список. Запускаем. В таких случаях у нас список “с” будет переопределяться.
# Если мы будем менять объекты, результат тоже будет, соответственно разным.
def func_with_params2(a, b = 2, c = None):
    if c is None: # если(if) С являет(is) None(ничего)
        c = []         # Если c равно None, создается пустой список для С
        c.append(a)    # Затем добавляется значение a в список С
    print(c)           # Печатается список С

        # Проверка if c is None:
    # Когда функция вызывается без аргумента С, параметр С будет None.
    # Проверка if c is None позволяет определить, был ли передан аргумент для С. Если С не передавали, то С равен None.
    # Если С — None, то переменной c присваивается пустой список [].

func_with_params2(2)
func_with_params2(3)
func_with_params2(4)

# DZ 14
def send_email(message, recipient, *, sender = "university.help@gmail.com"):
    ### Проверяем, что оба адреса имеют знак "@" и заканчиваются на ".com", ".ru" или ".net"
    if ('@' not in recipient or not recipient.endswith(('.com', '.ru', '.net')) or
            '@' not in sender or not sender.endswith(('.com','.ru','.net'))):
    # если(if) "элемент`а" нет(not) в(in) recipient или(or) нет(not) recipient.endswith(чего нет)
    # если у нас в if несколько условий, то они пишутся в скобках
    # метод .endswith проверяет - заканчивается ли строка указанным суффиксом, и возвращает True, если это так, или False, если нет
    ## Метод .endswith() принимает: Либо один строковый суффикс, например: string.endswith(".com").
    ## Либо кортеж из нескольких суффиксов, например: string.endswith((".com", ".ru", ".net"))
    ### Если хотя бы одно из условий истинно (то есть не выполнено), то выводим сообщение
        print(f'Невозможно отправить письмо с адреса {sender} на адрес {recipient}') # выводим
    elif sender == recipient: # иначе если sender ==(равен) recient то
        print('Нельзя отправить письмо самому себе') # выводим
    elif sender == "university.help@gmail.com": # Проверяем, используется ли адрес отправителя по умолчанию
        print(f'Письмо успешно отправлено с адреса {sender} на адрес {recipient}') # выводим
    else: # иначе ни одно из условий не выполнено
        print(f'НЕСТАНДАРТНЫЙ ОТПРАВИТЕЛЬ! Письмо отправлено с адреса {sender} на адрес {recipient}') # выводим

send_email('Это сообщение для проверки связи', 'vasyok1337@gmail.com')
send_email('Вы видите это сообщение как лучший студент курса!', 'urban.fan@mail.ru', sender='urban.info@gmail.com')
send_email('Пожалуйста, исправьте задание', 'urban.student@mail.ru', sender='urban.teacher@mail.uk')
send_email('Напоминаю самому себе о вебинаре', 'urban.teacher@mail.ru', sender='urban.teacher@mail.ru')

# Одна “звездочка” используется для распаковки и запаковки именно позиционных параметров, которые содержат один элемент: списки, кортежи, множества и т.д.;
# Две “звездочки” используются для запаковки и распаковки именованных параметров. В Python такая коллекция одна - словари. В них элементы хранятся парами.
# Для того чтобы добавить ключ и пару через функция надо применять не двоеточие, а равно как будто что-то присваиваем
def params3(*params): # кортеж
    print(params)

params3(1, 3 ,5, 2, 3)

def params1(a, b, c, d, e):
    print(a, b ,c ,d, e)

list1 = [1, 2, 3, 4, 5]
params1(*list1) # распаковка списка

def params2(**params): # словарь
    print(params)
params2(a= 2, b= 2) # при создании словаря в вызове функции, в ключе необходимо называть именованные параметры
# Для того чтобы добавить ключ и пару через функция надо применять не двоеточие, а равно как будто что-то присваиваем

# DZ 15
def print_params(a = 1, b = 'строка', c = True): # Функция с тремя параметрами по умолчанию
    print(a, b ,c) # вывод параметром

print_params(35) # вызов функции с параметром, так как он один, следующие подхватываются, которые были по умолчанию
print_params(4, 'test') # вызов функции с двумя параметром, так как их два, следующие подхватываются, которые были по умолчанию
print_params(8, None, False) # вызов функций с тремя параметрами, которые мы переопределили
print_params()

print_params(b = 25) # вызов функции с переопределением определенного параметра
print_params(c = [1, 2, 3]) # вызов функции с переопределением определенного параметра (в данном случае) создание списка в параметре C

values_list = [100, 'OneZero', True] # список
values_dict = {'a':200, 'b':'ZeroOne', 'c':None} # словарь ключ:значение

print_params(*values_list) # вызов функции с распаковкой списка
print_params(**values_dict) # вызов функции с распаковкой словаря(ключ это параметр в функции) важно, чтобы их было одинаковое кол-во
values_list_2 = [54.32, 'Строка' ] # Список
print_params(*values_list_2, 42) # вызов функции с распаковкой списка и замена параметра C (что пишет pyharm ошибочно) так как в списке уже два параметра, то мы ввели третий
'----------------------------------------------------------------------------------------------------------------------'
def test_func(*params): # функция где в аргументе одна звездочка, принимает неопределенное кол-во аргументов, создает кортеж
    print('Тип',type(params))
    print("Аргумент", params)

test_func()
test_func(1, 3, 5, 4, 6)

def summator(txt, *values):
    s = 0
    for i in values:
        s += i
    return f'{txt}{s}'

print(summator('Сумма чисел:', 2, 3, 5))

def info(**values): # # функция где в аргументе две звездочки, принимает неопределенное кол-во аргументов, создает словарь
    print('Тип', type(values))
    print("Аргумент", values)
    for key, value in values.items():
        print(key, value)
info(name='Ilya', cource='Python') # при создании словаря в вызове функции, в ключе необходимо называть именованные параметры
# Для того чтобы добавить ключ и пару через функция надо применять не двоеточие, а равно как будто что-то присваиваем

def info(value ,*types, name_author = 'Ilysha', **values): # # функция где в аргументе две звездочки, принимает неопределенное кол-во аргументов, создает словарь
    # всегда в аргументе функции сначала идет одна звездочка, потом две
    print('Тип', type(values))
    print("Аргумент", values)
    for key, value in values.items():
        print(key, value)
    print(types)
info('Пример использования аргументов всех типов', 2, 3, 5, 4, name='Ilya', cource='Python') # при создании словаря в вызове функции, в ключе необходимо называть именованные параметры
# Для того чтобы добавить ключ и пару через функция надо применять не двоеточие, а равно как будто что-то присваиваем

def my_sum(n, *args, txt = 'Сумма числе'):
    s = 0
    for i in range(len(args)):
        s += args[i] ** n
    print(f'{txt}:{s}')

my_sum(1, 1, 2, 3, 4, 5)
my_sum(2, 2, 3, 4, 5,txt='Сумма квадратов' )

# DZ 16
def single_root_words(root_word, *other_words): # определяем функцию с двумя аргументами (первый позиционный и второй *кортеж)
    same_words = [] # создание пустого списка
    root_word = root_word.lower() # объявляем, что root.world равен root.world.lower() преобразует аргумент в нижний регистр (название такое же так как переменные взаимозаменяемые)
    for i in other_words: # цикл перебора в котором переменная i временно принимает значение из списка
        if root_word in i.lower() or i.lower() in root_word: # проверка. если(if) root_word в(in) i.lower()
            # получается что мы проверяем есть ли слово root_word в индексе i, который при проверке преобразует слово в нижний регистр, но при в добавление в список сохранит изначальный регистр
            # так же проверяем и обратно
            same_words.append(i) # если есть совпадение, то добавляем слово хранящиеся в переменной i в список
    return same_words # возвращаем значение в список

result1 = single_root_words('rich', 'richiest', 'orichalcum', 'cheers', 'richies')
result2 = single_root_words('Disablement', 'Able', 'Mable', 'Disable', 'Bagel')
print(result1)
print(result2)

# Рекурсия — это цепочка вызовов функции сама собой, где каждое новое значение строится на основе предыдущего,
# пока не будет достигнут базовый случай.
def summa(n):
    # Определяем функцию summa, которая принимает один аргумент n.
    # Эта функция будет использовать рекурсию для вычисления суммы всех чисел от 1 до n включительно.
    if n == 1:  # Базовый случай
        # Если n равно 1, то мы достигли базового случая.
        # Базовый случай нужен для остановки рекурсии.
        # Здесь функция просто возвращает 1, потому что сумма от 1 до 1 — это 1.
        return 1
    else:  # Рекурсивный случай
        # Если n не равно 1, то мы выполняем рекурсивный вызов.
        # Сначала функция возвращает n (текущую величину), добавляя к результату вызова summa(n - 1).
        # summa(n - 1) вычисляет сумму чисел от 1 до n-1.
        return n + summa(n - 1)

# После определения функции вызовем её для демонстрации:
print(summa(5))
# summa(5)
# └── 5 + summa(4)
#     └── 4 + summa(3)
#         └── 3 + summa(2)
#             └── 2 + summa(1)
#                 └── 1 (базовый случай)
# Обратный процесс:
# summa(1) → 1
# summa(2) → 2 + 1 = 3
# summa(3) → 3 + 3 = 6
# summa(4) → 4 + 6 = 10
# summa(5) → 5 + 10 = 15
#
# Краткое описание:
# Рекурсия в функции summa работает следующим образом:
# 1. Функция вызывает сама себя с уменьшением аргумента (n - 1), пока n не станет 1 (базовый случай).
# 2. При достижении базового случая возвращается 1.
# 3. В процессе возврата накапливается результат: сумма n + результат предыдущего вызова.

# DZ 17
def get_multiplied_digits(number): # определяем функцию с одним аргументом
    str_number = str(number) # Преобразуем аргумент в строку
    first = int(str_number[0:1]) # сохраняем первое число в переменную first из переменyой str_number, предварительно перевели ее в int
    if len(str_number) > 1: # если длина строки больше 1, то возвращаем число умноженную на функцию со срезом
        return first * get_multiplied_digits(int(str_number[1:]))
    # Рекурсивный случай: вызываем функцию для оставшейся части числа (все цифры, кроме первой),
    # а результат умножаем на `first`.
    # Таким образом, постепенно умножаем первую цифру на произведение остальных цифр.
    elif len(str_number) == 1: # базовый случай число строки равно 1, то возвращаем first
    # Базовый случай рекурсии: если осталась только одна цифра, возвращаем её.
        return first

resultget = get_multiplied_digits(40203)
print(resultget)

# DZ GPT
def sum_of_digits(n):
    if n < 10:  # Базовый случай: число состоит из одной цифры
        return n
    else:  # Рекурсивный случай
        last_digit = n % 10  # Последняя цифра
        remaining_digits = n // 10  # Оставшиеся цифры
        return last_digit + sum_of_digits(remaining_digits)

print(sum_of_digits(45678))

def factorial(n):
    if n < 1:
        return 'Введите число большое одного'
    # Базовый случай: если n равно 1, факториал равен 1
    elif n == 1:
        return 1
    else:
        # Рекурсивный случай: n умножается на факториал (n-1)
        return n * factorial(n - 1)

# Пример вызова функции
print(factorial(4))
print(f'Факториал для 5 равен: {factorial(5)}')  #

'''Существует перечень функций, которые встречаются при попытке преобразовать один тип данных к другому:
#int() - целое число int(input()) # вводимый текст юзера преобразуется ва число
#float() - число с плавающей запятой
#bool() - логические значения
#str() - строки
#list() - список
#tuple() - кортеж
#dict() - словарь
#set() - множество'''

salary = [2300, 1800.80, 5000, 1234.02, 7500.12]
print(round(sum(salary) / len(salary), 2),'- средняя зарплата в компании') # функция sum() - находит сумму всех значений
                                                                 # функция len() - возвращает длину передаваемой последовательности
                                                                 # функция round() - работа с числами после точки,
                                                                 # возвращает число с определенным количеством цифр после точки
                                                                 # В общем виде она выглядит так: round(number, digits).
# В качестве первого аргумента (number) передаём дробное число, а во втором (digits) указываем количество чисел после запятой.
# Второй аргумент по умолчанию равен нулю.
print(round(max(salary),2),'- максимальная зарплата в компании')          # функция max() - находит максимальное значение/элемент в переданной последовательности
print(round(min(salary),2),'- минимальная зарплата зарплата в компании')  # функция min() - находит минимальное значение/элемент в переданной последовательности

name_salary = ['Илья', 'Алина', 'Миша', 'Юля', 'Артем']

# zip - функция, которая позволяет объединять элементы из нескольких итерируемых объектов в один итерируемый объект
### zipped_name_salary = zip(name_salary, salary) ###
### print(zipped_name_salary) # если попытаемся вызвать саму переменную, то получим адрес объекта ###
### для того чтобы работать дальше с этой переменной, нам надо указать с чем мы хотим работать ###
### print(list(zipped_name_salary)) # в данном примере указываю, что я хочу работать со списком ###
### print(dict(zipped_name_salary)) # в данном примере указываю, что я хочу работать со словарем ###
zipped_name_salary = dict(zip(name_salary, salary)) # все это дело можно сразу обернуть словарем или другим итерируемом объектом
print(zipped_name_salary['Алина'], '- зарплата Алины') # вызываем переменную, которая уже является словарем.
# используем ключ, чтобы получиться значение

a = [True, False, False]
# Функция any() проверяет объект, его содержимое, то есть пробегает по элементам.
# При условии, что хотя бы один из элементов внутри объекта будет True, функция вернёт нам True,
# в противном случае вернёт False.
'''any - любой'''
print(any(a))
a = [False, False, False]
print(any(a))
# Если смотреть на числа, например, с точки зрения логических значений, то любые числа, кроме 0, будут давать True.
a = [1, 0, 0]
print(any(a))
# Если будут все нули, то и в ответе получим False
a = [0, 0, 0]
print(any(a))
# На строки мы смотрим с точки зрения наличия в ней символов. Если строка пустая, тогда False
# При наличии в строке хотя бы одного элемента, получим True
b = ''
print(any(b))
b = 'slovo'
print(any(b))
# функции all(), если все элементы True получаем True. Если хотя бы один элемент False - получаем False.
'''all - все'''
# Если хотя бы один элемент False - получаем False
a = [1, 1, 0]
print(all(a))
# Если все элементы True получаем True
a = [1, 1, 1]
print(all(a))

'''Интроспекция — это способность какого-либо объекта получить информацию об атрибутах и методах в процесс выполнения программы.'''

# Функция dir() возвращает список атрибутов и методов объекта.
# Если аргументом является объект, dir() выведет все доступные атрибуты и методы этого объекта.
# Если аргументом является модуль, dir() вернет список его функций, классов и переменных.
# Пример:
# dir(a) выведет список методов и атрибутов объекта 'a', в данном случае это список.
'''dir - справочник или список атрибутов'''
print(dir(a))  # Выведет список атрибутов и методов объекта 'a' (например, методы list)

# Функция isinstance() - используется для проверки принадлежности объекта к определенному классу или типу данных.
# Она принимает два аргумента: объект, который нужно проверить, и класс или тип данных,
# к которому нужно проверить принадлежность.
## isinstance - (объект, тип данных) ## isinstance - (объект, (тип данных, тип данных, и т.д))
# Она возвращает True- Истина, если объект принадлежит классу, иначе False - Ложь.
'''isinstance - относится экземпляр, этот экземпляр, это экземпляр, этот пример'''
print(isinstance(b, str)) # выводим в консоль относится ли переменная b к классу str-строка
## Аналогичного результата можно добиться, если проверить через type равняется
print(type(b) == str) # тип переменной b равняется к классу str-строка
a = [1, 2, 3]
b = [1, 2, 3]
# Оператор «==» сравнивает значения объектов:
print(a == b) # равняется ли a и b
# Однако оператор «is»(является) проверяет идентичность объектов
print(a is b)
# Функция id() возвращает уникальный идентификатор для указанного объекта, то есть его адрес в памяти
'''id - идентификатор'''
print(id(a))
print(id(b))
c = b
print(b)
print(c)
print(id(b))
print(id(c))
# Однако оператор «is»(является) проверяет идентичность объектов
print(c is b)
# функцией Help() - если вы, допустим, забыли или нуждаетесь в помощи.
'''help - помощь'''
print(help(print))
# pass в Python — это особый оператор заглушки, который не выполняет никаких действий.
# Он находит свое применение в тех местах, где синтаксис языка требует наличие блока кода,
# но вы ещё не готовы прописывать его логику.'''
'''pass - пасс, пас, пропуск'''
def herlper1():
    '''Тут должно быть объяснение'''
    pass
'''В исходном коде Python строки документации заключаются в тройные кавычки и пишутся сразу под заголовком объекта.'''
# Извлекать строки документации можно двумя способами:
# Через встроенный для каждого объекта атрибут-переменную __doc__.
# С помощью встроенной в Python функции help, которая запускает интерактивную справочную систему.
print(herlper1.__doc__)
print(help(herlper1))

# Максимум в списке
def find_max(list_):
    max_ = list_[0]
    for i in list_:
        if i > max_:
            max_ = i
    return max_

print(find_max([20, 52, 12, 101, 15, -1, -88, 100]))

# Подсчёт четных чисел в списке
def count_even(list_):
    counter = 0
    list_kolvo =[]
    for i in list_:
        if i == 0:
            continue
        elif i % 2 == 0:
            counter += 1
            list_kolvo.append(i)
    print(list_kolvo)
    return counter

print(count_even([2, 2, 3, 4, 2, 1, 0]))

# Уникальный список
def unique(list_):
    new_list = []
    for i in list_:
        if i not in new_list: # если(if) не(not) в(in) списке(new_list)
            new_list.append(i)# то переменную i добавляем в список
    return new_list

print(unique([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]))

# DZ GPT
# Минимум в списке
def find_min(list_):
    min_ = list_[0]
    for i in list_:
        if i < min_:
            min_ = i
    return min_

print(find_min([20, 52, 12, 101, 15, -1, -88, 100]))

#Подсчёт нечётных чисел
def count_odd(list_):
    counter = 0
    for i in list_:
        if i == 0:
            continue
        if i % 2 != 0:
            counter += 1
    return counter

print(count_odd([2, 2, 3, 4, 2, 1, 0]))

# Уникальные числа (но в отсортированном порядке)
def unique_sorted(list_):
    new_unique = []
    for i in list_:
        if i not in new_unique:
            new_unique.append(i)
    new_unique.sort()
    return new_unique

print(unique_sorted([1, 5, 3, 1, 7, 2, 4, 5, 3, 2]))

#Сумма положительных чисел
def sum_positive(list_):
    sum_positive = 0
    for i in list_:
        if i > 0:
            sum_positive += i
    return sum_positive


print(sum_positive([-5, 10, 0, -3, 8, -2]))

#Числа больше среднего значения
def above_average(list_):
    new_above_average =[]
    list_1 = sum(list_)
    average = list_1 / len(list_)
    for i in list_:
        if i > average:
            new_above_average.append(i)
    return new_above_average

print(above_average([1, 2, 3, 4, 5, 6]))

#Удалить все отрицательные числа
def remove_negatives(list_):
    no_negatives = []
    for i in list_:
        if i >= 0:
            no_negatives.append(i)
    return no_negatives

print(remove_negatives([-5, 10, 0, -3, 8, -2]))

# Найти индексы чётных чисел
'''Не смог сам решить'''
def even_indices(list_):
    indices_ = []
    for i in range(len(list_)):  # Перебираем индексы списка
        if list_[i] % 2 == 0:  # Проверяем, чётное ли число на текущем индексе
            indices_.append(i)  # Добавляем индекс в результирующий список
    return indices_

print(even_indices([1, 2, 3, 4, 5, 6]))

#Умножить все элементы списка на заданное число
def multiply_list(list_, factor):
    multiply =[]
    for i in list_:
        k = factor * i
        multiply.append(k)
    return multiply

print(multiply_list([1, 2, 3], 3))

#Найти все элементы, которые встречаются более одного раза
'''Не смог сам решить'''
def find_duplicates(list_):
    duplicates_list = []
    seen = set()  # Для отслеживания уже встреченных элементов
    for i in list_:
        if i in seen and i not in duplicates_list:  # Если элемент уже был, но еще не добавлен в результат
            duplicates_list.append(i)
        else:
            seen.add(i)  # Запоминаем, что элемент встретился
    return duplicates_list

print(find_duplicates([1, 2, 3, 4, 5, 2, 4, 6, 7, 4, 8]))

#Перевёрнутый список
def reverse_list(list_):
    revers = []
    for i in list_:
        revers.append(i)
    revers = sorted(revers, reverse = True) # функция сортет
    return revers

#Синтаксис функции sorted():
# sorted(iterable, key=None, reverse=False)
# где:
## iterable: обязательный параметр, представляющий итерируемый объект или встроенную последовательность,
# элементы которого требуется отсортировать.
## key: необязательный параметр, представляющий функцию, которая определяет ключ сортировки.
# По умолчанию None, что означает сортировку по значениям элементов.
## reverse: необязательный параметр, определяющий порядок сортировки.
# Если - reverse=True, то сортировка будет производиться в обратном порядке (от большего к меньшему),
# а если reverse=False (по умолчанию), то сортировка будет производиться в прямом порядке (от меньшего к большему).

print(reverse_list([1, 2, 3, 4, 5]))

print(not [])
print(not [1, 2, 3])

# DZ 18
data_structure = [
    [1, 2, 3],
    {'a': 4, 'b': 5},
    (6, {'cube': 7, 'drum': 8}),
    "Hello",
    ((), [{(2, 'Urban', ('Urban2', 35))}])
]
def calculated_structure(data): # создаем функцию с позиционным аргументом
    total_sum = 0
    if isinstance(data, (int, float)): # если этот экземпляр(isinstance, объект, (тип данных, если их несколько-то в скобки)-True-Истина
        total_sum += data # то в переменную тоталсум прибавляем это значение и сохраняем
    elif isinstance(data, str): # иначе если этот экземпляр(isinstance, объект, строка)- True-Истина
        total_sum += len(data) # то в переменную тоталсум прибавляем и сохраняем длину строки
    elif isinstance(data,(list, set, tuple)): # иначе если этот экземпляр(isinstance, объект, (тип данных, тип данных) True-Истина
        for element in data: # цикл для elementa в data
            total_sum += calculated_structure(element) # рекурсивный вызов функции (в начале где иф)
    elif isinstance(data, dict): # иначе если этот экземпляр(isinstance, объект, (тип данных, тип данных)
        for key, value in data.items(): # цикл для словаря. так как в словаре два аргумента, то и временных переменной тоже две
                                        # метод .item позволяет получить ключ и значение
            total_sum += calculated_structure(key) # рекурсивный вызов функции для ключа (в начале где иф)
            total_sum += calculated_structure(value) # рекурсивный вызов функции для значения (в начале где иф)
    return total_sum # возвращаем в ответ total_sum

result = calculated_structure(data_structure) # переменная в которой функция и ее аргумент
print(result)

'''ЛОГИКА NOT(не)'''
mem = 'slovo'
if 's' in mem:
    print('s есть')
    # если буква С в слове
    # есть,правда
if 'b' in mem:
    print('s есть')
    # если буква Б в слове
    # нет, ложь
if 'k' not in mem:
    print('нет элемента k')
    # если буквы К нет в слове
    # нет, правда
if 's' not in mem:
    print('нет элемента s')
    # если буквы С нет в слове
    # есть, ложь

# Пояснение оператора not:
# Каждый not в коде инвертирует булево значение выражения:
# Если выражение внутри not истинно (True), not делает его ложным (False).
# Если выражение внутри not ложно (False), not делает его истинным (True).
#-------------------------
num = -5
if not num >= 0:
    print('число меньше или равно нулю,то оно отрицательное')
    # если число не меньше и равно нулю
if num >= 0:
    print('число больше нуля')
    # если число больше, равно нул.


# Существует два вида импорта:
# 1. Абсолютный импорт
# Используется, чтобы явно указать полный путь к модулю, начиная с корня проекта.
# Это наиболее надёжный и читаемый способ импорта, так как он чётко показывает, откуда берётся модуль.
# Предположим, у вас есть следующая структура проекта:
#
# project/
# ├── main.py
# ├── package1/
# │   ├── module1.py
# │   └── module2.py

# Если вы хотите импортировать module1 из module2, используйте абсолютный импорт:
# # В module2.py
# from package1 import module1

# Если вы работаете в main.py и хотите импортировать module1:
# # В main.py
# from package1 import module1

# 2. Относительный.
# Относительный импорт — это использование конструкции «from» с применением точки или двоеточия и так далее
# Относительный импорт позволяет импортировать модули относительно текущего модуля.
# . — текущая директория.
# .. — на уровень выше.
# ... — на два уровня выше и так далее.

# С той же структурой проекта:
# Если вы хотите импортировать module1 из module2, используя относительный импорт:
# В module2.py
# from . import module1  # Импорт из текущей директории (package1)

# Если вы хотите импортировать module1 из другой вложенной папки:
# from ..package1 import module1  # Поднимаемся на уровень выше и импортируем module1

##### module4
# import module4_1 as m4_1 # импортируем модуль4_1 as(как) название, которе будет использоваться в будущем, при обращенье к модулю;-1
# # чтобы использовать функции, класса, переменные без префикса module4_1/m4_1
# from module4_1 import say_hello as sh #from(из) (объект) import (что импортируем/вытаскиваем) так же можно дать сокращенное название
#                           # после импорта можно указать *, что укажет на то, что мы хотим импортировать все
# '''В начале выполнения программы мы видим сообщение «Привет», потому что интерпретатор сначала импортирует второй модуль.
# Перед тем как завершить импорт, он считывает всю информацию из модуля, обрабатывает создание функций и переменных, и,
# ###конечно же, выполняет команду «#print»###. Это поведение сохраняется независимо от способа импорта:
# даже если мы импортируем только один элемент, например, переменную «a» из «module2»,
# интерпретатор всё равно выполнит весь код модуля при запуске. Мы по-прежнему видим сообщение «Привет»,
# поскольку соответствующая функция была выполнена.'''
# print(dir(m4_1)) # # Функция dir(). Эта функция позволяет получить информацию об атрибутах объекта
#
# print('Привет, здесь мы изучаем Модули и Пакеты, в данном уроке ты находишься на 4 модуле')
#
# # print(m4_1.a) # обращаемся к модулю4_1 через точку вызываем функцию или переменную из него
# # m4_1.say_hello()
# # say_hello()
#
# print(m4_1.__name__)

##### module4_1
# def say_hello():
#     print('Привет я из функции в 4 модуле')
#     return 'Ты использовал функцию из файла модуль4_1'
#
# def main():
#     a = 50
#     b = 100
#     print('Эээ')
#     print('123')
#
# if __name__ == '__main__':
#     main()
# #Когда файл запускается как основная программа, его __name__ становится '__main__'.
# #Когда файл импортируется как модуль, его __name__ будет содержать имя файла без расширения .py (например, 'myfile').
# #__name__ — это переменная, которая всегда содержит имя модуля (или '__main__', если это основной файл).
# #__main__ — это просто строка, которая означает, что файл был запущен как основной скрипт.
# ### ИТОГ ###
# #__name__ хранит имя текущего модуля. Когда файл запускается напрямую, его __name__ равно '__main__'.
# #__main__ — это специальное значение, которое используется для проверки, был ли файл запущен напрямую или импортирован.
# print(__name__)

#from modules import module4_1
##(from)из modules(тут указана папка) (import)импорт файл - здесь импорт всего файла
##(from)из modules(тут указана папка).файл (import)импорт (что импортируем(название функции и тд))
# from modules.module4_1 import say_hello as sh

# Так же если пакет содержит в себе модули, то лучше всего импортировать их через from(из) (пакет) импорт (модуль, модуль)

# DZ 19
from true_math import divide as tmd # из(from) модуля import (что импортируем) как(as) название к которому будем обращаться
from fake_math import divide as fmd # из(from) модуля import (что импортируем) как(as) название к которому будем обращаться

result1 = fmd(69, 3)
result2 = fmd(3, 0)
result3 = tmd(49, 7)
result4 = tmd(15, 0)

print(result1)
print(result2)
print(result3)
print(result4)

#CODEWARS 1
def likes(names):
    if not names:  # если не names, если names пуста
        return f"no one likes this"  # то возвращаем no one likes this
    elif len(
            names) == 1:  # если длина списка равняется 1, когда мы используем команду len для списка она показывает кол-во элементов в списке,
                          # а при указании индекса кол-во символов в элементе
        return f"{names[0]} likes this"  # выводим names с индексом 0, то есть первое имя, так как подсчет начинается с нуля, префикс f
    elif len(
            names) == 2:  # если длина списка равняется 2, когда мы используем команду len для списка она показывает кол-во элементов в списке
        return f"{names[0]} and {names[1]} like this"
    elif len(names) == 3:
        return names[0] + ', ' + names[1] + ' and ' + names[2] + ' like this' # вывод без префикса f
    elif len(names) >= 4:  #
        return f"{names[0]}, {names[1]} and {len(names) - 2} others like this"  # выводим names с индексом 0, names с индексом 1 и
                            # кол-во элементов{len(в списке) - 2} вычитаем 2 из кол-во элементов в списке так как уже указали двоих

print(likes([]))
print(likes(['Peter']))
print(likes(['Jacob', 'Alex']))
print(likes(['Max', 'John', 'Mark']))
print(likes(['Alex', 'Jacob', 'Mark', 'Max']))
print(likes(['Alex', 'Jacob', 'Mark', 'Max', 'Peter', 'Pacob', 'Jacob', 'Mark', 'Max', 'Peter', 'Pacob']))

#from modules import module4_1
##(from)из modules(тут указана папка) (import)импорт файл - здесь импорт всего файла

##(from)из modules(тут указана папка).файл (import)импорт (что импортируем(название функции и тд)) as(как) - принимает название функции/или модуля, когда мы будем к ней обращаться
# from modules.module4_1 import say_hello as sh

##### Пакет — это директория, которая по сути такая же, как и наша "modules".
##### Единственным отличием пакета от обычной папки является наличие внутри файла "__init__.py" с двойным подчеркиванием.
##### Когда мы создали файл "__init__.py", мы заметили, что на изображении нашей папки "modules" появился кружочек.
##### Этот кружочек обозначает, что наш модуль, или наша папка, теперь стала пакетом.

# Существует особенность: когда мы импортируем пакет или взаимодействуем с ним, код из файла "__init__.py" с двойным подчеркиванием
# начинает выполняться. Это происходит аналогично тому, как происходит выполнение кода при импорте какого-либо модуля,
# где вся информация из модуля считывается и выполняется. В случае с файлом "__init__.py" также считывается и выполняется код,
# содержащийся в этом файле.



import modules

print(modules)

# Размещение файла main.py внутри пакета допустимо, но это не всегда является лучшим подходом.
# Давайте разберём плюсы и минусы этого решения, чтобы понять, правильно ли вы сделали.
#
# Плюсы размещения main.py внутри пакета
# Компактность проекта:
#
# Если ваш проект небольшой, а логика программы тесно связана с этим пакетом, то хранение main.py внутри него удобно.
# Например, если весь проект связан только с package1, то main.py в его корне логично объединяет весь код.
# Локализация кода:
#
# Если вы планируете, что main.py используется только в контексте этого пакета (и не предполагается его вызов извне),
# то такое расположение может быть оправдано.


# Минусы размещения main.py внутри пакета
# Нарушение модульности:
#
# Обычно main.py используется как точка входа для всей программы. Его место, как правило, за пределами пакетов,
# чтобы он мог обращаться ко всем модулям и пакетам проекта.
#
# Например:
# project/
# ├── package1/
# │   ├── package2/
# │   │   ├── package3/
# │   │   │   ├── __init__.py
# │   │   │   ├── module2.py
# │   │   ├── __init__.py
# │   ├── __init__.py
# ├── main.py
# Такое расположение позволяет отделить основной запускной файл от реализации логики внутри пакетов.
#
# Сложность импорта:
# Если main.py находится внутри пакета, вам придётся работать с относительными импортами внутри пакета.
# Это может усложнить поддержку проекта, особенно если вы решите переместить точку входа позже.
# При расположении main.py вне пакета, вы можете использовать абсолютные импорты
# (например, from package1.package2.module import ...), что считается более читабельным и удобным.
#
# Неудобство масштабирования:
# Если проект будет расти, вам, возможно, потребуется добавлять другие модули и пакеты на одном уровне с package1.
# В таком случае, файл main.py внутри одного пакета уже не будет интуитивно подходить как общая точка входа.




# Если ваш проект небольшой и состоит из одного основного пакета, оставлять main.py внутри пакета — допустимо.
# Однако в профессиональной разработке чаще применяют следующую структуру:
#
# project/
# ├── package1/
# │   ├── package2/
# │   │   ├── package3/
# │   │   │   ├── __init__.py
# │   │   │   ├── module2.py
# │   │   ├── __init__.py
# │   ├── __init__.py
# ├── main.py
#
# Преимущества:
# Файл main.py является точкой входа для всей программы.
# Все пакеты и модули остаются отдельно, поддерживая модульность.
# Если проект вырастет, вам будет проще добавлять другие модули, например:
#
# project/
# ├── package1/
# ├── package2/
# ├── utilities/
# ├── main.py


# Метод .isdigit() возвращает True, если все символы в строке являются цифрами. Если нет, возвращается False.
# isdigit = is(является)digit(цифрой) - является цифрой

#CODEWARS 2
# Задача, даются PIN коды разной длины, надо сделать так, чтобы PIN код из 4 или 6 символов выдавало тру
# Остальное False. При этом надо учесть, чтобы True выдавало только когда в наборе цифры.
# Если 4 или 6 символов, но в них есть другие символы кроме цифр, то False
def validate_pin(pin):
    pin = str(pin.lower()) # преобразуем элементы в строку и в нижний регистр
    if "-" in pin or "+" in pin: # если 'символ' в pin(переменной) или если 'символ' в pin(переменной)
        return False # то возвращаем False
    if pin.isdigit() is True: # если pin.isdigit (is-является digit-цифрой) является True
        # Метод .isdigit() возвращает True, если все символы в строке являются цифрами. Если нет, возвращается False.
        if len(pin) == 4 or len(pin) == 6: # то если длина(len) pin == 4 или(or) длина(len) pin == 6
            return True # то возвращаем True
        else: # иначе
            return False # возвращаем False
    if pin.isdigit() is False: # если pin.isdigit (is-является digit-цифрой) является False
        return False # возвращаем False

print(validate_pin(22+3))
print(validate_pin(1234123))
print(validate_pin(123456))
print(validate_pin(-123))

#CODEWARS 3 (Почти решил сам)
def to_jaden_case(string):
    # Разбиваем строку на слова и приводим каждое слово к формату с заглавной буквой
    st = ' '.join(word.capitalize() for word in string.split()) # пока не очень разобрался с этими методами.
    return st

result = to_jaden_case("How can mirrors be real if our eyes aren't real")
print(result)

#CODEWAR 4(Не решил)
# Задача, даются элементы, при вводе которых требуется на выходе заменить символы на #, а остальные 4 оставить открытые.
def maskify(cc):
    if len(cc) <= 4:
        return cc
    # Если длина строки больше 4 символов:
    # 1. Вычисляем количество символов, которые нужно заменить на `#`:
    # Это `len(cc) - 4` — длина строки минус 4 символа, которые остаются неизменными.
    # 2. Создаём строку из символов `#` такой длины: `"#" * (len(cc) - 4)`.
    # 3. Берём последние 4 символа строки с помощью среза `cc[-4:]`.
    # 4. Складываем строку из `#` и последние 4 символа, чтобы получить маскированную строку.
    return "#" * (len(cc) - 4) + cc[-4:]

###########
import math

# from math import - если мы возьмем библиотеку «math» и импортируем все из нее, что произойдет с нашим «globals»?
# Обратите внимание, что здесь появилось огромное количество значений.


# ЗДЕСЬ ПРИМЕР ТОГО КАК ФУКНЦИЯ МОЖЕТ СЧИТЫВАТЬ ЗНАЧЕНИЕ ПЕРЕМЕННЫХ ИЗ ГЛОБАЛЬНОГО ПРОСТРАНСТВА
def square(x):
    # global a
# Сейчас «a» находится в другом пространстве имен, а не в глобальном.
    # Она находится в локальном пространстве имен, и с этим можно что-то делать.
    # Однако если мы хотим связать их, например, если мы хотим, чтобы наша функция «square» перезаписывала переменную «a»,
    # которая находится в другом пространстве имен, как это сделать внутри функции? На самом деле это очень просто.
    # Нам нужно добавить оператор «global» и указать, какие значения мы будем использовать из глобального пространства
    d = a ** 2 # По сути, функция обладает своим собственным пространством имен, которое называется локальным, и значение она будет брать из этого локального пространства.
    return d
               # Переменная d находится в локальном пространстве, то есть она существует только в функции
               # Но в глобальном пространстве, мы не можем взять значение из функции, так как оно создается только в функции.
               # Но функция может считывать значения(только чтение) из глобального пространства.

               # Если бы это происходило внутри функции, мы сначала смотрели бы на локальное пространство, потом на глобальное, и
               # только затем на встроенное. Такой порядок называется "изнутри наружу".
               # Таким образом, мы сначала обращаемся к нашему пространству имен, а затем к встроенному пространству имен.
a = 5 # БЕРЕТСЯ ЭТО ЗНАЧЕНИЕ # Переменная находится в глобальном пространстве $$$$$
# Когда мы передаем «a**2», это «a» берется из нашей основной программы.
# То есть, если внутри локального пространства имен ничего нет, мы обращаемся к другому пространству имен — глобальному.
# Этот процесс работает изнутри наружу: мы можем обращаться к глобальным переменным изнутри функции,
# но не можем извлекать значения из функции в нашу программу.

# Мы можем обращаться к глобальным переменным изнутри функции, но не можем извлекать значения из функции в нашу

# Важно не забывать, что у нас в функции есть свое собственное пространство имен.
# Если внутри функции не определено какое-то значение, мы будем пытаться найти его в других местах.
# Если значение определено, мы в первую очередь обращаемся к нему в локальном пространстве.

b = square(2)
print(a)
print(b)
# print(globals()) # Функция globals() возвращает словарь со значениями переменных, представляющий текущую глобальную область видимости модуля

# ПРИМЕР ТОГО КАК ФУНКЦИЯ ИЩЕТ ПЕРЕМЕННЫЕ - Объемлющая область видимости
# from package1.package2.module1 import * - из(from) (папка.папка.модуль) импорт(import) * - звездочка означает импорт всего модуля
d = 4 # нашла бы она ее, если бы ее здесь не было, а вверху у нас был бы импорт модуля
      # то функция начала бы искать d уже в модуле, в модуле она равна 11
def square1(x):
    d = x ** 2
    def even(x):
        nonlocal d # Указываем, что будем перезаписывать переменную d из внешней функции square1
        d = x / 2
        if d % 2 == 0: # в функции even проверка d % 2, она начинает искать значение d изнутри наружу, находит d в функции square1
                       # если бы переменной d не было в функции square1, она бы начала искать в глобальном пространстве
            print('Число четное')
        else:
            print('Число нечетное')
    even(x)
    return d
    # global - Если мы хотим использовать значение из глобального пространства имен в локальном, мы применяем команду «global».

# Вызов locals() внутри функции возвращает словарь с локальными переменными
# На уровне модуля: изменения словаря locals() могут влиять на глобальные переменные, так как он совпадает с globals().
# # На уровне модуля
# x = 5
# locals()['x'] = 10
# print(x)  # Вывод: 10

### области видимости - обычно с конца ###
# Встроенная
# Глобальная
# Объемлющая
# Локальная

b = square1(4)
print(b)

def public_function():
    return "I'm a public function."


def _private_function():
    return "I'm a private function."

__all__ = ['public_function']

# В этом примере __all__ — это список, который содержит имена всех объектов, доступных для импорта при использовании
# конструкции from (моймодуль) import *. В данном случае, если где-то в коде написать from (моймодуль) import *,
# будет импортирована только функция public_function, в то время как _private_function останется недоступной.
#
# Таким образом, __all__ определяет интерфейс модуля, который виден при импорте *.
# Это особенно полезно, когда нужно сделать некоторые функции или классы «приватными» или внутренними для модуля,
# чтобы они не могли быть использованы вне его.
#
# Важно отметить, что __all__ влияет только на поведение импорта *.
# Если импортировать объекты напрямую, например, from (моймодуль) import _private_function, то __all__ будет проигнорирован.

#CODEWAR 5
#Просто, учитывая строку слов, верните длину самого короткого слова (слов).
def find_short(s):
    short = len(s) # переменная содержит кол-во символов в аргументе
    for i in s.split(): # цикл i в s.split() в i будет временно помещаться одно слово
        p = len(i) # переменная p содержит в себе кол-во символов в i
        if p < short: # если p меньше short
            short = p # то short равняется p
    return short # возвращаем short

print(find_short('bitcoin take over the world maybe who knows perhaps'))

# DZ 20
def test_function():
    def inner_function():
        print('Я в области видимости функции test_function')
    inner_function()


test_function()
# inner_function() # ошибка такое имя не определено

nums = [5, 1 ,3, 8, 7, 0]

# Этот метод я больше всех понял(ну почти, но принцип понимаю и код тоже)
def bubble_sort(ls): # Сортировка пузырьком
    swapped = True  # Флаг, который показывает, происходили ли обмены элементов в этом проходе.
    while swapped:
        swapped = False  # Сбрасываем флаг, предполагая, что обменов больше не будет.
        for i in range(len(ls) - 1):  # Проходим по всем элементам списка (кроме последнего).
            if ls[i] > ls[i+1]:  # Если текущий элемент больше следующего: # работаем со списками #
                ls[i], ls[i + 1] = ls[i + 1], ls[i]  # Меняем их местами.
                swapped = True  # Устанавливаем флаг, чтобы показать, что произошёл обмен.

bubble_sort(nums)
print(nums)

nums_1 = [5, 1, 3, 8, 7, 2]

def selection_sort(ls): # Сортировка выбором
    for i in range(len(ls)):  # Проходим по всем элементам списка.
        lowest = i  # Предполагаем, что текущий элемент (ls[i]) — минимальный.
        for j in range(i + 1, len(ls)):  # Ищем минимальный элемент в оставшейся части списка.
            if ls[j] < ls[lowest]:  # Если нашли элемент меньше текущего минимального:
                lowest = j  # Запоминаем индекс этого элемента.
        ls[i], ls[lowest] = ls[lowest], ls[i]  # Меняем местами текущий элемент с минимальным.

selection_sort(nums_1)
print(nums_1)

nums_2 = [9, 3, 1, 7, 4, 2]

def insertion_sort(ls): # Сортировка вставкой
    for i in range(len(ls)):  # Начинаем с первого элемента, двигаемся вправо
        j = i - 1  # Инициализируем j, чтобы начинать проверку с элемента перед текущим
        key = ls[i]  # Текущий элемент, который нужно вставить на правильное место
        while ls[j] > key and j >= 0:  # Пока элементы слева больше, сдвигаем их
            ls[j + 1] = ls[j]  # Сдвигаем элементы вправо
            j -= 1  # Переходим к следующему элементу слева
        ls[j + 1] = key  # Вставляем текущий элемент на его правильное место

insertion_sort(nums_2)
print(nums_2)

# from sortfunc_test.sortfunc import *

data_1 = list(map(int, input('Введите числа через пробел: ').split())) # 1 2 3 4 5

# Функция map() используется для применения функции к каждому элементу итерируемого объекта (например, списка или словаря)
# и возврата нового итератора для получения результатов.
# map(function, iterable)
# function — это функция, которую мы хотим применить. Она может быть как заранее определённой, так и анонимной (с использованием lambda).
# iterable — это итерируемый объект, к каждому элементу которого будет применяться функция.
# Если вы хотите получить результат в виде списка, вы должны явно преобразовать объект map в список с помощью функции list().
# Функция list() берёт любой итерируемый объект (например, результат map()) и создаёт из него список.


data_2 = list(map(int, input('Введите числа через пробел: ').split())) # 1 2 3 4 5
data_3 = list(map(int, input('Введите числа через пробел: ').split())) # 1 2 3 4 5

bubble_sort(data_1)
selection_sort(data_2)
insertion_sort(data_3)

print('Пузырьковая сортировка:', data_1)
print('Сортировка выбором:', data_2)
print('Сортировка вставкой:', data_3)

nums = [1, 2, 3, 4, 5]
squared = map(lambda x: x**2, nums)  # Применяем функцию x**2 к каждому элементу
print(list(squared))  # Преобразуем результат в список
# Вывод: [1, 4, 9, 16, 25]

words = ["hello", "world", "python"]
uppercased = list(map(str.upper, words))  # Применяем метод upper() к каждой строке
print(uppercased)
# Вывод: ['HELLO', 'WORLD', 'PYTHON']

# Генератор списка (или list comprehension) — это удобный и компактный способ создания новых списков в Python.
# [выражение for элемент in итерируемый_объект if условие]
# выражение — это операция или функция, которая применяется к каждому элементу.
# for элемент in итерируемый_объект — цикл, который перебирает элементы итерируемого объекта.
# if условие (необязательно) — фильтр, который определяет, включать элемент в итоговый список или нет.

nums = [1, 2, 3, 4, 5]
squared = [x**2 for x in nums]
print(squared)
# Вывод: [1, 4, 9, 16, 25]

nums = [1, 2, 3, 4, 5, 6]
even_nums = [x for x in nums if x % 2 == 0]
print(even_nums)
# Вывод: [2, 4, 6]

words = ["hello", "world", "python"]
uppercased = [word.upper() for word in words]
print(uppercased)
# Вывод: ['HELLO', 'WORLD', 'PYTHON']

# ЛЯМБДА
# lambda — это ключевое слово в Python, которое используется для создания анонимных функций (функций без имени)
# lambda аргументы: выражение
# lambda — ключевое слово, создающее функцию.
# аргументы — список аргументов, которые принимает функция (как в обычной функции).
# выражение — единственное выражение, которое вычисляется и возвращается.
# lambda x, y: x + y
# lambda — ключевое слово, которое говорит Python, что вы создаете анонимную функцию.
# x, y — это параметры функции. В данном случае, функция принимает два аргумента: x и y.
# x + y — это выражение, которое вычисляется и возвращается. Lambda-функции всегда возвращают результат выражения.
# add_lambda = lambda x, y: x + y
# Создает анонимную функцию, которая принимает два аргумента x и y.
# Возвращает их сумму (x + y).
# add_lambda(3, 5)
# Присваивается переменной add_lambda, которую можно использовать как обычную функцию.


global_var = 'я глобальная переменная'
print(global_var)


def local_func():
    # global global_var
    local_var = 'я локальная переменная'
    print(f'внутри функции {local_var}')
    print(f'внутри функция {global_var}')


def local_func1():
    global global_var
    global_var = 135623465
    print(global_var)
    local_var = 'я локальная переменная'
    print(f'внутри функции {local_var}')
    print(f'внутри функция {global_var}')

local_func()
local_func1()

try:
    print(local_var)
    # except:
    print('Ошибочка')
except NameError as e:
    print(f'Ошибочка {e}')


def outer_func():
    outer_var = 'Я переменная внешней функции'

    def inner_funk():
        inner_var = 'я переменная внутренней функции'
        print(f'Внутри внутренней функции {inner_var}')
        print(f'Внутри внутренней функции {outer_var}')

    inner_funk()
    print(f'Внутри внешней функции {outer_var}')

outer_func()


def outer_func_nonlocal():
    outer_var = 'Я переменная внешней функции1'

    def inner_funk_nonlocal():
        # nonlocal outer_var
        outer_var = 'Я измененная переменная внешней функции2'
        print(f'Внутри внутренней функции {outer_var}')

    inner_funk_nonlocal()
    print(f'Внутри внешней функции {outer_var}')

outer_func_nonlocal()

# try и except — это ключевые слова в Python, которые используются для обработки ошибок (исключений)
# try:
#     Код, который может вызвать исключение
# except ExceptionType:
#     Код, который выполняется, если произошло исключение указанного типа

## Простая обработка ошибки
# try:
#     num = int(input("Введите число: "))
#     print("Вы ввели:", num)
# except ValueError:
#     print("Это не число!")
# В блоке try выполняется код, который может вызвать ошибку.
# Если ошибка ValueError возникает (например, пользователь ввел текст вместо числа), выполняется блок except.

# Как это работает?
# try: Программа пытается выполнить код в этом блоке.
# except: Если во время выполнения блока try возникает ошибка (исключение), программа переходит к соответствующему блоку except.
# Если ошибок нет, блок except пропускается.

## Обработка нескольких типов ошибок
# try:
#     x = int(input("Введите число: "))
#     result = 10 / x
# except ValueError:
#     print("Ошибка: вы ввели не число.")
# except ZeroDivisionError:
#     print("Ошибка: деление на ноль невозможно.")
# Если пользователь вводит текст, сработает ValueError.
# Если пользователь вводит 0, сработает ZeroDivisionError.

## Общий except для всех ошибок
# Если не указывать тип ошибки, except поймает любое исключение:
# try:
#     x = int(input("Введите число: "))
#     result = 10 / x
# except:
#     print("Произошла ошибка!")

## Расширенный синтаксис
### ''else: Код, который выполняется, если ошибок не было.''
# try:
#     x = int(input("Введите число: "))
# except ValueError:
#     print("Ошибка!")
# else:
#     print("Всё прошло успешно!")
#
### ''finally: Код, который выполняется всегда (независимо от того, произошла ошибка или нет).''
# try:
#     x = int(input("Введите число: "))
# except ValueError:
#     print("Ошибка!")
# finally:
#     print("Программа завершена.")

##Полный блок
# try:
#     x = int(input("Введите число: "))
#     result = 10 / x
# except ValueError:
#     print("Ошибка: введено не число.")
# except ZeroDivisionError:
#     print("Ошибка: деление на ноль.")
# else:
#     print("Результат:", result)
# finally:
#     print("Выполнение завершено.")

# Краткий итог
# try — блок для кода, который может вызвать исключение.
# except — блок для обработки ошибок.
# else — выполняется, если ошибок не было.
# finally — выполняется всегда.

#CODEWAR 6 (Относительно сам решил)
# Вводятся число, которое потом показывает привычное нам время hh:mm:ss
def make_readable(seconds):
    seconds = int(seconds) # перевод строки в integer - число
    hh = seconds // 3600 # расчет часа- Здесь мы берём целую часть от деления секунд на 3600, что даёт количество часов.
    mm = (seconds % 3600) // 60 # расчет минут - Сначала берём остаток от деления секунд на 3600 (seconds % 3600), чтобы исключить часы. Затем делим этот остаток на 60, чтобы получить количество минут.
    ss = seconds % 60 # расчет секунд - Остаток от деления секунд на 60 даёт оставшиеся секунды.
    return f'{hh:02}:{mm:02}:{ss:02}' # # f-строка автоматически преобразует значения в строку. ':02' задаёт формат с двумя символами, дополняя недостающие нулями.

# : указывает, что начинается спецификатор формата.
# 02 означает, что длина значения будет не менее двух символов, а недостающие символы слева заполняются нулями.

'''Форматирование с помощью f-строк (f-strings)
Синтаксис:
f"{variable:format_spec}"
variable — переменная или выражение, значение которой нужно вставить.
format_spec — это спецификатор формата, который указывает, как отобразить значение.'''

# Спецификаторы формата:
# Спецификатор	            Описание	                         Пример
# :02	                    Дополнить до 2 символов с нулями	 5 → 05
# :03	                    Дополнить до 3 символов с нулями	 7 → 007
# .2f	                    Число с плавающей точкой, 2 знака	 3.14159 → 3.14
# >	                        Выравнивание вправо	                 "abc" → " abc"
# <	                        Выравнивание влево	                 "abc" → "abc "
# ^	                        Центрирование	                     "abc" → " abc "
# ,	                        Разделение числа запятыми	         1000000 → 1,000,000
# b	                        Двоичное представление	             5 → 101
# x	                        Шестнадцатеричное представление	     255 → ff

print(make_readable(3999))

#CODEWAR 7 (Сам решил)
#Учитывая массив целых чисел, верните новый массив, в котором каждое значение удвоено.
def maps(a):
    a_1 = [z * 2 for z in a] # новый список в нем генератор списка - с выражением z*2 цикл для(for) z in(в) списке(a)
    # Генератор списка: перебираем каждый элемент `z` из списка `a` и добавляем в новый список результат умножения `z` на 2.

    # В выражении[z * 2for z in a], временная переменная z:
    # Представляет текущий элемент списка a на каждой итерации цикла for
    # Используется в выражении z * 2, которое выполняется для каждого элемента
    return a_1

print(maps([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))


# key — это дополнительный параметр, который можно передать в функции, такие как max, min, sorted, и некоторые другие.
# Параметр key используется в:
# max(iterable, key=...) — находит максимальный элемент по указанному ключу.
# min(iterable, key=...) — находит минимальный элемент по указанному ключу.
# sorted(iterable, key=...) — сортирует элементы по указанному ключу.
# sorted(iterable, key=...) — сортирует элементы по указанному ключу.
# list.sort(key=...) — сортирует список "на месте".
#
# Синтаксис:
# max(iterable, key=function)
# min(iterable, key=function)
# sorted(iterable, key=function)
# пишем что находим, где находим, по какому ключу
#
# Примеры использования
# 1. max(iterable, key=function)
# Что находим? Максимальный элемент.
# Где находим? В переданном итерируемом объекте (iterable).
# По какому ключу? Ключ определяется функцией function, которая применяется к каждому элементу, чтобы вычислить "значение для сравнения".
# Пример:
words = ["apple", "banana", "cherry"]
longest_word = max(words, key=len)
print(longest_word)  # 'banana'
# Что находим? Самое длинное слово.
# Где находим? В списке words.
# По какому ключу? По длине каждого слова (функция len).

'''КЛАССЫ'''
# Объектно-ориентированное программирование (ООП) основывается на трёх ключевых принципах:
# 1) Наследование — этот принцип позволяет создавать новые классы на основе существующих,
# что даёт возможность расширять и изменять поведение базового класса, делая производные классы более уникальными.
# 2) Инкапсуляция — позволяет скрывать внутренние детали реализации класса от пользователей,
# предоставляя доступ только к необходимым элементам. Это способствует более безопасной работе и предотвращает случайные ошибки.
# 3) Полиморфизм — позволяет использовать объекты разных классов через единый интерфейс,
# что упрощает взаимодействие с ними и делает код более гибким.
'''Дополнительное объяснение:'''

# Что такое класс?
# Класс — это конструкция, которая описывает структуру и поведение объектов. Он содержит:

# Атрибуты — данные или свойства объекта (например, name).
# Методы — функции, которые определяют поведение объекта.
# Что такое объект?
# Объект (или экземпляр класса) — это конкретный "представитель" класса с уникальным набором атрибутов. В данном примере Ilya и Alina — это два разных объекта класса Human.

# Что делает __init__?
# __init__ (инициализатор) автоматически вызывается при создании нового объекта. Он помогает задать начальные значения атрибутов, используя аргументы, переданные при создании объекта.

# Почему используется self?

# self — это ссылка на текущий объект, который создаётся.
# Все атрибуты и методы объекта доступны через self.
# В инициализаторе self.name = name означает: "Создать атрибут name у текущего объекта и присвоить ему значение из аргумента name."
# Для создания класса достаточно указать ключевое слово class, после которого следует название класса (с большой буквы).

# Класс можно представить как шаблон или инструкцию, на основе которой создаются объекты (экземпляры).
# Каждый объект класса обладает характеристиками (атрибутами) и может выполнять определённые действия (методы).
# Классы позволяют объединять данные (атрибуты) и логику (методы) в одной структуре.

class Human:
    # Классовый атрибут — это переменная, которая принадлежит классу, а не его отдельным экземплярам.
    # Все экземпляры этого класса имеют доступ к классовым атрибутам, и изменения в классовом атрибуте
    # повлияют на все экземпляры, которые на него ссылаются.

    ## Таким образом, классовый атрибут 'head' доступен всем экземплярам, но 'name' и 'age' являются индивидуальными атрибутами, специфичными для каждого объекта.
    ## Это удобно, когда необходимо хранить информацию, которая относится ко всем объектам, а не к отдельным экземплярам.
    head = True # Это значение доступно всем объектам, созданным на основе класса Human.
    # Классовые атрибуты могут быть изменены и это изменение будет отражаться на всех объектах, созданных на основе этого класса

    ### Это знание помогает понять, как организовать данные и методы в классах, а также различать, какие атрибуты относятся к классам, а какие — к объектам.

    """Здесь обычно идет описание класса в тройных кавычках"""
    # Инициализатор класса (__init__) — это специальный метод, который вызывается автоматически при создании нового объекта.
    # Он используется для задания начальных значений атрибутов объекта.
    def __init__(self, name, age):
        # Атрибуты экземпляра #
        # self — ссылка на текущий экземпляр объекта. Она позволяет обращаться к атрибутам и методам объекта.
        # Атрибуты name и age инициализируются при создании объекта. Они становятся уникальными характеристиками каждого объекта.
        self.name = name # Устанавливаем значение атрибута name.
        self.age = age # Устанавливаем значение атрибута age.
        self.say_info()  # Вызов метода внутри конструктора (__init__). Это позволяет автоматически выводить информацию о созданном объекте.

    # Метод объекта, который выводит информацию об объекте в формате строки.
    def say_info(self):
        # self.name и self.age относятся к текущему экземпляру класса.
        print(f'Привет, меня зовут {self.name}, мне {self.age}')

    # Метод объекта, который увеличивает значение атрибута age на 1.
    def birthday(self): # метод при котором, использовании этого метода увеличивается возраст объекта/экземпляра
        self.age += 1 # Увеличиваем значение возраста (age) текущего объекта.
        print(f'У меня день рождения, мне теперь {self.age}')

    # Методы, содержащие двойное подчеркивание, называются специальными или магическими методами.
    # Также можно встретить другое название — dunder-методы, что является сокращением от фразы "double underscore"
    # (двойное нижнее подчеркивание). На данном занятии будет представлено несколько из этих магических методов.

    # Использование метода __len__() для определения длины массива в Python.
    # Метод __len__ всегда должен возвращать int
    def __len__(self):
        return self.age

    # destruct - деструктор
    # Это может происходить либо по завершении работы интерпретатора, когда все строки кода выполнены, либо при отсутствии ссылок на объект.
    # Для удаления объекта можно воспользоваться оператором '__del__', который активирует деструктор.
    def __del__(self):
        print(f'{self.name} ушел(а), но обещал(а) вернуться')
        # можно использовать pass для заглушки

    # Переопределение метода __bool__ позволяет задавать собственные условия для проверки "истинности" объектов класса.
    # В данном случае объект считается "истинным", если значение его атрибута age больше 18.

    # Метод __bool__ вызывается автоматически, когда объект участвует в условной проверке (например, if <объект>:).
    # Возвращаемое значение — True или False:
    # - True, если age > 18.
    # - False, если age <= 18.
    def __bool__(self):
        return self.age > 18

    # В Python существуют встроенные операторы (например, +, -, >, <, ==), которые имеют стандартное поведение для базовых типов данных.
    # Например:
    # - Числа: 5 > 3 вернёт True, а 7 < 2 вернёт False.
    # - Строки: "apple" < "banana" (лексикографическое сравнение).
    #
    # Однако мы можем переопределить стандартное поведение операторов для объектов пользовательских классов.
    # Этот процесс называется **перегрузкой операторов**.
    #
    # Это позволяет определять, как операторы работают с экземплярами классов, предоставляя свою логику.

    # Перегрузка оператора "<" (меньше чем).
    # Метод '__lt__()' (Lower Than) определяет, что должно происходить при использовании оператора "<" для объектов данного класса.
    # В данном примере: два объекта будут сравниваться на основе их атрибута 'age'.
    def __lt__(self, other):
        return self.age < other.age

    # Перегрузка оператора ">" (больше чем).
    # Метод '__gt__()' (Greater Than) определяет, что должно происходить при использовании оператора ">" для объектов данного класса.
    # В данном примере: два объекта будут сравниваться на основе их атрибута 'age'
    def __gt__(self, other):
        return self.age > other.age

    # Перезагрузка оператора "==" (равно).
    # Метод '__eq__()' (Equal) определяет, что должно происходить при использовании оператора "==" для объектов данного класса.
    # В данном примере: два объекта будут сравниваться на основе их атрибутов name == name и age == age
    def __eq__(self, other):
        return self.name == other.name and self.age == other.name


# ilya — это экземпляр (объект) класса Human.
# Переменная ilya — это объект (экземпляр) класса Human, созданный на основе его шаблона.
# Класс Human — это шаблон, описывающий свойства и поведение человека (атрибуты и методы).

# Чтобы создать объект, вы вызываете класс как функцию
# Создаём объект класса Human с именем 'Илья' и возрастом 24.
ilya = Human('Илья', 24)
# Переменная ilya представляет собой экземпляр класса Human и хранит информацию о конкретном человеке.

# Можно добавить атрибут объекту после его создания, даже если он не был определён в классе.
ilya.surname = 'Нефедов'

# Создаём второй объект класса Human с именем 'Алина' и возрастом 24.
alina = Human('Алина', 24)
liza = Human('Лиза', 13)

# Выводим значения атрибутов объектов.
# Атрибут name хранит имя объекта, age — возраст, а surname был добавлен вручную для объекта ilya.
print(ilya.name, ilya.surname, ilya.age)
print(alina.name, alina.age)

# Функция hasattr() проверяет существование атрибута в указанном объекте.
# hasattr - имеет атрибут
# hasattr(object, name)
# object: Объект, у которого вы хотите проверить наличие атрибут
# name: Строка, представляющая имя атрибута, метода

if hasattr(ilya, 'surname'):
    print(f'{ilya.surname}, Проверка функции hasattr')
else:
    print("У объекта нет атрибута surname.")

# Применяем метод birthday для объекта alina, чтобы увеличить её возраст на 1.
alina.birthday()

'''del ilya # при добавлении деструктора мы можем удалять объект через оператор del'''

# Вновь выводим информацию об объектах, используя метод say_info.
ilya.say_info()
alina.say_info()

print(f'Проверка: {ilya < alina}')
print(f'Проверка: {ilya > alina}')
print(f'Проверка: {ilya == alina}')

# При проверке if <переменная>: вызывается метод __bool__() объекта, на который ссылается переменная.
# Если метод возвращает True, код внутри блока if выполняется.
# Если метод возвращает False, выполняется блок else (если он есть)

# if ilya:  # Проверяем объект ilya. Метод ilya.__bool__() возвращает True или False в зависимости от возраста.
# Если ilya.age > 18, выполнится код в блоке if.
# Если ilya.age <= 18, выполнится блок else.

if ilya:
    print(f'{ilya.name} достиг совершеннолетия')
else:
    print(f'{ilya.name} не достиг совершеннолетия')
# Поведение аналогично: if alina: и if liza: проверяют истинность объектов.
# Метод __bool__ для каждого объекта (alina, liza) вызывает соответствующий атрибут age объекта
if alina:
    print(f'{alina.name} достиг совершеннолетия')
else:
    print(f'{alina.name} не достиг совершеннолетия')
# Вывод информации о совершеннолетии каждого объекта:
# - Если объект "истинный" (возраст больше 18), выводится сообщение о достижении совершеннолетия.
# - Если объект "ложный" (возраст 18 или меньше), выводится сообщение о несовершеннолетии.
if liza:
    print(f'{liza.name} достиг совершеннолетия')
else:
    print(f'{liza.name} не достигла совершеннолетия')

# Пример использования классового атрибута:
print(Human.head)  # Обращаемся к классовому атрибуту 'head' через сам класс.

# Изменяем классовый атрибут у объекта 'ilya'. Это создаст новый атрибут, который будет локальным для этого экземпляра.
ilya.head = False

# При проверке атрибутов сначала ищем в экземпляре. Если его нет, то ищем в классе.
# Поэтому у объекта 'ilya' будет свой атрибут 'head', а у 'alina' — классовый атрибут.
print(f'Если голова у Ильи - {ilya.head}, если ли голова у Алины - {alina.head}')  # Вывод: False (у Ilya) и True (по умолчанию у Alina)
# Важно: Если атрибут объекта не был изменён, то при проверке Python обратится к классовому атрибуту.

print(Human.__mro__) # Обратившись к атрибуту 'mro()', который отображает цепочку наследования для класса


'''Class_Method_New'''


class User:
    # __instance — это атрибут класса, который хранит ссылку на единственный экземпляр класса (если он уже был создан).
    # Используется для реализации паттерна Singleton (синглтон), где допускается только один объект данного класса.
    __instance = None

    # Метод __new__ отвечает за создание нового объекта.
    # cls — это ссылка на сам класс User, аналогично self для методов экземпляра.

    # Метод __new__ используется для контроля над процессом создания объектов.
    # Применяется в паттернах Singleton, работе с неизменяемыми типами,
    # создании кэша или при необходимости управлять доступом к объектам.
    def __new__(cls, *args, **kwargs):
        print(f'Я в нью')  # Этот вывод помогает понять, что метод __new__ был вызван.

        # Проверяем, существует ли уже экземпляр класса. Если он не создан, создаём его.
        if cls.__instance is None:
            # super().__new__(cls) вызывает родительский метод __new__, который создаёт объект.
            # В данном случае super() вызывает __new__ у родительского класса object, что создаёт новый объект.
            cls.__instance = super().__new__(cls)
            # Возвращаем единственный экземпляр класса.
        return cls.__instance

        # Метод __init__ отвечает за инициализацию созданного объекта.

    # self указывает на экземпляр объекта, который был возвращён методом __new__.
    def __init__(self, *args, **kwargs):
        print(f'Я в ините')  # Этот вывод помогает понять, что метод __init__ был вызван.

        # Сохраняем позиционные аргументы в атрибуте args объекта.
        self.args = args

        # Проходимся по именованным аргументам (kwargs).
        # Для каждого ключа-значения создаём атрибут объекта с соответствующим именем.
        for key, value in kwargs.items():
            setattr(self, key, value)  # setattr динамически создаёт атрибуты объекта.
            # Синтаксис функции setattr:
            # setattr(object, name, value)
            # object: Это объект, для которого вы хотите задать или изменить атрибут.
            # name: Это имя атрибута, которое вы хотите создать или изменить. Оно передается как строка (тип данных: str).
            # value: Это значение, которое будет присвоено атрибуту. Оно может быть любого типа данных.

            # setattr полезен, когда вам нужно создавать атрибуты в объекте динамически, например, когда вы не знаете заранее, какие именно атрибуты будут добавлены.

# __mro__ (Method Resolution Order) показывает порядок поиска методов.
# Он определяет, в каком порядке будут искаться методы в классе и его родителях.
print(User.__mro__)
# Вывод будет: (<class '__main__.User'>, <class 'object'>),
# так как User наследуется от object, это стандарт для Python классов.

other = [1, 2, 3, 4, 5]  # Позиционные аргументы, которые передаются в класс.
user = {'name': 'Artem', 'age': 24, 'gender': 'male'}  # Именованные аргументы (словарь), которые передаются в класс.

user1 = User(*other, **user)
# Создаётся объект класса User. В процессе выполнения происходит:
# 1. Вызов метода __new__:
#    - Если объекта не существует, создаётся новый экземпляр.
#    - Возвращается ссылка на экземпляр.
# 2. Вызов метода __init__:
#    - Инициализируется экземпляр, создаются атрибуты args и атрибуты из kwargs.

print(user1.args)
# Вывод: (1, 2, 3, 4, 5)
# Атрибут args содержит переданные позиционные аргументы, упакованные в кортеж.

print(user1.name)
# Вывод: 'Artem'
# Атрибут name был добавлен через именованные аргументы kwargs.

print(user1.age)
# Вывод: 24
# Аналогично name, атрибут age добавлен через kwargs.

print(user1.gender)
# Вывод: 'male'
# gender также добавлен через именованные аргументы kwargs.

print(dir(user1))
# Если аргументом является объект, dir() выведет все доступные атрибуты и методы этого объекта.

print(user1.__dict__)
# Атрибут __dict__ возвращает словарь всех изменяемых атрибутов объекта или класса.
# Это позволяет получить, добавить или изменить атрибуты объекта динамически.

class Example:
    def __new__(cls, *args, **kwargs):
        print("Я в __new__")
        print(f"args: {args}")     # Позиционные аргументы
        print(f"kwargs: {kwargs}") # Именованные аргументы
        return object.__new__(cls) # Создаём новый объект класса Example

    def __init__(self, first, second, third):
        print("Я в __init__")
        print(f"first: {first}")   # Первый позиционный аргумент
        print(f"second: {second}") # Именованный аргумент second
        print(f"third: {third}")   # Именованный аргумент third

# Создаём объект
ex = Example('data', second=25, third=3.14)

class Animal:  # Родительский класс Animal (основной класс, от которого будут наследоваться другие).
    def __init__(self, species):  # Метод инициализации (__init__), задающий вид животного.
        self.species = species  # Устанавливаем атрибут 'species' объекта равным переданному значению.
        print(f"Я животное, вид: {self.species}")  # Выводим сообщение с указанием вида животного.

class Dog(Animal):  # Дочерний класс Dog, который наследуется от родительского класса Animal.
    def __init__(self, name, species="Собака"):  # Метод инициализации с двумя параметрами: 'name' и 'species' (по умолчанию "Собака").
        # super() — встроенная функция Python для вызова методов родительского класса.
        # Синтаксис: super().method_name(arguments)
        # Здесь: super().__init__(species) вызывает метод __init__ класса Animal и передаёт ему аргумент 'species'.
        super().__init__(species)  # Инициализируем атрибут 'species' с помощью конструктора родительского класса.
        self.name = name  # Устанавливаем атрибут 'name' объекта равным переданному значению.
        print(f"Моё имя: {self.name}")  # Выводим сообщение с указанием имени собаки.

# Создаём объект класса Dog с именем "Шарик" (по умолчанию 'species' будет "Собака").
dog = Dog("Шарик")


# DZ 21
class House:  # Создаем класс House (Дом)

    houses_history = []  # Атрибут класса House - пустой список, который будет хранить историю всех домов.

    # Метод __new__ — это специальный метод, который вызывается перед методом __init__.
    # Его задача — создать и вернуть новый объект.
    # Он принимает класс (cls) как первый аргумент, а также любые дополнительные аргументы,
    # переданные при создании объекта.
    # Важно, чтобы метод __new__ возвращал новый экземпляр класса, потому что этот экземпляр
    # затем будет передан в метод __init__ для инициализации.
    def __new__(cls, *args, **kwargs):
        cls.houses_history.append(args[0])  # Добавляем значение нулевого индекса из args (например, имя дома)
        # В этом случае предполагается, что первым аргументом будет имя дома.
        # Этот список хранит все дома, созданные с использованием класса House.

        # Вызов родительского метода __new__ у базового класса object.
        # Метод __new__ создаёт новый экземпляр объекта, который будет использоваться в программе.
        # Мы передаем управление методу __new__ родительского класса object для создания объекта.
        return object.__new__(cls)  # Создает новый экземпляр объекта, возвращая его.

    def __init__(self, name, number_of_floors): # инициализация. self - ссылка на саму себя, атрибуты: name - название, number_of_floors - номер этажа
        self.name = name # устанавливаем значение атрибута name = name
        self.number_of_floors = number_of_floors # устанавливаем значение атрибута number_of_floors = number_of_floors

    def go_to(self, new_floor): # метод в классе
        if new_floor > self.number_of_floors or new_floor < 1: # Если new_floor больше чем self.number_of_floors или меньше 1
            return print('Такого этажа не существует') # возвращаем Такого этажа не существует
        else: # иначе
            for i in range(1, new_floor + 1): # для(for) i в(in) range(1, new_floor + 1)
                                              # range(start, stop, step) - stop не включительный
                print (i)

    def __len__(self): # метод __len__ возвращает длину массива, всегда int
        return self.number_of_floors # возвращаем номер/длину этажей

    # Перегрузка оператора "str()" (представление объекта в виде строки).
    # Метод __str__ является специальным методом, предназначенным для представления строкового представления объекта.
    # Метод '__str__()' определяет, как объект будет выглядеть при вызове функции str() или print().
    def __str__(self):
        return f'Название: {self.name}, кол-во этажей {self.number_of_floors}'

    # Деструктор - уничтожение объекта.
    # Этот метод вызывается, когда объект уничтожается или когда на него больше не остаётся ссылок.
    def __del__(self):
        print(f'{self.name} снесен, но он останется в истории')
        # Здесь можно освободить ресурсы или выполнить другие действия перед уничтожением объекта.
        # Например, можно добавить запись в журнал или очистить какие-то внешние ресурсы.
        # Для заглушки можно использовать pass, если не требуется выполнять дополнительные действия.

    # Перезагрузка оператора "==" (равно).
    # Метод '__eq__()' (Equal) определяет, что должно происходить при использовании оператора "==" для объектов данного класса.
    # В данном примере: два объекта будут сравниваться на основе их атрибутов number_of_floors == number_of_floors
    # Функция isinstance() используется для проверки принадлежности объекта к определенному классу или типу данных.
    ## isinstance - (объект, (тип данных)) - выдает true(истина) или false(ложь)
    def __eq__(self, other):
        if isinstance(other, House):
            return self.number_of_floors == other.number_of_floors

    # Перегрузка оператора "<" (меньше чем).
    # Метод '__lt__()' (Lower Than) определяет, что должно происходить при использовании оператора "<" для объектов данного класса.
    # В данном примере: два объекта будут сравниваться на основе их атрибута 'age'
    def __lt__(self, other):
        if isinstance(other, House):
            return self.number_of_floors < other.number_of_floors

    # Перегрузка оператора "<=" (меньше или равно).
    # Метод '__le__()' (Lower or Equal) определяет, что должно происходить при использовании оператора "<=".
    # В данном примере: проверяется, меньше или равен атрибут 'age' у одного объекта по сравнению с другим.
    def __le__(self, other):
        if isinstance(other, House):
            return self.number_of_floors <= other.number_of_floors

    # Перегрузка оператора ">" (больше чем).
    # Метод '__gt__()' (Greater Than) определяет, что должно происходить при использовании оператора ">".
    # В данном примере: два объекта сравниваются на основе их атрибута 'number_of_floors', проверяя, больше ли он.
    def __gt__(self, other):
        if isinstance(other, House):
            return self.number_of_floors > other.number_of_floors

    # Перегрузка оператора ">=" (больше или равно).
    # Метод '__ge__()' (Greater or Equal) определяет, что должно происходить при использовании оператора ">=".
    # В данном примере: проверяется, больше или равен атрибут 'number_of_floors' у одного объекта по сравнению с другим.
    def __ge__(self, other):
        if isinstance(other, House):
            return self.number_of_floors >= other.number_of_floors

    # Перегрузка оператора "!=" (не равно).
    # Метод '__ne__()' (Not Equal) определяет, что должно происходить при использовании оператора "!=".
    # В данном примере: проверяется, различаются ли значения атрибута 'number_of_floors' у двух объектов.
    def __ne__(self, other):
        if isinstance(other, House):
            return self.number_of_floors != other.number_of_floors

    # Перегрузка оператора "+" (сложение).
    # Метод '__add__()' (Addition) определяет, что должно происходить при использовании оператора "+".
    # В данном примере: добавляется целочисленное значение к атрибуту 'number_of_floors' текущего объекта.
    # Если переданный параметр не является целым числом, метод ничего не делает.
    def __add__(self, value):
        # Проверяем, является ли переданное значение целым числом.
        if isinstance(value, int):
            # Добавляем значение к атрибуту 'number_of_floors' текущего объекта.
            self.number_of_floors += value
            # Возвращаем текущий объект, чтобы можно было использовать результат в цепочке операций.
            return self

    # Перегрузка оператора "+" (сложение) с правым операндом.
    # Метод '__radd__()' вызывается, если объект класса находится справа от оператора "+".
    # В данном примере: если value является числом (int), то метод возвращает сумму атрибута 'number_of_floors' текущего объекта и value.
    # Использование: число + объект
    def __radd__(self, value):
        if isinstance(value, int):
            self.number_of_floors += value # Добавляем значение к атрибуту 'number_of_floors' текущего объекта.
            return self # возвращаем текущий объект

    # Перегрузка оператора "+=" (сложение с присваиванием).
    # Метод '__iadd__()' определяет поведение при использовании оператора "+=".
    # В данном примере: если value является числом (int), то метод изменяет значение атрибута 'number_of_floors' текущего объекта, увеличивая его на value.
    # После этого возвращает текущий объект (self), чтобы оператор "+=" работал корректно.
    # Использование: объект += число
    def __iadd__(self, value):
        if isinstance(value, int):
            self.number_of_floors += value  # Добавляем значение к атрибуту 'number_of_floors' текущего объекта.
            return self  # возвращаем текущий объект

    ### НЬАНСЫ ПРИ РАБОТЕ С АРИФМИТИЧЕСКИМИ ОПЕРАТОРАМИ  ###
    # Если ваша цель — Добавление значения к атрибуту объекта и изменение объекта:
    # def __add__(self, value):
    #     if isinstance(value, int):
    #         self.number_of_floors += value  # Сохраняем результат сложения в атрибуте
    #         return self  # Возвращаем текущий объект

    # Если ваша цель — Возвращение результата сложения, не изменяя объект:
    # def __add__(self, value):
    #     if isinstance(value, int):
    #         return self.number_of_floors + value  # Возвращаем результат сложения

    # ПРИМЕР ОСТАЛЬНЫХ АРИФМЕТИЧЕСКИХ ОПЕРАТОРОВ
            # ПРИЧМЕЧАНИЕ #
            # Да, если добавить i к названию метода
            # Использовать __iadd__ вместо __add__, это изменяет поведение оператора так, чтобы он работал как оператор присваивания с арифметикой (+=).
        # Перегрузка оператора "+" (сложение).
        # Метод '__add__()' определяет, что должно происходить при использовании оператора "+".
        # В данном примере: складываются значения атрибута 'атрибут' двух объектов.

        # Перегрузка оператора "-" (вычитание).
        # Метод '__sub__()' (Subtraction) определяет, что должно происходить при использовании оператора "-".
        # В данном примере: вычитается значение атрибута 'атрибут' одного объекта из другого.

        # Перегрузка оператора "*" (умножение).
        # Метод '__mul__()' (Multiplication) определяет, что должно происходить при использовании оператора "*".
        # В данном примере: значения атрибута 'атрибут' двух объектов перемножаются.

        # Перегрузка оператора "/" (деление).
        # Метод '__truediv__()' (True Division) определяет, что должно происходить при использовании оператора "/".
        # В данном примере: значение атрибута 'атрибут' одного объекта делится на значение другого.

        # Перегрузка оператора "//" (целочисленное деление).
        # Метод '__floordiv__()' (Floor Division) определяет, что должно происходить при использовании оператора "//".
        # В данном примере: выполняется целочисленное деление значений атрибута 'атрибут'.

        # Перегрузка оператора "%" (остаток от деления).
        # Метод '__mod__()' (Modulo) определяет, что должно происходить при использовании оператора "%".
        # В данном примере: вычисляется остаток от деления значений атрибута 'атрибут' двух объектов.

        # Перегрузка оператора "**" (возведение в степень).
        # Метод '__pow__()' (Power) определяет, что должно происходить при использовании оператора "**".
        # В данном примере: значение атрибута 'атрибут' одного объекта возводится в степень, равную значению другого.


# h1 = House('ЖК Горский', 18)
# h2 = House('Домик в деревне', 2)
#
# print(f'{h1.name, h1.number_of_floors}') # я про этот принт
# h1.go_to(10)
# print(f'{h2.name, h2.number_of_floors}') # я про этот принт
# h2.go_to(10)

# __str__
# print(h1) # получаем srt представление об объекте # то есть принт выше мы можем не использовать, чтобы получить информацию, мы уже добавили метод, который это делает
# print(h2) # получаем srt представление об объекте
#
# # __len__
# print(len(h1)) # len возвращает длину объекта (в данном случаи номер/длину этажей)
# print(len(h2)) # len возвращает длину объекта (в данном случаи номер/длину этажей)
#
# h1 = House('ЖК Эльбрус', 10)
# h2 = House('ЖК Акация', 20)
#
# print(h1)
# print(h2)
#
# print(h1 == h2) # __eq__
#
# h1 = h1 + 10 # __add__
# print(h1)
# print(h1 == h2)
#
# h1 += 10 # __iadd__
# print(h1)
#
# h2 = 10 + h2 # __radd__
# print(h2)
#
# print(h1 > h2) # __gt__
# print(h1 >= h2) # __ge__
# print(h1 < h2) # __lt__
# print(h1 <= h2) # __le__
# print(h1 != h2) # __ne__

h1 = House('ЖК Эльбрус', 10)
print(House.houses_history)
h2 = House('ЖК Акация', 20)
print(House.houses_history)
h3 = House('ЖК Матрёшки', 20)
print(House.houses_history)

# Удаление объектов
del h2
del h3

print(House.houses_history)

# КЛАСС С ПРИМЕНЕНИЕМ __new__

# === Пример использования магического метода __new__ ===

# === В Python магический метод __new__ отвечает за создание нового объекта класса. ===
# Он должен возвращать созданный объект. Если этого не сделать, метод __init__ не будет вызван.
# В __new__ можно использовать super().__new__(cls) или object.__new__(cls) для создания объекта.
# Обычно переопределяется в классах, наследуемых от неизменяемых типов, таких как int, str, tuple.

class Example:
    def __new__(cls, *args, **kwargs):
        """
        Синтаксис: __new__(cls, *args, **kwargs)
        Описание: Магический метод, отвечающий за создание нового объекта класса.
        Аргументы:
        - cls: Ссылка на класс.
        - *args, **kwargs: Позиционные и именованные аргументы.
        Возвращает: Новый объект класса.
        """
        print("Я в __new__")
        print(f"args: {args}")  # Позиционные аргументы
        print(f"kwargs: {kwargs}")  # Именованные аргументы
        # Создаём новый объект через object.__new__(cls)
        instance = object.__new__(cls)
        return instance  # Возвращаем объект

    def __init__(self, first, second, third):
        """
        Синтаксис: __init__(self, first, second, third)
        Описание: Инициализирует созданный объект. Вызывается после __new__.
        Аргументы:
        - first: Первый аргумент.
        - second: Второй аргумент.
        - third: Третий аргумент.
        """
        print("Я в __init__")
        print(f"first: {first}")
        print(f"second: {second}")
        print(f"third: {third}")

# Создаём объект Example
obj = Example("значение1", second="значение2", third="значение3")


# === Пример реализации Singleton через __new__ ===
class Singleton:
    _instance = None  # Хранит единственный экземпляр

    def __new__(cls, *args, **kwargs):
        """
        Реализация паттерна Singleton.
        Описание: Гарантирует создание только одного экземпляра класса.
        """
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

# Проверяем Singleton
singleton1 = Singleton()
singleton2 = Singleton()
print(singleton1 is singleton2)  # True

# === Пример работы с неизменяемым типом ===
class CustomInt(int):
    def __new__(cls, value):
        """
        Описание: Изменяет поведение базового типа int.
        Удваивает переданное значение.
        """
        return super().__new__(cls, value * 2)

# Проверяем CustomInt
x = CustomInt(5)
print(x)  # 10

class User:
    # __instance — это атрибут класса, который хранит ссылку на единственный экземпляр класса (если он уже был создан).
    # Используется для реализации паттерна Singleton (синглтон), где допускается только один объект данного класса.
    __instance = None

    # Метод __new__ отвечает за создание нового объекта.
    # cls — это ссылка на сам класс User, аналогично self для методов экземпляра.

    # Метод __new__ используется для контроля над процессом создания объектов.
    # Применяется в паттернах Singleton, работе с неизменяемыми типами,
    # создании кэша или при необходимости управлять доступом к объектам.

    def __new__(cls, *args, **kwargs):
        print(f'Я в нью')  # Этот вывод помогает понять, что метод __new__ был вызван.

        # Мы проверяем атрибут класса __instance. Причем, для обращения к нему используем параметр cls – ссылку на текущий класс.
        # Проверяем, существует ли уже экземпляр класса. Если он не создан, создаём его.
        if cls.__instance is None:
            # super().__new__(cls) вызывает родительский метод __new__, который создаёт объект.
            # В данном случае super() вызывает __new__ у родительского класса object, что создаёт новый объект.
            cls.__instance = super().__new__(cls)
            # Возвращаем единственный экземпляр класса.
            # === В Python магический метод __new__ должен возвращать адрес нового созданного объекта === ###
        return cls.__instance

        # Метод __init__ отвечает за инициализацию созданного объекта.

    # self указывает на экземпляр объекта, который был возвращён методом __new__.
    def __init__(self, *args, **kwargs):
        print(f'Я в ините')  # Этот вывод помогает понять, что метод __init__ был вызван.

        # Сохраняем позиционные аргументы в атрибуте args объекта.
        self.args = args

        # Проходимся по именованным аргументам (kwargs).
        # Для каждого ключа-значения создаём атрибут объекта с соответствующим именем.
        for key, value in kwargs.items():
            setattr(self, key, value)  # setattr динамически создаёт атрибуты объекта.
            # Синтаксис функции setattr:
            # setattr(object, name, value)
            # object: Это объект, для которого вы хотите задать или изменить атрибут.
            # name: Это имя атрибута, которое вы хотите создать или изменить. Оно передается как строка (тип данных: str).
            # value: Это значение, которое будет присвоено атрибуту. Оно может быть любого типа данных.

            # setattr полезен, когда вам нужно создавать атрибуты в объекте динамически, например, когда вы не знаете заранее, какие именно атрибуты будут добавлены.

# __mro__ (Method Resolution Order) показывает порядок поиска методов.
# Он определяет, в каком порядке будут искаться методы в классе и его родителях.
print(User.__mro__)

# Вывод будет: (<class '__main__.User'>, <class 'object'>),
# так как User наследуется от object, это стандарт для Python классов.

other = [1, 2, 3, 4, 5]  # Позиционные аргументы, которые передаются в класс.
user = {'name': 'Artem', 'age': 24, 'gender': 'male'}  # Именованные аргументы (словарь), которые передаются в класс.

user1 = User(*other, **user)
# Создаётся объект класса User. В процессе выполнения происходит:
# 1. Вызов метода __new__:
#    - Если объекта не существует, создаётся новый экземпляр.
#    - Возвращается ссылка на экземпляр.
# 2. Вызов метода __init__:
#    - Инициализируется экземпляр, создаются атрибуты args и атрибуты из kwargs.

print(user1.args)
# Вывод: (1, 2, 3, 4, 5)
# Атрибут args содержит переданные позиционные аргументы, упакованные в кортеж.

print(user1.name)
# Вывод: 'Artem'
# Атрибут name был добавлен через именованные аргументы kwargs.

print(user1.age)
# Вывод: 24
# Аналогично name, атрибут age добавлен через kwargs.

print(user1.gender)
# Вывод: 'male'
# gender также добавлен через именованные аргументы kwargs.

print(dir(user1))
# Если аргументом является объект, dir() выведет все доступные атрибуты и методы этого объекта.

print(user1.__dict__)
# Атрибут __dict__ возвращает словарь всех изменяемых атрибутов объекта или класса.
# Это позволяет получить, добавить или изменить атрибуты объекта динамически.


class Animal:  # Родительский класс Animal (основной класс, от которого будут наследоваться другие).
    def __init__(self, species):  # Метод инициализации (__init__), задающий вид животного.
        self.species = species  # Устанавливаем атрибут 'species' объекта равным переданному значению.
        print(f"Я животное, вид: {self.species}")  # Выводим сообщение с указанием вида животного.

class Dog(Animal):  # Дочерний класс Dog, который наследуется от родительского класса Animal.
    def __init__(self, name, species="Собака"):  # Метод инициализации с двумя параметрами: 'name' и 'species' (по умолчанию "Собака").
        # super() — встроенная функция Python для вызова методов родительского класса.
        # Синтаксис: super().method_name(arguments)
        # Здесь: super().__init__(species) вызывает метод __init__ класса Animal и передаёт ему аргумент 'species'.
        super().__init__(species)  # Инициализируем атрибут 'species' с помощью конструктора родительского класса.
        self.name = name  # Устанавливаем атрибут 'name' объекта равным переданному значению.
        print(f"Моё имя: {self.name}")  # Выводим сообщение с указанием имени собаки.

# Создаём объект класса Dog с именем "Шарик" (по умолчанию 'species' будет "Собака").
dog = Dog("Шарик")

###

class Database:
    # Класс для управления базой данных пользователей

    def __init__(self):
        # Инициализация объекта класса Database
        # Создаётся пустой словарь для хранения данных пользователей
        self.data = {}

    def add_user(self, username, password):
        # Метод добавления пользователя в базу данных
        # Аргументы: username (логин), password (пароль)
        # Добавляет в словарь self.data новую пару ключ-значение
        # username — ключ, password — значение
        self.data[username] = password


class User:
    """
    Класс пользователя, содержащий атрибуты: логин и пароль
    Проверяет пароль на длину (8+), наличие заглавной буквы и цифры.
    """
    def __init__(self, username, password, password_confirm):
        # Инициализация объекта класса User
        # Аргументы: username (логин), password (пароль), password_confirm (подтверждение пароля)
        self.username = username  # Присваиваем логин атрибуту объекта
        # Проверяем, что пароль содержит длину в +8 символов и хотя бы одну заглавную букву и хотя бы одну цифру.
        # len(password) >= 8 - проверяет длину пароля больше или равно 8 символам
        # any(i.isupper() for i in password) — проверяет, есть ли хотя бы одна заглавная буква в строке:
        #     - i.isupper() возвращает True для каждого символа, который является заглавной буквой.
        #     - any() возвращает True, если хотя бы один символ строки является заглавной буквой.
        # any(i.isdigit() for i in password) — проверяет, есть ли хотя бы одна цифра в строке:
        #     - i.isdigit() возвращает True для каждого символа, который является цифрой.
        #     - any() возвращает True, если хотя бы один символ строки является цифрой.
        # Если три условия выполняются, продолжаем проверку и сравниваем пароль с подтверждением.
        if len(password) >= 8 and any(i.isupper() for i in password) and any(i.isdigit() for i in password):
            if password == password_confirm:
                self.password = password
        else:
            print('Пароль должен содержать не менее 8 символов, одну цифру и одну заглавную букву')



# Основной блок программы
# Этот блок выполняется только если скрипт запускается напрямую, а не импортируется
if __name__ == '__main__':
    # Создается объект 'database', в котором создается экземпляр класса Database.
    database = Database()
    while True:
        # \n — символ новой строки. При выводе переводит текст на следующую строку. Используется для форматирования текста.
        choice = int(input('Приветствую! Выберите действие: \n1 - Вход\n2 - Регистрация\n'))
        if choice == 1:
            # Вход пользователя
            login = input('Введите логин: ')
            password = input('Введите пароль: ')
            if login in database.data:
                if password == database.data[login]:
                    print(f'Вход выполнен, {login}')
                    break
                else:
                    print('Неверный пароль')
            else:
                print('Пользователь не найден')
        if choice == 2:
            # Регистрация пользователя
            # Создаём объект класса User, используя ввод пользователя
            user = User(
                input('Введите логин: '),  # Запрашиваем у пользователя логин
                password := input('Введите пароль: '),  # Запрашиваем у пользователя пароль
                password2 := input('Повторите пароль: ')  # Запрашиваем подтверждение пароля
            )
        # Моржовый оператор (:=) позволяет одновременно присваивать и возвращать значение.
        # Используется для сокращения кода и удобства работы внутри выражений.
        # Не работает в глобальном пространстве имен.

        # Пример использования:
        # 1. Присваивание внутри условия:
        # if (n := len(value)) > 5:  # Присваивает len(value) переменной n и сразу проверяет условие
        #     print(f"Длина строки: {n}")

        # 2. Упрощение циклов:
        # while (line := input("Введите строку: ")) != "exit":  # Присваивает результат input переменной line
        #     print(f"Вы ввели: {line}")
        # Добавляем нового пользователя в базу данных
        # В качестве аргументов передаём логин и пароль объекта user
            if password != password2:
                print('Пароли не совпадает, попробуй еще раз')
                continue
                #exit()
        # Функция exit() — это встроенная функция Python, предназначенная для завершения работы программы.
        # exit(code)
        # Параметр code (опционально): числовой код возврата, который сообщает операционной системе о результате завершения программы.
        # 0 — успешное завершение (по умолчанию).
        # Любое ненулевое значение — ошибка.
            database.add_user(user.username, user.password)

        # Печатаем содержимое словаря self.data
        print(database.data)
        # Атрибут __dict__ возвращает словарь всех изменяемых атрибутов объекта или класса.
        # Это позволяет получить, добавить или изменить атрибуты объекта динамически.
        print(database.__dict__)
        # __mro__ (Method Resolution Order) показывает порядок поиска методов.
        # Он определяет, в каком порядке будут искаться методы в классе и его родителях.
        print(Database.__mro__)


# DZ 22
# Комментарии добавлял GPT #
from time import sleep

# Класс пользователя
class User:
    def __init__(self, nickname, password, age):
        self.nickname = nickname  # Имя пользователя
        self.password = hash(password)  # Хэшированный пароль для безопасности
        self.age = age  # Возраст пользователя

    # Метод __repr__()
    # __repr__(self)
    #
    # Описание:
    # Метод __repr__() используется для создания строкового представления объекта.
    # Это представление предназначено для отладки и демонстрации объекта. Когда объект выводится
    # или преобразуется в строку, вызывается метод __repr__().
    # Если метод __repr__() реализован, он заменяет стандартное представление объекта (которое обычно
    # выглядит как адрес в памяти) на более осмысленную строку, которая может быть использована для
    # восстановления объекта.
    # Идеально, если строка, возвращаемая __repr__(), может быть использована для воссоздания объекта.

    def __repr__(self):
        return f'{self.nickname}, {self.password}, {self.age}'


# Класс видео
class Video:
    def __init__(self, title, duration, time_now=0, adult_mode=False):
        self.title = title  # Название видео
        self.duration = duration  # Продолжительность видео в секундах
        self.time_now = time_now  # Текущее время просмотра видео
        self.adult_mode = adult_mode  # Флаг возрастного ограничения

    def __repr__(self):
        return f'{self.title}'


# Основной класс приложения
class UrTube:
    def __init__(self):
        self.users = []  # Список зарегистрированных пользователей
        self.videos = []  # Список добавленных видео
        self.current_user = None  # Текущий пользователь

    def __repr__(self):
        return f'{self.users}, {self.videos}, {self.current_user}'

    # Авторизация пользователя
    def log_in(self, nickname, password):
        pas = hash(password)  # Хэшируем введённый пароль
        for i in self.users:  # Цикл используется для проверки учетных данных.
                              # Переменная `i` принимает значения объектов класса `User`, чтобы сравнить `nickname` и `password` с вводимыми данными.
                              # Мы можем обращаться к атрибутам класса `User`, так как в `self.users` хранятся его объекты.
            if nickname == i.nickname and pas == i.password:  # Проверяем совпадение логина и пароля
                self.current_user = nickname  # Устанавливаем текущего пользователя
                print(f'Пользователь {nickname} вошел в аккаунт')

    # Регистрация пользователя
    def register(self, nickname, password, age):
        # Проверяем, существует ли пользователь с таким никнеймом
        if any(p.nickname == nickname for p in self.users):  # Используем цикл для проверки существования пользователя.
                                                             # Переменная `p` принимает значения объектов класса `User` из списка `self.users`.
                                                             # Мы можем обращаться к их атрибутам (например, `p.nickname`), так как `self.users` хранит экземпляры класса `User`.
            print(f'Юзер {nickname} уже существует')
        else:
            obj = User(nickname, password, age)  # Создаём нового пользователя
            self.users.append(obj)  # Добавляем его в список пользователей
            self.current_user = nickname  # Устанавливаем текущего пользователя
            print(f'Пользователь {nickname} вошел в аккаунт')

    # Выход из аккаунта
    def log_out(self):
        self.current_user = None  # Убираем текущего пользователя

    # Добавление видео
    def add(self, *other): # *other - создает кортеж
        self.videos.extend(other)  # Добавляем в список наш кортеж
        return self.videos

        # Поиск видео по ключевому слову

    def get_videos(self, other):
        value = other.lower()  # Приводим ключевое слово к нижнему регистру для удобства поиска
        get_videos1 = []  # Создаём список для подходящих видео
        for x in self.videos:  # Цикл перебирает объекты `Video` в списке `self.videos`.
                               # Переменная `x` принимает значения каждого объекта видео, добавленного в список.
                               # Мы можем обращаться к атрибутам класса `Video` (например, `x.title`), так как в `self.videos` хранятся экземпляры этого класса.
            if value in x.title.lower():  # Проверяется, содержится ли ключевое слово (`value`) в названии текущего видео (`x.title`).
                # Название видео также приводится к нижнему регистру для корректного поиска без учёта регистра.
                get_videos1.append(x.title)  # Добавляем название видео в список, если условие выполняется
        return get_videos1  # Возвращаем список найденных видео

    # Просмотр видео
    def watch_video(self, film):
        if not self.current_user:  # Если пользователь не авторизован
            print('Войдите в аккаунт')
            return
        for i in self.videos:  # Цикл перебирает все объекты `Video`, добавленные в список `self.videos`.
                               # Переменная `i` последовательно принимает каждое видео.
                               # Мы можем обращаться к атрибутам класса `Video`, так как в `self.videos` хранятся его объекты.
            if film in i.title:  # Если найдено видео с указанным названием
                for k in self.users:  # Цикл используется для проверки текущего пользователя.
                                      # Переменная `k` принимает значения объектов класса `User`, чтобы определить, есть ли возрастные ограничения на видео.
                                      # Мы можем обращаться к атрибутам объектов класса `User`, так как в `self.users` хранится список экземпляров этого класса.
                    if k.nickname == self.current_user and i.adult_mode:  # Если видео имеет ограничение 18+
                        # Проверяется, является ли текущий пользователь (`self.current_user`) тем же,
                        # кого представляет объект `k` из списка `self.users`.
                        # Это нужно, чтобы проверить ограничения именно для активного пользователя.
                        # Одновременно проверяется, включено ли возрастное ограничение для видео (`i.adult_mode`).
                        # Условие выполняется, если текущий пользователь совпадает с `k`, и видео предназначено для взрослых.
                        if k.age < 18:  # Проверяем возраст пользователя
                            # Если видео имеет ограничение для взрослых, проверяется возраст пользователя (`k.age`).
                            # Если возраст пользователя меньше 18 лет, доступ к видео блокируется.
                            # Пользователь получает сообщение о том, что он не может просмотреть видео.
                            print(f'Вам нет 18 лет для просмотра видео "{i.title}"')
                            return
                print(f'Воспроизводится видео: {i.title}')  # Начинаем воспроизведение
                for l in range(i.time_now, i.duration):  # Цикл, эмулирующий воспроизведение видео. Итерации проходят от текущего времени `i.time_now` до полной продолжительности `i.duration`.
                    sleep(1)  # Пауза в 1 секунду на каждом шаге симулирует проигрывание кадра.
                    i.time_now += 1  # Увеличиваем текущее время воспроизведения на 1 секунду.
                    print(f"Время: {i.time_now} сек")  # Выводим текущее время.
                print(f'Конец видео')  # Сообщаем о завершении воспроизведения
                i.time_now = 0  # Сбрасываем текущее время просмотра
                return
        print(f'Видео не найдено, повторите поиск')


# Создание экземпляра приложения
ur = UrTube()

# Создание объектов видео
v1 = Video('Лучший язык программирования 2024 года', 200)
v2 = Video('Для чего девушкам парень программист?', 10, adult_mode=True)

# Добавление видео
ur.add(v1, v2)

# Проверка поиска
print(ur.get_videos('лучший'))  # Ищем видео с ключевым словом "лучший"
print(ur.get_videos('ПРОГ'))  # Ищем видео с ключевым словом "ПРОГ"

# Попытка просмотра без авторизации
ur.watch_video('Для чего девушкам парень программист?')

# Регистрация и авторизация пользователей
ur.register('vasya_pupkin', 'lolkekcheburek', 13)
ur.watch_video('Для чего девушкам парень программист?')  # Попытка просмотра видео с ограничением
ur.register('test_mou_test', 'dlgkokLKDFJo2354F', 14)
ur.watch_video('Для чего девушкам парень программист?')
# ur.watch_video('Лучший язык программирования 2024 года') # воспроизводится
ur.register('urban_pythonist', 'iScX4vIJClb9YQavjAgF', 25)
ur.watch_video('Для чего девушкам парень программист?')  # Просмотр успешен

# Проверка входа в другой аккаунт
ur.register('vasya_pupkin', 'F8098FM8fjm9jmi', 55)
print(ur.current_user)  # Текущий пользователь

# Попытка воспроизведения несуществующего видео
ur.watch_video('Лучший язык программирования 2024 года!')


'''НАСЛЕДОВАНИЕ КЛАССОВ'''

# На самом деле символ нижнего подчеркивания и двойного нижнего подчеркивания в Python имеет очень широкий спектр применения
# Например, нижнее подчеркивание перед именем делает это имя "защищённым" (protected),
# предполагая его использование только внутри класса и его подклассов. Это особенно актуально для импортов.

class _Human:
    head = True  # Публичный атрибут: доступен для чтения и записи вне класса.
    _legs = True  # Защищённый атрибут: предполагается его использование только внутри класса и подклассов.
    __arms = True  # Приватный атрибут: недоступен напрямую из дочерних классов или экземпляров.
    # Символ двойного нижнего подчеркивания создаёт "обфускацию" имени (name mangling),
    # автоматически добавляя перед именем атрибута имя класса (например, _Human__arms).

    # Метод say_hello() логично вынести в родительский класс, так как он общий для всех людей.
    # Дочерние классы, такие как Student и Teacher, автоматически наследуют его.
    # Это позволяет использовать метод say_hello() для всех дочерних классов без необходимости его переопределения.
    def say_hello(self):
        print(f'Привет')

    # Метод about() демонстрирует доступ к атрибутам разных уровней "защищённости":
    # публичным (head), защищённым (_legs) и приватным (__arms).
    def about(self):
        print(self.head)  # Доступ к публичному атрибуту.
        print(self._legs)  # Доступ к защищённому атрибуту.
        print(self.__arms)  # Доступ к приватному атрибуту через обфусцированное имя (_Human__arms).

    # Конструктор (__init__) в родительском классе.
    # Если у дочернего класса не определён свой __init__, будет использоваться этот метод.
    # Важно: self в данном контексте ссылается на экземпляр дочернего класса,
    # поэтому вызовы методов и доступ к атрибутам могут быть переопределены в подклассе.
    def __init__(self):
        if hasattr(self, 'about'):  # Проверка на наличие метода about у текущего экземпляра.
            self.about()  # Вызов метода about(). Если метод переопределён в подклассе, вызовется версия подкласса.

# Класс Human является базовым (родительским) классом.
# Класс Student является дочерним (подклассом) класса Human.
# Дочерний класс наследует атрибуты и методы родительского класса.
# Если в дочернем классе вызывается метод или атрибут, сначала проверяется его наличие внутри дочернего класса.
# Если метод или атрибут не найден, поиск продолжается в родительском классе.
class Student(_Human):
    head = False  # Атрибут head переопределён в дочернем классе Student.
    # Дочерний класс может добавлять собственные методы и атрибуты, которых нет в родительском классе.

class Teacher(_Human):
    pass  # Заглушка pass означает, что класс Teacher пока не добавляет ничего нового к родительскому классу.

# Принцип DRY (Don’t Repeat Yourself, "не повторяйся"):
# Наследование позволяет избежать дублирования кода, предоставляя общий функционал в родительском классе.
# Например, метод say_hello() определён только в классе Human, но доступен и для Student, и для Teacher.

student = Student()  # Создаём экземпляр класса Student.
teacher = Teacher()  # Создаём экземпляр класса Teacher.
human = _Human()  # Создаём экземпляр класса Human.

# Метод say_hello() вызывается у объектов дочерних классов,
# но фактически он определён в родительском классе Human.
student.say_hello()  # Вывод: Привет
teacher.say_hello()  # Вывод: Привет

# Дочерний класс Student переопределяет атрибут head.
# Значение head для экземпляра класса Student берётся из дочернего класса, а не из родительского.
print(student.head)  # Вывод: False

# Атрибут head для экземпляра класса Human берётся из родительского класса Human.
print(human.head)  # Вывод: True

# Метод about() демонстрирует доступ к атрибутам класса на разных уровнях "защищённости".
human.about()  # Доступ к head, _legs, __arms (через name mangling).
student.about()  # Доступ к head, _legs, __arms (унаследованный метод).

# Метод dir() показывает все доступные атрибуты объекта, включая те, которые создаются через обфускацию (name mangling).
print(dir(human))
print(dir(student))
print('---')

# Доступ к приватному атрибуту __arms осуществляется через обфусцированное имя (_Human__arms).
print(student._Human__arms)  # Вывод: True
print(teacher._Human__arms)  # Вывод: True

# Доступ к приватному атрибуту напрямую вызовет ошибку.
# print(human.__arms)  # Ошибка: AttributeError: '_Human' object has no attribute '__arms'.



class Parent:
    def __init__(self):
        self._protected = "I am protected"
        self.__private = "I am private"

    def show(self):
        print(self._protected)
        print(self.__private)

class Child(Parent):
    def access_attributes(self):
        print(self._protected)  # Доступен
        # print(self.__private)  # Ошибка: 'Child' object has no attribute '__private'

parent = Parent()
print(parent._protected)  # Доступ извне (но не рекомендуется)
# print(parent.__private)  # AttributeError

child = Child()
child.access_attributes()

# Name mangling для приватных атрибутов:
# Name Mangling:
# Python автоматически изменяет имя приватного атрибута, добавляя имя класса перед ним.
# Например, __private в классе Parent станет _Parent__attribute.
print(parent._Parent__private)  # Работает, но использовать крайне нежелательно

# Вывод:
# Используйте _attribute для защищённых переменных, которые могут понадобиться подклассам.
# Используйте __attribute для полного сокрытия данных и предотвращения конфликтов.



# DZ 23 (Сделал Сам, Комментарии писал GPT)
# Класс Animal (Животное)
class Animal:
    alive = True  # Атрибут, указывающий на то, жив ли объект (по умолчанию True)
    fed = False  # Атрибут, указывающий на то, накормлено ли животное (по умолчанию False)

    def __init__(self, name):
        self.name = name  # Инициализация имени животного

    def eat(self, food):
        # food — это объект, переданный в метод eat
        # Когда мы передаем объект p1 (например, цветок), он является экземпляром класса Flower.
        # Класс Flower наследует атрибут edible от родительского класса Plant.
        # Поэтому, когда мы обращаемся к food.edible, Python ищет атрибут в объекте p1 (класс Flower),
        # а если его нет, ищет его в родительском классе Plant (где edible по умолчанию False).

        if food.edible is True:
            print(f'{self.name} съел {food.name}')  # Если еда съедобна, животное ест
            self.fed = True  # Животное становится накормленным
        if food.edible is False:
            print(f'{self.name} не стал есть {food.name}')  # Если еда несъедобна, животное не ест
            self.alive = False  # Животное умирает

# Класс Plant (Растение)
class Plant:
    edible = False  # Растения по умолчанию не съедобны. Этот атрибут будет унаследован всеми классами,

    # которые наследуют от Plant, если они не переопределят его.

    def __init__(self, name):
        self.name = name  # Инициализация имени растения

# Классы-наследники Animal
class Mammal(Animal):  # Млекопитающие (наследуют от Animal)
    pass

class Predator(Animal):  # Хищники (наследуют от Animal)
    pass

# Классы-наследники Plant
class Flower(Plant):  # Цветок (не съедобен)
    pass

class Fruit(Plant):  # Плод (съедобен)
    edible = True  # Плоды переопределяют edible и делают его True (съедобным)

# Создаем объекты
a1 = Predator('Волк с Уолл-Стрит')  # Хищник
a2 = Mammal('Хатико')  # Млекопитающее
p1 = Flower('Цветик семицветик')  # Цветок (несъедобный)
p2 = Fruit('Заводной апельсин')  # Плод (съедобный)

# Выводим имена объектов
print(a1.name)  # Вывод: Волк с Уолл-Стрит
print(p1.name)  # Вывод: Цветик семицветик

# Проверяем начальные состояния животных
print(a1.alive)  # Вывод: True (живое)
print(a2.fed)  # Вывод: False (не накормленное)

# Волк (хищник) пытается съесть цветок (несъедобный)
a1.eat(p1)  # Вывод: Волк с Уолл-Стрит не стал есть Цветик семицветик
# Здесь, так как объект p1 — это экземпляр класса Flower, и класс Flower наследует атрибут edible от Plant,
# то при вызове p1.edible возвращается значение False, и Волк не ест цветок, умирает.

# Хатико (млекопитающее) пытается съесть апельсин (съедобный)
a2.eat(p2)  # Вывод: Хатико съел Заводной апельсин
# Здесь, так как объект p2 — это экземпляр класса Fruit, и класс Fruit переопределяет атрибут edible на True,
# при вызове p2.edible возвращается значение True, и Хатико ест апельсин.

# Проверяем состояние после еды
print(a1.alive)  # Вывод: False, так как Волк умер (не стал есть несъедобное)
print(a2.fed)  # Вывод: True, так как Хатико съел съедобное и стал накормленным

# DZ 24
class Vehicle:
    # Константные (постоянные) значения в Python принято писать полностью в верхнем регистре (капсом).
    # Этот список доступных цветов скрыт, потому что он является приватным.
    __COLOR_VARIANTS = ['blue', 'red', 'green', 'black', 'white']

    def __init__(self, owner, __model, __engine_power, __color):
        # Конструктор (инициализация объекта):
        # self.owner - открытый атрибут, доступен всем.
        self.owner = str(owner)  # Владелец транспортного средства.

        # Приватные атрибуты (доступны только внутри класса или через методы):
        self.__model = str(__model)  # Модель транспортного средства.
        self.__engine_power = int(__engine_power)  # Мощность двигателя.
        self.__color = str(__color)  # Цвет транспортного средства.

        # Здесь `self.__model` используется для сохранения приватного атрибута модели.
        # self ссылается на конкретный экземпляр класса, созданный в момент вызова конструктора.
        # Когда мы используете self внутри метода класса, self всегда ссылается на конкретный экземпляр этого класса, на котором был вызван метод.
        # vehicle1.get_model()  # Здесь self — это vehicle1 == Здесь self — это vehicle1

    # Геттеры: методы, позволяющие безопасно получать значения приватных атрибутов.
    # Они защищают данные от прямого доступа и позволяют добавлять логику при их вызове.
    def get_model(self):
        print(f'Модель: {self.__model}')

    def get_horsepower(self):
        print(f'Мощность двигателя: {self.__engine_power}')

    def get_color(self):
        print(f'Цвет: {self.__color}')

    # Общий метод для вывода всей информации об объекте.
    def print_info(self):
        self.get_model()
        self.get_horsepower()
        self.get_color()
        print(f'Владелец: {self.owner}')

    # Сеттеры: методы, позволяющие безопасно изменять значения приватных атрибутов.
    # Они помогают контролировать, какие данные могут быть назначены, и проверять их корректность.
    def set_color(self, new_color):
        # Метод для изменения цвета транспортного средства.
        # Проверяет, соответствует ли новый цвет списку доступных цветов (__COLOR_VARIANTS).
        for x in self.__COLOR_VARIANTS:
            if new_color.lower() == x.lower():  # Сравнение нового цвета без учёта регистра.
                self.__color = x  # Если цвет найден в списке, он назначается объекту.
                return  # Оператор return завершает выполнение метода, чтобы предотвратить вывод ошибки.
        else:
            # Если цвет не найден в списке, выводится сообщение об ошибке.
            print(f'Нельзя сменить цвет на {new_color}')

class Sedan(Vehicle):
    # Константа с ограничением количества пассажиров в седане.
    __PASSENGERS_LIMIT = 5

# Создаём экземпляр класса Sedan с определёнными атрибутами.
vehicle1 = Sedan('Fedos', 'Toyota Mark II', 500, 'blue')

# Изначальные свойства объекта выводятся через print_info().
vehicle1.print_info()

# Пытаемся сменить цвет на недопустимый, затем на допустимый.
vehicle1.set_color('Pink')  # Этот цвет не доступен в __COLOR_VARIANTS, поэтому будет ошибка.
vehicle1.set_color('BLACK')  # Этот цвет доступен, поэтому изменение произойдёт.

# Изменяем владельца напрямую через открытый атрибут owner.
vehicle1.owner = 'Vasyok'

# Проверяем обновлённые свойства объекта через print_info().
vehicle1.print_info()

#print(Vehicle._Vehicle__model) # Напрямую обратиться нельзя
# print(f'{vehicle1._Vehicle__model}') # Через name mangling:
                                     # Можно вручную обратиться к атрибуту, указав его преобразованное имя:

# В Python приватные атрибуты обозначаются с помощью двойного нижнего подчёркивания (__attribute).
# Это делает их недоступными напрямую за пределами класса. Но внутри самого класса (включая геттеры, сеттеры или другие методы) мы можем к ним обращаться.

# Почему? Потому что геттеры и сеттеры являются частью класса, и внутри методов класса всё ещё используется объект self,
# который "знает" о своих собственных атрибутах, включая приватные.

class Example:
    def __init__(self, value):
        self.__private_value = value  # Приватный атрибут

    def get_value(self):  # Геттер
        return self.__private_value

    def set_value(self, new_value):  # Сеттер
        self.__private_value = new_value

obj = Example(42)
print(obj.get_value())  # Доступ через геттер
obj.set_value(100)      # Изменение через сеттер
print(obj.get_value())

#Здесь геттер и сеттер позволяют безопасно получать и изменять значение приватного атрибута __private_value.

'''НАСЛЕДОВАНИЕ МЕТОД super()'''

# super() используется для автоматического вызова методов родительских классов в порядке MRO (Method Resolution Order).
# Это упрощает работу с множественным наследованием, избегая жесткой привязки к конкретным родительским классам.
# MRO определяет порядок поиска методов в цепочке наследования.
# Когда использовать super():
# - Когда необходимо объединить поведение нескольких родительских классов.
# - Когда нужно обеспечить правильный порядок вызова методов, особенно в случае множественного наследования.
# - Когда хочется избежать дублирования кода, не вызывая методы родительских классов вручную.
# - Когда порядок наследования может изменяться, и нужно гарантировать правильную работу программы.

# В классе Human вызов super() позволяет вызвать методы следующих классов по MRO, обеспечивая правильный порядок и логику.
class Human:
    def __init__(self, name, group):
        self.name = name
        super().__init__(group)  # Вызывает конструктор следующего класса по MRO
        super().about()  # Вызов метода about() из следующего класса в цепочке MRO

    def info(self):
        print(f'Привет, меня зовут {self.name}')


class StudentGroup:
    def __init__(self, group):
        self.group = group

    def about(self):
        print(f'{self.name} учится в группе {self.group}')


# Класс Student использует множественное наследование, и super() помогает правильно вызвать методы из обоих родительских классов.
# Использование super() гарантирует, что конструкторы и методы родительских классов будут вызваны в правильном порядке.
class Student(Human, StudentGroup):
    def __init__(self, name, place, group):
        super().__init__(name, group)  # Вызов конструкторов классов Human и StudentGroup по MRO
        self.place = place
        super().info()  # Вызов метода info() из класса Human

        # В коде:
        # 1. При вызове super().__init__(name, group) Python сначала вызывает конструктор
        #    класса Human, затем переходит к следующему классу (StudentGroup) по MRO.
        # 2. При вызове super().info() Python вызывает метод info() из класса Human,
        #    так как он идет первым в MRO.
        #
        # Использование super() в этом контексте позволяет:
        # - Автоматически управлять порядком вызова методов, избегая жесткой привязки
        #   к классу.
        # - Избегать дублирования кода и поддерживать гибкость при изменении порядка
        #   наследования.
        # - Сохранять устойчивость к изменениям в структуре классов.

student = Student('Алина', 'Урбан', 'Питон 1')

# Вывод MRO можно проверить с помощью метода mro(), который показывает, в каком порядке Python будет искать методы:
print(Student.mro())  # Проверка порядка MRO: [Student, Human, StudentGroup, object]

# Когда используется super(), Python автоматически находит методы по порядку в MRO, делая код более гибким и поддерживаемым.
# MRO гарантирует правильный порядок вызовов методов и предотвращает проблемы при изменении порядка наследования.



#####
# Пример, когда стоит использовать super():
# Предположим, у вас есть два родительских класса,
# которые выполняют схожие действия, но вы хотите объединить их поведение в дочернем классе:

class Parent1:
    def greet(self):
        print("Hello from Parent1")

class Parent2:
    def greet(self):
        print("Hello from Parent2")

class Child(Parent1, Parent2):
    def greet(self):
        # Вызов greet() из обоих родителей через super()
        super().greet()

child = Child()
child.greet()
# Здесь super() используется для вызова метода greet() в соответствии с MRO, а не напрямую указывая Parent1.greet() или Parent2.greet().
# Если изменится порядок наследования, super() автоматически будет вызывать метод из следующего класса в MRO, что гарантирует правильное поведение.

# Когда не обязательно использовать super():
# Если в вашем классе нет множественного наследования, то использование super() не дает особых преимуществ.
# В этом случае можно прямо вызывать методы родительского класса.

# Когда вам нужно жестко контролировать, какой родительский класс будет вызван.
# В таких случаях вы можете явно указать класс, например, Parent1.method(self).
# В общем случае, для множественного наследования и при необходимости гарантировать правильный порядок вызова методов, использование super() — это лучший подход.

# Однако, важность такого класса заключается в том, что он управляет тем, как методы из родительских классов вызываются и комбинируются,
# особенно через использование super() и MRO (Method Resolution Order).

# Определяем класс A с методом method()
class A:
    def method(self):
        print("Метод из A")  # Этот метод будет найден в классе A

# Определяем класс B с методом method()
class B:
    def method(self):
        print("Метод из B")  # Этот метод будет найден в классе B
        # Нет вызова super(), поэтому поиск не продолжится в A

# Определяем класс C, который наследует B и A
class C(B, A):  # Порядок наследования: сначала B, затем A
    def method(self):
        print("Метод из C")  # Этот метод будет найден в классе C
        super().method()  # Вызов super() продолжит поиск метода в следующем классе по MRO

c = C()
c.method()  # Этот вызов будет искать метод по цепочке MRO (C -> B)

# Ожидаемый вывод:
# Метод из C
# Метод из B

# Важные моменты:
# 1. Класс C вызывает метод method() из своего родителя по порядку MRO (сначала из B, затем из A).
# 2. В классе B нет вызова super(), поэтому поиск метода не продолжится в A.
# 3. Метод из A не будет вызван, так как в B не было вызова super() для продолжения поиска.

# MRO и super() помогают избежать проблем, связанных с изменением порядка наследования,
# гарантируя правильный порядок вызова методов.
# Класс с множественным наследованием управляет логикой вызова методов из разных классов,
# но не является «главным» в контексте всей программы.



# Определяем класс A с методом method()
class A:
    def method(self):
        print("Метод из A")  # Этот метод будет найден в классе A

# Определяем класс B с методом method()
class B:
    def method(self):
        print("Метод из B")  # Этот метод будет найден в классе B
        super().method()  # Вызов super() продолжит поиск метода в следующем классе по MRO

# Определяем класс C, который наследует B и A
class C(B, A):  # Порядок наследования: сначала B, затем A
    def method(self):
        print("Метод из C")  # Этот метод будет найден в классе C
        super().method()  # Вызов super() продолжит поиск метода в следующем классе по MRO

c = C()
c.method()  # Этот вызов будет искать метод по цепочке MRO (C -> B -> A)

# Вывод MRO для класса C
print(C.mro())  # Выведет: [<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>]

# Важные моменты:
# 1. В классе C вызывается super().method(), что приводит к вызову метода из B (следующий класс в MRO).
# 2. В классе B есть вызов super().method(), который продолжает поиск метода в классе A.
# 3. В MRO порядок наследования C -> B -> A гарантирует, что метод из A будет вызван, если super() используется в B.

# MRO и super() помогают избежать проблем, связанных с изменением порядка наследования,
# гарантируя правильный порядок вызова методов.
# Класс с множественным наследованием управляет логикой вызова методов из разных классов,
# но не является «главным» в контексте всей программы.

# DZ 25
from random import randint  # Импортируем функцию randint для генерации случайных чисел.

# Базовый класс для всех животных
class Animal:
    live = True  # Класс-атрибут: указывает, что животные живые.
    sound = None  # Атрибут звука, который переопределяется в дочерних классах.
    _DEGREE_OF_DANGER = 0  # Приватный атрибут: степень опасности животного.

    def __init__(self, speed, _cords=[0, 0, 0]):
        # Инициализация объекта: задаём скорость и начальные координаты.
        self._cords = [0, 0, 0]  # Приватные координаты животного: X, Y, Z.
        self.speed = speed  # Скорость передвижения животного.

    def move(self, dx, dy, dz):
        # Метод для передвижения животного.
        self._cords[0] = dx * self.speed  # Перемещение по оси X с учётом скорости.
        self._cords[1] = dy * self.speed  # Перемещение по оси Y с учётом скорости.
        if dz < 0:
            # Если животное пытается уйти под землю, выводим сообщение и прекращаем выполнение.
            print('Слишком глубоко, я не могу нырнуть')
            return
        else:
            self._cords[2] = dz * self.speed  # Перемещение по оси Z (вверх).

    def get_cords(self):
        # Метод для получения текущих координат животного.
        print(f'X:{self._cords[0]}, Y:{self._cords[1]}, Z:{self._cords[2]}')

    def attack(self):
        # Метод для атаки: проверяем степень опасности животного.
        if self._DEGREE_OF_DANGER >= 5:
            print(f'Острожно, я тебя атакую 0_0')  # Если степень опасности высокая, животное атакует.
        else:
            print(f'Извините, я мирный')  # Если степень опасности низкая, животное мирное.

    def speak(self):
        # Метод для воспроизведения звука животного.
        print(f'{self.sound}')


# Класс птиц, наследуется от Animal.
class Bird(Animal):
    beak = True  # Класс-атрибут: у птиц есть клюв.

    def lay_eggs(self):
        # Метод для откладывания яиц.
        ran1_4 = randint(1, 4)  # Генерируем случайное число от 1 до 4.
        print(f'Вот (есть) {ran1_4} яйца для тебя')  # Сообщаем, сколько яиц снесено.


# Класс водных животных, наследуется от Animal.
class AquaticAnimal(Animal):
    _DEGREE_OF_DANGER = 3  # Водные животные имеют среднюю степень опасности.

    def dive_in(self, dz):
        # Метод для погружения в воду.
        dz = abs(dz)  # Берём модуль значения глубины, чтобы избежать отрицательных чисел.
        self._cords[2] -= dz  # Уменьшаем координату Z (погружаемся вниз).
        if self._cords[2] < 0:
            # Если координата Z становится меньше 0, устанавливаем её на 0.
            self._cords[2] = 0
        self.speed /= 2  # Скорость животного уменьшается вдвое при погружении.


# Класс ядовитых животных, наследуется от Animal.
class PoisonousAnimal(Animal):
    _DEGREE_OF_DANGER = 8  # Ядовитые животные имеют высокую степень опасности.


# Утконос, класс множественного наследования от Bird, PoisonousAnimal и AquaticAnimal.
class Duckbill(Bird, PoisonousAnimal, AquaticAnimal):
    sound = "Click-click-click"  # Звук, издаваемый утконосом.

    def __init__(self, speed):
        # Конструктор утконоса: передаём скорость в конструктор родительских классов.
        super().__init__(speed)

    def dive_in(self, dz):
        # Переопределение метода погружения.
        super().dive_in(dz)

    def lay_eggs(self):
        # Переопределение метода откладывания яиц.
        super().lay_eggs()

    def attack(self):
        # Переопределение метода атаки.
        super().attack()

    def speak(self):
        # Переопределение метода воспроизведения звука.
        super().speak()

    def move(self, dx, dy, dz):
        # Переопределение метода перемещения.
        super().move(dx, dy, dz)

    def get_cords(self):
        # Переопределение метода получения координат.
        super().get_cords()


# Создаём экземпляр класса Duckbill с заданной скоростью.
db = Duckbill(10)
print(db.live)  # Проверяем, жив ли объект (класс-атрибут из Animal).
print(db.beak)  # Проверяем, есть ли у утконоса клюв (класс-атрибут из Bird).
db.speak()  # Утконос издаёт свой звук (переопределённый метод).
db.attack()  # Проверяем, атакует ли утконос (метод учитывает степень опасности).
db.move(1, 2, 3)  # Перемещаем утконоса по координатам X, Y, Z.
db.get_cords()  # Получаем текущие координаты утконоса.
db.dive_in(60)  # Утконос ныряет на 60 единиц глубины.
db.get_cords()  # Проверяем координаты после погружения.
db.lay_eggs()  # Утконос откладывает яйца.
print(Duckbill.mro())



# Когда дочерний класс наследует атрибуты и методы родительского класса через super(), он получает доступ ко всем этим атрибутам и методам.
# В приведённом примере атрибут self.items, инициализированный в родительском классе Parent, становится доступным в дочернем классе Child.

class Parent:
    def __init__(self, items):
        self.items = items  # Присваиваем переданный список атрибуту self.items

class Child(Parent):
    def __init__(self, items):
        super().__init__(items)  # Вызываем конструктор Parent
        self.items.append("Added in Child")  # Изменяем список, добавляя элемент

# Создаём список и передаём его в дочерний класс
items_list = ["Item1", "Item2"]
child_instance = Child(items_list)

print(child_instance.items)  # ['Item1', 'Item2', 'Added in Child']
print(items_list)            # ['Item1', 'Item2', 'Added in Child']

# DZ 26
import math  # Импортируем модуль math для выполнения математических операций, таких как вычисление корня.

# Базовый класс для геометрических фигур
class Figure:
    sides_count = 0  # Класс-атрибут: задаёт количество сторон фигуры (по умолчанию 0).

    def __init__(self, __color, __sides):
        # Конструктор класса принимает цвет фигуры и её стороны.
        # Цвет (RGB) сохраняется как список, стороны — как список длины сторон.
        self.__sides = list(__sides)  # Приватный атрибут: список длин сторон.
        self.__color = [*__color]  # Приватный атрибут: цвет фигуры (RGB).
        self.filled = True  # Атрибут заполненности фигуры (по умолчанию True).

    def check(self):
        # Метод проверяет количество сторон фигуры.
        # Если количество сторон соответствует sides_count, возвращает их.
        # Если количество сторон меньше, создаёт список сторон длиной sides_count со значением 1.
        l = 0
        if len(self.__sides) == self.sides_count:  # Проверка количества сторон.
            for i in self.__sides:  # Перебираем стороны.
                self.__sides = []  # Обнуляем список сторон.
                self.__sides.append(i)  # Добавляем текущую сторону.
                return self.__sides
        else:
            # Если количество сторон меньше, создаём новый список сторон с длиной sides_count.
            self.__sides = []
            while l < self.sides_count:  # Заполняем список сторонами длиной 1.
                self.__sides.append(1)
                l += 1
            return self.__sides

    def get_color(self):
        # Метод возвращает текущий цвет фигуры (RGB).
        return self.__color

    def __is_valid_color(self, r, g, b):
        # Приватный метод проверяет корректность переданного цвета (RGB).
        # Цвет должен быть в диапазоне 0-255 для каждого из значений r, g, b.
        if isinstance(r, int) and isinstance(g, int) and isinstance(b, int):
            if 0 <= r <= 255 and 0 <= g <= 255 and 0 <= b <= 255:
                # Если цвет корректен, обновляем атрибут __color.
                self.__color = [r, g, b]
                return self.__color
        return self.__color  # Если цвет некорректен, возвращаем текущий.

    def set_color(self, r, g, b):
        # Публичный метод для изменения цвета фигуры.
        # Делегирует проверку валидности метода __is_valid_color.
        self.__is_valid_color(r, g, b)

    def __is_valid_sides(self, *args):
        # Приватный метод для проверки длин сторон.
        # Возвращает True, если все стороны больше 0 и их количество соответствует текущему.
        for i in args:
            if i > 0 and len(args) == len(self.__sides):
                return True
        return False

    def get_sides(self):
        # Метод возвращает текущие стороны фигуры.
        return self.__sides

    def __len__(self):
        # Специальный метод, возвращающий периметр фигуры (сумму всех сторон).
        j = 0
        for i in self.__sides:  # Перебираем стороны и суммируем их длины.
            j += i
        return j

    def set_sides(self, *new_sides):
        # Метод устанавливает новые стороны фигуры.
        # Проверяет, чтобы количество сторон соответствовало sides_count.
        if len(new_sides) == self.sides_count:
            self.__sides = list(new_sides)
            return self.__sides
        return self.__sides


# Класс для круга, наследуется от Figure
class Circle(Figure):
    sides_count = 1  # У круга считается только одна сторона (диаметр).

    def __init__(self, __color, *__sides):
        # Конструктор класса. Передаём цвет и диаметр в родительский класс.
        super().__init__(__color, __sides)  # Вызываем конструктор Figure.
        super().check()  # Проверяем корректность количества сторон.
        storona = __sides[0]  # Извлекаем первую сторону (диаметр круга).
        self.__radius = int(storona) * 3.14 / 1  # Вычисляем радиус.

    def get_square(self):
        # Метод возвращает площадь круга (π * r²).
        sq = 3.14 * self.__radius ** 2
        return sq


# Класс для треугольника, наследуется от Figure
class Triangle(Figure):
    sides_count = 3  # У треугольника всегда три стороны.

    def __init__(self, __color, *__sides):
        # Конструктор класса. Передаём цвет и длины сторон в родительский класс.
        super().__init__(__color, __sides)
        super().check()  # Проверяем корректность количества сторон.

    def get_square(self):
        # Метод возвращает площадь треугольника по формуле Герона.
        p = (self.__sides[0] + self.__sides[1] + self.__sides[2]) / 2  # Полупериметр.
        s = math.sqrt(p * (p - self.__sides[0]) * (p - self.__sides[1]) * (p - self.__sides[2]))  # Площадь.
        return s


# Класс для куба, наследуется от Figure
class Cube(Figure):
    sides_count = 12  # У куба 12 рёбер.

    def __init__(self, __color, *__sides):
        # Конструктор класса. Принимает цвет и длину стороны куба.
        x = len(__sides)  # Определяем количество переданных сторон.
        if x == 1:
            # Если передана одна сторона, создаём список из 12 одинаковых сторон.
            self.__sides = list(__sides)
            for i in self.__sides:
                self.__sides = []
                l = 0
                while l < self.sides_count:
                    self.__sides.append(i)
                    l += 1
                super().__init__(__color, self.__sides)
        else:
            # Если передано больше сторон, используем их напрямую.
            super().__init__(__color, __sides)
            super().check()

    def get_volume(self):
        # Метод возвращает объём куба (ребро³).
        return self.__sides[0] ** 3


# Примеры использования:
# Создаём круг с цветом (200, 200, 100) и диаметром 10.
circle1 = Circle((200, 200, 100), 10)
# Создаём куб с цветом (222, 35, 130) и длиной ребра 6.
cube1 = Cube((222, 35, 130), 6)
# Изменяем цвет круга.
circle1.set_color(55, 66, 77)
print(circle1.get_color())  # Новый цвет круга.
# Пытаемся установить некорректный цвет куба.
cube1.set_color(300, 70, 15)
print(cube1.get_color())  # Цвет куба не изменился.
# Пытаемся установить некорректные стороны для куба.
cube1.set_sides(5, 3, 12, 4, 5)
print(cube1.get_sides())  # Стороны куба не изменились.
# Устанавливаем новую сторону круга.
circle1.set_sides(15)
print(circle1.get_sides())
# Выводим периметр круга.
print(len(circle1))
# Выводим объём куба.
print(cube1.get_volume())
# Выводим площадь круга.
print(circle1.get_square())
print('------------------------------------')
circle2 = Circle((200, 200, 100), 15, 10)
print(circle2.get_sides())
triangle = Triangle((200, 200, 100), 10, 6)
print(triangle.get_sides())
cube2 = Cube((200, 200, 100), 9)
print(cube2.get_sides())
print(cube2.get_volume())
cube3 = Cube((200, 200, 100), 12)
print(cube3.get_sides())
print(cube3.get_volume())
print(cube3.__len__())

'''Строки байты и кодировка'''
# === Работа с таблицей ASCII ===
# ASCII (American Standard Code for Information Interchange) содержит символы с числовыми кодами от 0 до 127.

# Пример: используя функцию `ord`, мы можем получить числовой код символа.
print(ord('h'))  # Вывод: 104 (числовое представление символа 'h' в таблице ASCII)

# Преобразование строки в список числовых кодов ASCII.
a = 'hello'
chars = []
for i in a:
    chars.append(ord(i))
print(chars)  # Вывод: [104, 101, 108, 108, 111]

# Синтаксис функции `ord`:
# ord(char: str) -> int
# Возвращает числовой код символа в Unicode (или ASCII, если символ в пределах ASCII).
# Параметр:
# - `char` (str): одиночный символ.
# Возвращает:
# - (int): числовой код символа.

# === Работа с функцией chr ===
# Чтобы преобразовать числовой код обратно в символ, используем функцию `chr`.
print(chr(104))  # Вывод: 'h'

# Восстановление строки из списка числовых кодов.
s = ''
for i in chars:
    s += chr(i)
print(s)  # Вывод: 'hello'

# Синтаксис функции `chr`:
# chr(code: int) -> str
# Возвращает символ, соответствующий числовому коду.
# Параметр:
# - `code` (int): числовой код символа (в пределах Unicode).
# Возвращает:
# - (str): символ.

# === Вывод всех символов таблицы ASCII ===
for i in range(128):
    print(chr(i), end=' ')  # Вывод всех символов таблицы ASCII от 0 до 127.

# === Работа с таблицей Unicode ===
# Unicode — это универсальный стандарт кодирования символов, включающий более 2 миллионов символов.
# Охватывает символы множества языков, а также специальные и технические символы.

# Пример вывода первых 1500 символов Unicode.
for i in range(1, 1500):
    print(chr(i), end=' ')  # Вывод символов с кодами от 1 до 1499.

# === Работа с байтами ===
# Байты (тип данных `bytes`) — это представление строк или символов в двоичном (или шестнадцатеричном) формате.
bb = b''  # Создание пустого объекта типа `bytes`.

# Пример работы с символом «h».
# Используем функцию `ord` для получения числового кода символа.
# Затем преобразуем его в шестнадцатеричный формат с помощью функции `hex`.
print(hex(ord('h')))  # Вывод: '0x68' (шестнадцатеричное представление кода символа 'h')

# Создание байтовой строки.
bb = b'\x68'  # Префикс `\x` обозначает шестнадцатеричный формат. Код '0x68' символа 'h' записан как '\x68'.
print(type(bb))  # Вывод: <class 'bytes'> (тип данных — байты)
print(bb)        # Вывод: b'h' (байтовое представление символа 'h')

# Если вы хотите выполнить декодирование (преобразование из bytes обратно в строку),
# нужно явно вызвать метод `.decode()`:
decoded = bb.decode()
print(decoded)  # Вывод: 'h' (декодированный символ)

# Декодирование байтов полезно, когда вам нужно работать с текстовым представлением данных,
# изначально сохранённых в формате байтов.

# === Дополнительная информация о методах encode и decode ===
# Метод `encode`:
#   Синтаксис: `str.encode(encoding="utf-8", errors="strict")`
#   Описание: Преобразует строку в байты с использованием указанной кодировки (по умолчанию UTF-8).
#   Аргументы:
#     - `encoding` (str, необязательный):
#         Кодировка, используемая для преобразования строки в байты.
#         По умолчанию используется 'utf-8'.
#         Примеры кодировок: 'ascii', 'utf-16', 'latin-1', и другие.
#     - `errors` (str, необязательный):
#         Способ обработки ошибок при преобразовании:
#         - 'strict' (по умолчанию): выбрасывает исключение при ошибке.
#         - 'ignore': игнорирует символы, которые нельзя закодировать.
#         - 'replace': заменяет некорректные символы на '?' или другой маркер.
#   Возвращает: Объект типа `bytes`.

# Метод `decode`:
#   Синтаксис: `bytes.decode(encoding="utf-8", errors="strict")`
#   Описание: Преобразует объект `bytes` в строку с использованием указанной кодировки (по умолчанию UTF-8).
#   Аргументы:
#     - `encoding` (str, необязательный):
#         Кодировка, используемая для декодирования байтов.
#         По умолчанию используется 'utf-8'.
#         Примеры кодировок: 'ascii', 'utf-16', 'latin-1', и другие.
#     - `errors` (str, необязательный):
#         Способ обработки ошибок при преобразовании:
#         - 'strict' (по умолчанию): выбрасывает исключение при ошибке.
#         - 'ignore': игнорирует символы, которые нельзя декодировать.
#         - 'replace': заменяет некорректные символы на '?' или другой маркер.
#   Возвращает: Объект типа `str`.

# Пример кодирования и декодирования строки:
utf8_string = 'Привет, мир!'  # Строка на русском языке.
utf8_bytes = utf8_string.encode('utf-8')  # Кодируем строку в байты.
print(utf8_bytes)  # Вывод: b'\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82, \xd0\xbc\xd0\xb8\xd1\x80!'

# Декодирование обратно в строку.
decoded_string = utf8_bytes.decode('utf-8')
print(decoded_string)  # Вывод: 'Привет, мир!'

# === Кодировка UTF-8 ===
# UTF-8 (8-битная форма преобразования Unicode) совместима с ASCII:
# - Символы ASCII занимают 1 байт.
# - Символы, выходящие за пределы ASCII, занимают 2–4 байта.
# UTF-8 широко используется благодаря поддержке всех символов Unicode и экономии памяти.



# === Работа с файлами: режимы открытия и основные операции ===
# Модуль pprint используется для красивого вывода данных.
from pprint import pprint

# === Открытие файла для чтения ===
# Синтаксис функции `open`:
# open(file: str, mode: str, buffering: int = -1, encoding: Optional[str] = None,
#      errors: Optional[str] = None, newline: Optional[str] = None, closefd: bool = True, opener: Optional[Callable] = None) -> TextIO
#
# Параметры:
# - file: (str) имя файла.
# - mode: (str) режим открытия. Основные режимы:
#   - 'r': чтение (по умолчанию).
#   - 'w': запись (перезаписывает файл или создаёт новый).
#   - 'a': добавление (добавляет содержимое в конец файла).
#   - 'b': открытие в бинарном режиме.
# - encoding: (str) кодировка (например, 'utf-8', 'ascii').

# Открываем файл sample.txt в режиме чтения ('r').
name = 'sample.txt'
file = open(name, 'r')  # Режимы: r (чтение), w (запись), a (добавление)

# Чтение содержимого файла
pprint(file.read())  # Обратите внимание: строки содержат символ переноса '\n'.

# Проверка текущей позиции указателя чтения
print(file.tell())  # Метод `tell()` возвращает текущую позицию указателя в файле.

# Перемещение указателя на позицию 75
file.seek(75)  # Метод `seek(offset, whence)` перемещает указатель на заданную позицию.
pprint(file.read())  # Читаем файл с новой позиции

# Закрытие файла
file.close()
# Почему важно закрывать файл?
# - Некоторые изменения могут не сохраниться до закрытия файла.
# - Незакрытые файлы могут повлиять на работу сборщика мусора и занять лимит открытых файлов ОС.
# - Закрытие предотвращает утечку ресурсов.

# === Открытие файла в режиме записи ===
# Режим 'w' перезаписывает файл при каждом открытии. Если файл не существует, он будет создан.
name2 = 'sample2.txt'
file2 = open(name2, 'w')

# В режиме записи (w) файл доступен только для записи. Попытка чтения вызовет ошибку:
# file2.read()  # Ошибка

# Запись строки в файл
file2.write('privet, 3to wtitten - zapis')

# Закрытие файла
file2.close()

# === Открытие файла в режиме добавления ('a') ===
# В этом режиме новые данные добавляются в конец файла, не перезаписывая его содержимое.
file = open(name, 'a')
file.write('\nhello world1')  # Добавление новой строки в конец файла
file.close()

# === Работа с бинарными файлами ===
# Для работы с бинарными файлами добавляем 'b' к режиму.
# Например, режим 'ab' используется для добавления данных в бинарном формате.
file = open(name, 'ab')  # Открытие файла для записи в бинарном формате
# file.write(b'\nBinary Data')  # Запись бинарных данных
file.close()

# === Режимы открытия файлов ===
# 1. 'r': чтение (по умолчанию, файл должен существовать).
# 2. 'w': запись (файл создаётся, если его нет; существующий файл перезаписывается).
# 3. 'a': добавление (файл создаётся, если его нет; добавление к существующему содержимому).
# 4. 'b': бинарный режим (добавляется к другим режимам, например, 'rb', 'wb', 'ab').
# 5. 'r+': чтение и запись (файл должен существовать).
# 6. 'w+': чтение и запись (перезаписывает файл, если существует).
# 7. 'a+': чтение и добавление (файл создаётся, если его нет).

# === Часто используемые методы для работы с файлами ===
# file.read(size=-1) -> str
#   Читает содержимое файла. Если указан `size`, читает заданное количество символов.

# file.readline(size=-1) -> str
#   Читает одну строку из файла. Если указан `size`, читает не более указанного количества символов.

# file.readlines(hint=-1) -> list[str]
#   Читает все строки из файла и возвращает их в виде списка.

# file.write(s: str) -> int
#   Записывает строку `s` в файл. Возвращает количество записанных символов.

# file.writelines(lines: list[str])
#   Записывает последовательность строк в файл.

# file.seek(offset: int, whence: int = 0) -> int
#   Перемещает указатель на заданную позицию:
#   - offset: смещение.
#   - whence: начало отсчёта (0 — начало, 1 — текущая позиция, 2 — конец файла).

# file.tell() -> int
#   Возвращает текущую позицию указателя в файле.

# file.close()
#   Закрывает файл. Обязательно вызывать после завершения работы с файлом.

# === Советы по работе с файлами ===
# 1. Всегда закрывайте файл после работы с ним (`file.close()`).
# 2. Используйте конструкцию `with open` для автоматического закрытия файла:
#    with open('file.txt', 'r') as file:
#        data = file.read()
#    # Файл автоматически закроется после выхода из блока `with`.
# 3. Используйте правильные режимы открытия файлов в зависимости от задачи.
# 4. Для чтения/записи больших файлов используйте буферизацию или читайте/пишите по частям.

# === Пример использования `with open` ===
with open('sample.txt', 'r') as file:
    content = file.read()
    print(content)
# Файл закрывается автоматически после выхода из блока `with`.

# DZ 27
'Памятка: Как работают объекты, передаваемые через *args и доступ к их атрибутам'
# Класс Product представляет товар с его аттрибутами
class Product:
    # Конструктор класса, инициализирует объект с аттрибутами name, weight и category
    def __init__(self, name, weight, category):
        self.name = name  # Атрибут name — название продукта
        self.weight = weight  # Атрибут weight — вес продукта
        self.category = category  # Атрибут category — категория продукта

    # Метод __str__ возвращает строковое представление объекта для удобного вывода
    def __str__(self):
        return f'{self.name}, {self.weight}, {self.category}'  # Возвращает строку вида: 'Potato, 50.5, Vegetables'

    # Метод __repr__ возвращает строку, представляющую объект, также для отладки
    def __repr__(self):
        return f'{self.name}, {self.weight}, {self.category}'  # Строка в том же формате


# Класс Shop представляет магазин, в котором хранятся товары (объекты класса Product)
class Shop:
    __file_name = 'product.txt'  # Имя файла, в котором будут храниться данные о товарах

    # Метод для получения всех продуктов, сохраненных в файле
    def get_products(self):
        file = open(self.__file_name, 'r')  # Открываем файл для чтения ('r' — режим чтения)
        rfile = file.read()  # Читаем все содержимое файла в одну строку
        file.close()  # Закрываем файл после чтения
        return rfile  # Возвращаем строку с данными всех продуктов

    # Метод для добавления новых продуктов в магазин
    def add(self, *other):
        existing_products = self.get_products()  # Получаем строку с существующими продуктами из файла

        # Цикл проходит по всем переданным объектам продуктов
        for i in other:  # *other — это кортеж, содержащий все переданные объекты (например, p1, p2, p3)
            # Пояснение к циклу:
            # Каждый элемент в `other` — это объект, переданный в метод add.
            # На каждой итерации переменная `i` будет ссылаться на текущий объект из кортежа `other`.
            # Например, если *other содержит p1, p2, p3, то `i` по очереди принимает значения p1, затем p2, затем p3.
            # Поскольку элементы `other` — это объекты класса Product (например, p1 или p2),
            # переменная `i` имеет доступ ко всем атрибутам класса Product через точечную нотацию,
            # такие как `i.name`, `i.weight`, и `i.category`.
            # Это позволяет безопасно работать с каждым объектом и его данными внутри цикла.

            # Проверяем, является ли текущий объект экземпляром класса Product
            if isinstance(i, Product):
                # Эта строка проверяет, является ли текущий объект (i) экземпляром класса Product.
                # Это важно, так как метод add может принимать любые объекты (не только Product).
                # Проверка isinstance гарантирует, что объект имеет доступ к атрибутам name, weight, и category.
                # Если объект не принадлежит классу Product, доступ к его атрибутам приведет к ошибке.
                # Таким образом, эта проверка защищает от непредвиденных ошибок в коде.

                # Проверяем, если имя текущего продукта (i.name) уже есть в строках существующих продуктов
                if i.name in existing_products:
                    print(
                        f'Продукт {i.name} уже есть в магазине')  # Если такой продукт уже существует, выводим сообщение
                else:
                    # Если продукт с таким именем ещё не существует, добавляем его в файл
                    file = open(self.__file_name, 'a')  # Открываем файл в режиме добавления ('a')
                    file.write(f'{i.name}, {i.weight}, {i.category}\n')  # Записываем информацию о продукте в файл
                    file.close()  # Закрываем файл
                    print(f'Продукт {i.name} добавлен в магазин')  # Выводим сообщение о добавлении товара
            else:
                # Если объект не является экземпляром Product, выводим предупреждение
                print(f'Объект {i} не является продуктом!')


# Создаем объект магазина
s1 = Shop()

# Создаем несколько объектов продуктов
p1 = Product('Potato', 50.5, 'Vegetables')  # Продукт с названием 'Potato', весом 50.5 и категорией 'Vegetables'
p2 = Product('Spaghetti', 3.4, 'Groceries')  # Продукт с названием 'Spaghetti', весом 3.4 и категорией 'Groceries'
p3 = Product('Potato', 5.5, 'Vegetables')  # Продукт с названием 'Potato', но с другим весом

print(p2)  # Выводим строковое представление объекта p2 с помощью __str__ метода

# Добавляем продукты в магазин
s1.add(p1, p2, p3)

# После добавления выводим все продукты, сохраненные в файле
print(s1.get_products())

import io  # Импортируем модуль io для работы с потоками ввода/вывода.
#from pprint import pprint  # Импортируем pprint для более читаемого вывода данных. уже импортирована#

# Открываем файл 'sample2.txt' в режиме чтения ('r') с использованием кодировки 'utf-8'.
name = 'sample2.txt'
file = open(name, 'r', encoding='utf-8')

# === Информация о методах файла ===
# Метод .writable() возвращает True, если файл открыт для записи, иначе False.
print(file.writable())  # Вывод: False (файл открыт только для чтения).

# Метод .readable() возвращает True, если файл открыт для чтения, иначе False.
print(file.readable())  # Вывод: True (файл открыт для чтения).

# Метод .seekable() возвращает True, если файл поддерживает установку положения курсора (позиционирование).
print(file.seekable())  # Вывод: True (текстовые файлы обычно поддерживают перемещение курсора).

# === Информация о файле ===
# Атрибут .name возвращает имя файла.
print(file.name)  # Вывод: sample2.txt (имя открытого файла).

# Атрибут .buffer возвращает низкоуровневый буфер ввода-вывода для файла.
# Полезен для работы с бинарными данными или для дополнительной оптимизации.
print(file.buffer)  # Вывод: <_io.BufferedReader name='sample2.txt'>.

# Метод .close() закрывает файл и освобождает все связанные с ним ресурсы.
# После вызова этого метода операции с файлом становятся невозможными.
print(file.close())  # Вывод: None (файл успешно закрыт).

# === Управление курсором в файле ===
# Метод .tell() возвращает текущую позицию курсора в файле.
# Позиция измеряется в байтах с начала файла.
print(file.tell())  # Вывод: Позиция курсора в байтах (обычно 0 для только что открытого файла).

# Метод .read() считывает содержимое файла.
# Если указать параметр (int), считывается указанное количество символов.
pprint(file.read())  # Вывод: содержимое файла 'sample2.txt'.

# Метод .tell() снова показывает текущую позицию курсора после чтения.
print(file.tell())  # Вывод: позиция в байтах (будет равна размеру файла после чтения до конца).

# Закрываем файл, чтобы освободить ресурсы и предотвратить утечки.
file.close()

# === Дополнительная информация о функциях ===
# .writable():
# - Синтаксис: file.writable() -> bool
# - Возвращает True, если файл открыт в режимах записи ('w', 'a', 'r+', и т.д.).
# - Если файл открыт в режиме только для чтения ('r'), возвращает False.

# .readable():
# - Синтаксис: file.readable() -> bool
# - Возвращает True, если файл открыт в режимах чтения ('r', 'r+', и т.д.).
# - Если файл открыт в режиме только для записи ('w', 'a'), возвращает False.

# .seekable():
# - Синтаксис: file.seekable() -> bool
# - Возвращает True, если поддерживается управление положением курсора.
# - Например, текстовые и бинарные файлы поддерживают seek, но сетевые потоки нет.

# .tell():
# - Синтаксис: file.tell() -> int
# - Возвращает текущее положение курсора в файле.
# - Полезно для контроля чтения и записи в файлах.

# .read():
# - Синтаксис: file.read(size=-1) -> str или bytes
# - Читает и возвращает содержимое файла.
# - Если `size` указан, читается указанное количество символов (или байтов, если файл бинарный).
# - Если `size=-1` (по умолчанию), читается весь файл.

# .close():
# - Синтаксис: file.close() -> None
# - Закрывает файл и освобождает все ресурсы.
# - После вызова метода файл становится недоступен.

# DZ 28
def custom_write(file_name, strings):
    """
    Функция записывает строки в файл с сохранением их позиций.

    Синтаксис:
    custom_write(file_name: str, strings: list) -> dict

    Аргументы:
    - file_name (str): Имя файла для записи.
    - strings (list): Список строк для записи.

    Возвращает:
    - dict: Словарь с позицией курсора и индексом строки в качестве ключей, а строкой в качестве значения.

    Описание работы:
    - Открывает файл в режиме добавления ('a') с кодировкой 'utf-8'.
    - Записывает каждую строку в файл, добавляя символ новой строки (`\n`) в конце.
    - Использует метод `tell()` для сохранения позиции курсора перед записью каждой строки.
    - Возвращает словарь с позициями курсора и индексами строк.
    """
    file = open(file_name, 'a', encoding='utf-8')  # Открываем файл в режиме добавления с кодировкой UTF-8.
    strings_positions = {}  # Словарь для хранения позиций курсора и записанных строк.
    x = 0  # Индекс строки (начинаем с 0).

    for i in strings:
        t1 = file.tell()  # Получаем текущую позицию курсора в байтах перед записью строки.
        file.write(f'{i}\n')  # Записываем строку в файл, добавляя символ новой строки '\n'.
        # Обновляем словарь: ключ — кортеж из индекса строки и позиции курсора, значение — строка.
        strings_positions.update({(x, t1): i})
        x += 1  # Увеличиваем индекс для следующей строки.

    file.close()  # Закрываем файл, освобождая ресурсы.
    return strings_positions  # Возвращаем словарь с информацией о записях.


# Список строк для записи в файл.
info = [
    'Text for tell.',  # Пример текста на английском.
    'Используйте кодировку utf-8.',  # Пример текста на русском.
    'Because there are 2 languages!',  # Ещё одна строка на английском.
    'Спасибо!'  # Русский текст.
]

# Вызываем функцию custom_write и сохраняем результат в переменную result.
result = custom_write('test.txt', info)

# Выводим содержимое словаря result (позиций и строк).

# Одна переменная (работа с кортежем):
for item in result.items():
    print(f"Целый кортеж: {item}")

# Две переменные (распаковка ключа и значения):
for key, value in result.items():
    print(f"Ключ: {key}, Значение: {value}")

### Итог:
# Одна переменная: возвращает кортеж (ключ, значение).
# Две переменные: распаковывают кортеж на ключ и значение отдельно ###



# Имя файла для работы #
name = 'sample2.txt'

# Открываем файл в кодировке utf-8
# Используем контекстный менеджер (with) - (рус-с), который автоматически закрывает файл после завершения работы.
with open(name, encoding='utf-8') as file:
    # Чтение файла построчно
    for line in file:  # Итерация по каждой строке в файле. Переменная `line` содержит текущую строку.
        for char in line:  # Итерация по каждому символу строки. Переменная `char` содержит текущий символ.
            print(char, end='')  # Вывод символа без добавления новой строки (end='')

    # Печатаем текущую позицию курсора в файле
    print(file.tell())

# === Объяснение кода ===
# - `with open(name, encoding='utf-8') as file`:
#   Синтаксис:
#   `with open(file: str, mode: str = 'r', encoding: Optional[str] = None) -> IO[str]`
#   - Открывает файл с указанным именем `name` в режиме по умолчанию ('r' - чтение).
#   - `encoding='utf-8'` указывает, что файл следует читать в кодировке UTF-8.
#   - Контекстный менеджер автоматически закрывает файл после выхода из блока `with`,
#     даже если внутри блока возникнет ошибка.

# DZ 29
# === Класс WordsFinder ===
# Класс для поиска, подсчёта и анализа слов в текстовых файлах.
class WordsFinder:
    file_names = []  # Класс-атрибут: хранит список имён файлов для анализа.

    def __init__(self, *args):
        # Конструктор принимает список имён файлов.
        self.args = 'args.txt'  # Внутренний атрибут для хранения имени файла по умолчанию (не используется).
        for i in args:
            self.file_names.append(i)  # Добавляем имена файлов в список file_names.

    def get_all_words(self):
        """
        Синтаксис: get_all_words() -> dict
        Возвращает словарь, где ключ — имя файла, значение — список всех слов в этом файле.
        """
        all_words = {}  # Словарь для хранения всех слов по каждому файлу.
        slova = []  # Временный список для хранения слов из текущего файла.
        for i in self.file_names:  # Проходим по каждому имени файла в file_names.
            with open(i, encoding='utf-8') as file:  # Открываем файл в режиме чтения с кодировкой UTF-8.
                for line in file:  # Читаем файл построчно.
                    line = line.lower()  # Приводим строку к нижнему регистру.
                    for pp in [',', '.', '=', '!', '?', ';', ':', ' - ']:
                        # Заменяем символы пунктуации на пустую строку.
                        if pp in line:
                            line = line.replace(pp, '')
                    for st in line.split():  # Разбиваем строку на слова.
                        slova.append(st)  # Добавляем слова в список.
                    all_words[i] = slova  # Обновляем словарь: ключ — имя файла, значение — список слов.
            return all_words  # Возвращаем словарь всех слов.

    def find(self, word):
        """
        Синтаксис: find(word: str) -> dict | None
        Возвращает словарь с именем файла и позицией слова, если найдено.
        Если слово не найдено, возвращает None.
        """
        find_list = {}  # Словарь для хранения результата поиска.
        x = 1  # Счётчик для определения позиции слова.
        all_words = self.get_all_words()  # Вызываем метод get_all_words и сохраняем его результат.
        for name, words in all_words.items():  # Итерируемся по файлам и спискам слов.
            for i in words:  # Проверяем каждое слово в списке.
                if word.lower() == i.lower():  # Если слово совпало (без учёта регистра).
                    find_list[name] = x  # Добавляем имя файла и позицию слова в словарь.
                    return find_list  # Возвращаем результат.
                else:
                    x += 1  # Увеличиваем позицию, если слово не найдено.

    def count(self, word):
        """
        Синтаксис: count(word: str) -> dict
        Возвращает словарь с именем файла и количеством вхождений слова.
        """
        count_list = {}  # Создаём пустой словарь для хранения количества вхождений слов по каждому файлу.
        all_words = self.get_all_words()  # Вызываем метод get_all_words и сохраняем его результат (словарь: имя файла -> список слов).
        for name, words in all_words.items():  # Итерируемся по словарю: имя файла и список слов.
            x = 0  # Обнуляем счётчик вхождений для текущего файла.
            for i in words:  # Проверяем каждое слово в списке `words`.
                if word.lower() == i.lower():  # Если слово совпадает с `word` (без учёта регистра).
                    x += 1  # Увеличиваем счётчик вхождений.
                    count_list[name] = x  # Добавляем пару (имя файла, количество вхождений) в словарь.
                    # Разница:
                    # count_list = {name: x} - создаёт новый словарь на каждой итерации цикла,
                    # где в словаре будет только одна пара ключ-значение (имя файла: количество вхождений).
                    # Этот подход заменяет весь словарь на новый на каждой итерации, что не является правильным.

                    # count_list[name] = x - добавляет или обновляет запись в существующем словаре.
                    # Если ключ (имя файла) уже есть в словаре, его значение обновляется на новое количество вхождений (x).
                    # Если ключа нет, добавляется новая пара: имя файла как ключ и количество вхождений как значение.
                    # Пример обновления:
                    # Если name = 'file1.txt' и x = 3, то count_list станет {'file1.txt': 3}.
                    # Если далее name = 'file2.txt' и x = 2, то count_list обновится: {'file1.txt': 3, 'file2.txt': 2}.
        return count_list  # Возвращаем словарь `count_list` с результатами для всех файлов.

# === Пример использования ===
finder2 = WordsFinder('test_file.txt')  # Создаём объект класса WordsFinder с файлом 'test_file.txt'.
print(finder2.get_all_words())  # Выводим все слова из файлов.
print(finder2.find('TEXT'))  # Ищем слово 'TEXT' и выводим его позицию.
print(finder2.count('teXT'))  # Считаем количество вхождений слова 'teXT'.

print('Привет, ' + 'мир')
# Используется конкатенация строк с помощью оператора +.
# Строки "Привет, " и "мир" объединяются в одну строку.
# Вывод: Привет, мир

print('Меня зовут %s' % 'Илья')
# Используется старый способ форматирования строк с оператором %.
# %s вставляет строку "Илья" в указанное место.
# Вывод: Меня зовут Илья

print('Меня зовут %s, мне %s' % ('Илья', 24))
# Форматирование с несколькими переменными через %.
# %s заменяется на соответствующие значения в кортежах ('Илья', 24).
# Вывод: Меня зовут Илья, мне 24

print('Меня зовут %(name)s, мне %(year)s' % {'name': 'Илья', 'year': 24})
# Форматирование с использованием словаря.
# Указывается имя ключа в скобках %(key)s, которое заменяется значением из словаря.
# Вывод: Меня зовут Илья, мне 24

print('Я учусь в {} {}'.format('Урбан -', 'University'))
# Метод .format() подставляет значения в фигурные скобки {} по порядку.
# В первом {} вставляется 'Урбан -', во втором {} — 'University'.
# Вывод: Я учусь в Урбан - University

print('Я учусь в {0} {1} {0}'.format('Урбан -', 'University'))
# Использование индексов в методе .format().
# {0} означает первый аргумент, {1} — второй. {0} повторяется дважды.
# Вывод: Я учусь в Урбан - University Урбан -

print('Я учусь в {title} {postfix} {title}'.format(title='Урбан -', postfix='University'))
# Метод .format() с именованными аргументами.
# {title} заменяется на 'Урбан -', а {postfix} — на 'University'.
# Вывод: Я учусь в Урбан - University Урбан -

print(f'{"Urban" * 2} это лучший университет!')
# Используется f-строка (f-string) для форматирования строк (Python 3.6+).
# Выражение {"Urban" * 2} вычисляется, умножая строку 'Urban' на 2.
# Вывод: UrbanUrban это лучший университет!

# DZ 30
# Программа для анализа и сравнения результатов двух команд в соревновании.

team1_num = 5  # Количество участников в команде "Мастера кода".
team2_num = 6  # Количество участников в команде "Волшебники данных".
score_1 = 40  # Количество решённых задач командой "Мастера кода".
score_2 = 42  # Количество решённых задач командой "Волшебники данных".
team1_time = 1552.512  # Общее время выполнения задач командой "Мастера кода" (в секундах).
team2_time = 2153.31451  # Общее время выполнения задач командой "Волшебники данных" (в секундах).

# === Условие для определения победителя ===
if score_1 > score_2 or score_1 == score_2 and team1_time > team2_time:
    # Если команда "Мастера кода" набрала больше очков,
    # либо если количество очков равно, но команда "Мастера кода" затратила больше времени:
    challenge_result = 'Победа команды Мастера кода!'  # Результат соревнования для команды "Мастера кода".
elif score_1 < score_2 or score_1 == score_2 and team1_time < team2_time:
    # Если команда "Волшебники данных" набрала больше очков,
    # либо если количество очков равно, но команда "Волшебники данных" затратила меньше времени:
    challenge_result = 'Победа команды Волшебники Данных!'  # Результат соревнования для команды "Волшебники данных".
else:
    # Если счёт и время выполнения задач совпадают:
    challenge_result = 'Ничья!'  # Результат, если команды завершили соревнование с одинаковыми показателями.

# === Вывод информации о командах и результатах ===
print('В команде Мастера кода участников: %s' % team1_num)
# Вывод количества участников команды "Мастера кода" с использованием старого форматирования строк.

print('Итого сегодня в командах участников: %s и %s' % (team1_num, team2_num))
# Вывод общего количества участников обеих команд.

print('Команда волшебников данных решила задач: {}'.format(score_2))
# Вывод количества задач, решённых командой "Волшебники данных", с использованием метода `format`.

print('Волшебники данных решили задачи за {}'.format(round(team2_time, 1)))
# Вывод времени, затраченного командой "Волшебники данных", округлённого до одного знака после запятой.

print(f'Команды решили {score_1} и {score_2} задач.')
# Вывод количества задач, решённых обеими командами, с использованием f-строк.

print(f'Результат битвы: {challenge_result}')
# Вывод результата соревнования (победитель или ничья).

print(f'Сегодня было решено {score_2 + score_1} задач, в среднем по { (team1_time + team2_time) / (score_2 + score_1):.2f} секунды на задачу')
# Вывод общего количества задач и среднего времени, затраченного на решение одной задачи.
# Используется f-строка с округлением среднего времени до двух знаков после запятой.

# === Синтаксис используемых методов и функций ===
# 1. round(number, ndigits):
#    - Округляет `number` до `ndigits` знаков после запятой.
#    - Аргументы:
#      - number (float): число для округления.
#      - ndigits (int): количество знаков после запятой (опционально).
#    - Возвращает округлённое число.

# 2. format():
#    - Синтаксис: 'строка с {} для вставки'.format(*args, **kwargs)
#    - Заменяет `{}` в строке на значения аргументов, переданных в метод.
#    - Пример: '{} + {} = {}'.format(2, 3, 5) → '2 + 3 = 5'.

# 3. f-строки:
#    - Синтаксис: f'строка с {переменная/выражение}'
#    - Позволяет встраивать значения переменных или выражений внутрь строк.
#    - Пример: f'Сумма: {2 + 3}' → 'Сумма: 5'.

'''OS MODULE - Функции для работы с операционной системой'''


import os  # Подключаем модуль os для работы с операционной системой.

# === Текущая директория ===
# os.getcwd() - возвращает текущую рабочую директорию.
print('Текущая директория:', os.getcwd())

# === Проверка существования директории ===
# os.path.exists(path: str) -> bool
# Проверяет, существует ли путь "path". Возвращает True, если существует, иначе False.
if os.path.exists('second'):
    # === Смена рабочей директории ===
    # os.chdir(path: str) -> None
    # Изменяет текущую рабочую директорию на указанную "path".
    os.chdir('second')
else:
    # === Создание новой директории ===
    # os.mkdir(path: str) -> None
    # Создаёт каталог по указанному пути "path".
    os.mkdir('second')
    os.chdir('second')

# Вывод текущей рабочей директории
print('Текущая директория:', os.getcwd())

# === Создание вложенных директорий ===
# os.makedirs(name: str) -> None
# Создаёт указанный путь, включая промежуточные каталоги.
# os.makedirs(r'third\fours')  # r указывает, что это "сырая" строка, экранировать символы \ не нужно.

# === Список файлов и папок в директории ===
# os.listdir(path: str = '.') -> list[str]
# Возвращает список файлов и каталогов в указанной директории (по умолчанию текущая).
print(os.listdir())

# === Рекурсивный обход директории ===
# os.walk(top: str) -> Iterator[Tuple[str, list[str], list[str]]]
# Рекурсивно обходит директорию "top", возвращая кортежи (root, dirs, files).
for i in os.walk('.'):
    print(i)

# === Переход в указанную директорию ===
os.chdir(r'D:\PythonProject\SchoolUrban\open_file')
print('Текущая директория:', os.getcwd())
print(os.listdir())

# === Генерация списка файлов ===
# os.path.isfile(path: str) -> bool
# Проверяет, является ли указанный путь файлом.
file = [f for f in os.listdir() if os.path.isfile(f)]

# === Генерация списка папок ===
# os.path.isdir(path: str) -> bool
# Проверяет, является ли указанный путь директорией.
dirs = [d for d in os.listdir() if os.path.isdir(d)]
print(file)
print(dirs)

# === Открытие файла ===
# os.startfile(filepath: str) -> None
# filepath: строка, представляющая путь к файлу. Это может быть:
# Имя файла (если файл находится в текущей рабочей директории).
# Полный путь к файлу (если файл находится в другой директории).
# Открывает файл или программу, как если бы вы двойным щелчком нажали на него в проводнике.
os.startfile(file[8])
# Откроет файл "example.txt", если он есть в текущей директории.
# os.startfile('example.txt')
# Указывает полный путь.
# os.startfile(r'C:\Users\User\Documents\example.txt')

# === Информация о файле ===
# os.stat(path: str) -> os.stat_result
# Возвращает информацию об указанном пути, например, размер файла, время последнего изменения и т. д.
print(os.stat(file[3]))

# === Размер файла ===
# os.stat_result.st_size
# Атрибут, возвращающий размер файла в байтах.
print(os.stat(file[3]).st_size)

# === Выполнение системной команды ===
# os.system(command: str) -> int
# Выполняет системную команду "command". Возвращает код завершения команды.
# os.system('pip install auto-py-to-exe')

# DZ 31
import time

# === Переменная directory ===
# Переменная `directory` указывает начальную директорию для обхода.
# Значение `'.'` означает текущую рабочую директорию.
directory = '.'

# === os.walk ===
# Синтаксис: os.walk(top: str) -> Iterator[Tuple[str, list[str], list[str]]]
# Возвращает генератор, который обходит все поддиректории и файлы в указанной директории `top`.
# На каждой итерации возвращает кортеж `(root, dirs, files)`.
# - `root` (str): путь к текущей директории.
# - `dirs` (list[str]): список директорий в текущей директории `root`.
# - `files` (list[str]): список файлов в текущей директории `root`.

for root, dirs, files in os.walk(directory):
    # root: текущая директория, которая в данный момент обрабатывается.
    # print(root)  # Выводит полный путь текущей директории.

    # dirs: список директорий внутри текущей директории `root`.
    # print(dirs)  # Выводит имена всех поддиректорий внутри `root`.

    # files: список файлов внутри текущей директории `root`.
    # print(files)  # Выводит имена всех файлов внутри `root`.

    for file in files:
        # === os.path.join ===
        # Синтаксис: os.path.join(path: str, *paths: str) -> str
        # Объединяет один или несколько компонентов пути в строку.
        # В данном случае объединяет `root` (директория) и `file` (имя файла),
        # чтобы получить полный путь к файлу.
        filepath = os.path.join(root, file)
        # print(filepath)  # Выводит полный путь к текущему файлу.

        # === os.path.getmtime ===
        # Синтаксис: os.path.getmtime(path: str) -> float
        # Возвращает время последнего изменения файла в формате UNIX timestamp (в секундах).
        filetime = os.path.getmtime(filepath)

        # === time.strftime ===
        # Преобразует время из формата UNIX timestamp в строку по указанному формату.
        formatted_time = time.strftime("%d.%m.%Y.%H:%M", time.localtime(filetime))

        # === os.path.getsize ===
        # Синтаксис: os.path.getsize(path: str) -> int
        # Возвращает размер файла в байтах.
        filesize = os.path.getsize(filepath)

        # === os.path.dirname ===
        # Синтаксис: os.path.dirname(path: str) -> str
        # Возвращает путь родительской директории указанного пути.
        parent_dir = os.path.dirname(filepath)
        # print(parent_dir)  # Выводит путь родительской директории файла.

        # Вывод информации о текущем файле.
        print(f'Обнаружен файл: {file}, Путь: {filepath}, Размер: {filesize} байт, Время изменения: {formatted_time}, Родительская директория: {parent_dir}')



# === Ошибки в Python ===

## 1. Синтаксические ошибки
# Синтаксическая ошибка (SyntaxError) возникает, если код написан неправильно, например:
# - Пропущены кавычки.
# - Неправильно указана запятая или двоеточие.
# - Ошибка в конструкции цикла или блока кода.

# Пример синтаксической ошибки:
# test = '123test321
# print(test)

# **Traceback** - Трассировка
# Traceback — это отчёт об ошибке, который показывает цепочку вызовов, приведших к ошибке.
# Его ключевые элементы:
# - **Место ошибки**: строка, в которой возникла проблема, и полный путь к файлу.
# - **Тип ошибки**: класс ошибки, например `SyntaxError`.
# - **Описание ошибки**: указание причины, например `unterminated string literal`.

# Пример:
# SyntaxError: unterminated string literal (detected at line 5)
# ^
# Эта стрелка указывает на место, где произошла ошибка.

# Особенности **traceback**:
# - **Читать снизу вверх**: первопричина ошибки обычно находится в конце отчета.
# - Указывает строку и тип ошибки для быстрой диагностики.

# Исправление:
# ```python
# test = '123test321'  # Добавлена закрывающая кавычка.
# print(test)
# ```


## 2. Исключения (Exceptions)
# Исключения в Python наследуются от базового класса `BaseException`.
# `BaseException` — это общий класс для всех исключений, включая системные (`SystemExit`, `KeyboardInterrupt`) и пользовательские (`Exception`).

# Классы исключений:
# - **AssertionError**: Проверяет истинность утверждения (`assert`).
# - **AttributeError**: Возникает при попытке доступа к несуществующему атрибуту объекта.
# - **GeneratorExit**: Генератор закрывается через метод `close()`.
# - **ImportError**: Ошибка импорта модуля или его атрибута.


### 1. **AssertionError**
# Описание:
# Возникает, если условие в выражении `assert` ложно.
# Используется для тестирования и проверки логических предположений в программе.

# Синтаксис: assert - утверждать, заявляю
# ```python
# assert условие, сообщение
# ```
# Аргументы:
# - **условие** (bool): Логическое выражение, которое должно быть истинным.
# - **сообщение** (str, необязательный): Сообщение, которое будет выведено в случае ошибки.

# Пример:
x = 5
assert x > 10, "x должно быть больше 10"
# Вывод:
# AssertionError: x должно быть больше 10

# Когда использовать:
# - Для отладки и тестирования.
# - Для проверки внутренних предположений в коде.


### 2. **AttributeError**
# Описание:
# Возникает, если объект не имеет запрашиваемого атрибута.
# Чаще всего используется для проверки интерфейсов и корректности взаимодействия объектов.

# Пример:
class Example:
    pass

obj = Example()
try:
    obj.some_attribute  # Пробуем вызвать несуществующий атрибут.
except AttributeError as e:
    print(f"Ошибка: {e}")  # Вывод: AttributeError: 'Example' object has no attribute 'some_attribute'

# Когда возникает:
# - При вызове несуществующего метода или переменной объекта.


### 3. **GeneratorExit**
# Описание:
# Вызывается, когда генератор завершает работу через метод `close()`.

# Пример:
def my_generator():
    try:
        yield 1
        yield 2
    finally:
        print("Генератор закрыт")

# Синтаксис вызова next():
# ```python
# next(iterator[, default])
# ```
# Квадратные скобки [ ] в документации:
# Они обозначают, что параметр внутри них является необязательным. Самих квадратных скобок в коде писать не нужно.

# Аргументы:
# - **iterator**: Объект-итератор или генератор.
# - **default** (необязательный): Возвращается вместо ошибки `StopIteration`, если итератор исчерпан.

# Возвращает:
# - Следующее значение из итератора или генератора.

# Пример использования next():
gen = my_generator()
print(next(gen))  # Вывод: 1 (первое значение генератора)
print(next(gen))  # Вывод: 2 (второе значение генератора)
try:
    print(next(gen))  # Попытка получить следующее значение вызовет StopIteration
except StopIteration:
    print("Генератор исчерпан")

# Закрытие генератора:
gen.close()  # Вывод: Генератор закрыт

# Когда возникает:
# - Для освобождения ресурсов, когда генератор больше не нужен.
# - При завершении генераторов.


### 4. **ImportError**
# Описание:
# Возникает при невозможности импорта модуля или его атрибута.

# Пример:
try:
    import nonexistent_module  # Пытаемся импортировать несуществующий модуль.
except ImportError as e:
    print(f"Ошибка импорта: {e}")  # Вывод: ImportError: No module named 'nonexistent_module'

# Когда возникает:
# - Если модуль отсутствует.
# - Если модуль существует, но его имя указано с ошибкой.
# - Если запрашиваемый атрибут отсутствует в модуле.


## Итоги:
# - Синтаксические ошибки легко обнаружить благодаря `traceback`.
# - Исключения позволяют обработать ошибки во время выполнения программы, сохранив её стабильность.
# - Регулярное использование механизмов исключений помогает писать более устойчивый и понятный код.

# === Операторы для обработки исключений в Python ===

# Описание и механизм работы:
# Python предоставляет четыре оператора для обработки исключений:
# - `try`: Переводится как "попытка". Используется для выполнения кода, который может вызвать ошибку.
# - `except`: Переводится как "кроме". Используется для обработки ошибки, если она возникает в блоке try.
# - `else`: Переводится как "иначе". Выполняется, если в блоке try не было ошибок.
# - `finally`: Переводится как "наконец". Выполняется в любом случае, независимо от того, была ошибка или нет.

# Механизм работы:
# 1) Код в блоке try выполняется построчно до тех пор, пока не возникнет ошибка.
# 2) При возникновении ошибки выполнение блока try прекращается, и программа "переходит" в блок except.
# 3) В блоке except можно обработать ошибку, чтобы программа продолжила работать.
# 4) Если ошибок в блоке try не возникло, выполнение переходит в блок else (если он присутствует).
# 5) Блок finally выполняется в любом случае, даже если в блоке try или except произошла ошибка.

# Синтаксис:
# try:
#     # Код, который может вызвать ошибку.
# except [ТипОшибки] [as Переменная]:
#     # Код, который выполняется при возникновении указанной ошибки.
# else:
#     # Код, который выполняется, если ошибок не было.
# finally:
#     # Код, который выполняется в любом случае.

# === Пример общего использования try-except ===
try:
    # Код, который потенциально может вызвать ошибку.
    pass
except:
    # Код, который выполняется в случае возникновения ошибки в блоке try.
    pass

# === Пример обработки деления на ноль ===
try:
    i = 0
    print(10 / i)  # Ошибка деления на ноль.
    print('Готово')  # Эта строка не выполнится из-за ошибки выше.
except:
    print('На ноль делить нельзя')  # Обрабатываем ошибку.

# === Указание конкретного класса ошибки ===
# Лучше указывать конкретный класс ошибки, если известно, что может произойти.
try:
    i = 0
    print(10 / i)
    print('Готово')
except ZeroDivisionError:  # Перехватываем только ошибки деления на ноль.
    print('На ноль делить нельзя')

# === Обработка нескольких ошибок ===
# В одном блоке except можно указать несколько классов ошибок.
try:
    truba = a + b  # NameError (переменные a и b не определены).
    truba = 10 / 0  # ZeroDivisionError (деление на ноль).
except (ZeroDivisionError, NameError):  # Обрабатываем обе ошибки в одном блоке.
    print('Что-то не так, но мы справились')

# === Сохранение ошибки в переменную ===
# Для вывода информации об ошибке используем конструкцию "as переменная".
try:
    truba = a + b
    truba = 10 / 0
except ZeroDivisionError as exc:  # Сохраняем объект ошибки в переменную exc.
    print(f'Нельзя делить на ноль. Ошибка: {exc}')
except NameError as exc:
    print(f'Нет такой переменной. Ошибка: {exc}')

# === Блок else ===
# Блок else выполняется, если ошибок в блоке try не возникло.
# Перевод:
# - else: "иначе" — выполняется, если в блоке try не было ошибок.
i = int(input('Введите число: '))  # Вводим число.

try:
    result = 10 * (1 / i)  # Делим 10 на введённое число.
except ZeroDivisionError as exc:
    print(f'На ноль делить нельзя. Ошибка: {exc}')
else:
    print(result)  # Выполняется, если ошибок в блоке try не было.
finally:
    # Блок finally выполняется в любом случае, даже если была ошибка.
    print('Если всё прошло успешно, вы получили ответ. Если нет, то обработали ошибку.')

print('-------------------------------------------------')

# DZ 32
# Задача: Написать функцию, которая обрабатывает ошибки сложения двух аргументов.
def add_everything_up(a, b):
    """
    Синтаксис: add_everything_up(a: Any, b: Any) -> str
    Описание: Складывает два значения и обрабатывает ошибки, если они возникают.
    Аргументы:
    - a: Первое значение для сложения.
    - b: Второе значение для сложения.
    Возвращает:
    - str: Сообщение о результате или об ошибке.
    """
    try:
        result = a + b  # Пытаемся сложить два значения.
    except TypeError as exc:  # Перехватываем ошибки типа.
        print(f'Ваши данные: {a}, {b}. Ошибка: {exc}.')
    else:
        print(result)  # Если ошибки не было, выводим результат.
    finally:
        return 'Если вы всё сделали правильно, то вы получили ответ. Если нет, то вы получили ошибку.'

# Тестирование функции.
print(add_everything_up(123.456, 'строка'))  # Ошибка сложения числа и строки.
print(add_everything_up('яблоко', 4215))  # Ошибка сложения строки и числа.
print(add_everything_up(123.456, 7))  # Успешное сложение двух чисел.



# === Работа со стеком вызовов функций и исключениями ===
# Стек вызовов (call stack) — это линейная структура данных, где функции размещаются по принципу "последним зашёл — первым вышел" (LIFO).
# Когда функция вызывается, она помещается в стек, а при её завершении удаляется из стека. Ошибки обрабатываются в порядке обратного вызова.

# === Пример 1. Исключение в стеке вызовов ===
def f1(number):
    # Возвращает результат деления 10 на переданное число.
    return 10 / number

def f2():
    # Выводит сообщение и вызывает f1 с аргументом 0, что вызывает исключение.
    print('Какой хороший день')
    result_f1 = f1(0)  # Здесь возникает ошибка деления на ноль.
    return result_f1

# На данном этапе происходит следующее:
# 1. Вызов функции `f2()` приводит к вызову `f1(0)`.
# 2. Во время выполнения `f1(0)` возникает исключение `ZeroDivisionError`.
# 3. Исключение не перехватывается внутри функции `f1` или `f2`.
# 4. Выполнение выходит из `f2` и переходит на уровень выше — туда, где была вызвана `f2`.
# 5. Управление передаётся в блок `except`.

try:
    total = f2()  # Вызываем f2(), которая вызывает f1().
    print(total)  # Эта строка не выполнится из-за ошибки.
except ZeroDivisionError as exc:
    # Перехватываем исключение деления на ноль.
    print(f'вот что-то пошло не так - {exc}, но мы устояли')

print('-----------------')

# === Пример 2. Исключение в цикле с несколькими итерациями ===
def f1(number):
    # Возвращает результат деления 10 на переданное число.
    return 10 / number

def f2():
    # Перебирает диапазон чисел и вызывает f1() на каждом из них.
    print('Какой хороший день пример 2')
    summ = 0
    for i in range(-2, 2):
        summ += f1(i)  # Исключение деления на ноль прерывает выполнение цикла.
        print(summ)
    return summ

try:
    total = f2()  # Вызываем f2(), где возникает ошибка.
    print(total)  # Эта строка не выполнится из-за ошибки.
except ZeroDivisionError as exc:
    # Перехватываем исключение деления на ноль.
    print(f'вот что-то пошло не так - {exc}, но мы устояли')

print('-----------------')

# === Пример 3. Обработка исключений внутри цикла ===
def f1(number):
    # Возвращает результат деления 10 на переданное число.
    return 10 / number

def f2():
    # Перебирает диапазон чисел, обрабатывая исключения внутри цикла.
    summ = 0
    for i in range(-2, 2):
        try:
            summ += f1(i)  # Вызываем f1().
            print(summ)  # Печатаем промежуточную сумму.
        except ZeroDivisionError as exc:
            # Перехватываем исключение и продолжаем выполнение цикла.
            print(f'внутри f1 что-то пошло не так: {exc}, но программа жива, мы молодцы')
    return summ / 0  # Возвращаем результат, вызывая новое исключение.

try:
    total = f2()  # Вызываем f2(), обрабатывая его исключения.
    print(f'Вот результат функции: {total}')
except ZeroDivisionError as exc:
    # Перехватываем исключение деления на ноль.
    print(f'внутри f2 что-то пошло не так: {exc}, но мы живы, мы молодцы')

print('-----------------')

# === Пример 4. Исключение NameError ===
def f1(number):
    return total / number  # Использование переменной total до её определения вызывает NameError.

def f2():
    try:
        result_f1 = f1(0)  # Вызываем f1().
        print(result_f1)
    except ZeroDivisionError as exc:
        # Перехватываем деление на ноль, если бы оно произошло.
        print(f'внутри f1 что-то пошло не так: {exc}, но мы устояли')
    return result_f1 / 0  # Возвращаем результат с ошибкой.

try:
    f2()  # Вызываем f2(), обрабатывая исключения.
except NameError as exc:
    # Перехватываем NameError.
    print(f'внутри f2 что-то пошло не так: {exc}, но мы устояли')

print('-----------------')

# DZ 33
# === Задача 1. Суммирование с обработкой ошибок ===
def person_sum(numbers):
    """
    Синтаксис: person_sum(numbers: list[Any]) -> tuple[int, int]
    Описание: Суммирует числа в списке, пропуская некорректные типы.
    Аргументы:
    - numbers: Список чисел и других объектов.
    Возвращает:
    - tuple: Кортеж из суммы чисел и количества ошибок.
    """
    result = 0  # Итоговая сумма.
    incorrect_data = 0  # Количество ошибок.
    for i in numbers: # Перебираем каждый элемент списка numbers.
        try:
            result += i  # Пытаемся добавить элемент к сумме.
        except TypeError:
            # Перехватываем ошибки типа.
            incorrect_data += 1
            print(f'Некорректный тип данных для подсчёта суммы - {i}')
    return result, incorrect_data

# === Задача 2. Среднее значение с обработкой ошибок ===
def calculate_average(numbers):
    """
    Синтаксис: calculate_average(numbers: list[Any]) -> float | None
    Описание: Вычисляет среднее значение с учётом ошибок.
    Аргументы:
    - numbers: Список чисел и других объектов.
    Возвращает:
    - float: Среднее значение чисел.
    - None: Если данные некорректны.
    """
    try:
        summ = person_sum(numbers)  # Получаем сумму и количество ошибок.
        average_sum = summ[0] / (len(numbers) - summ[1])  # Вычисляем среднее значение.
        return average_sum
    except ZeroDivisionError:
        # Обрабатываем деление на ноль.
        return 0
    except TypeError:
        # Обрабатываем некорректный тип данных.
        print(f'В numbers записан некорректный тип данных')
        return

# === Тестовые примеры ===
print(f'Результат 1: {calculate_average("1, 2, 3")}')  # Строка перебирается, каждый символ - строковый тип.
print(f'Результат 2: {calculate_average([1, "Строка", 3, "Ещё строка"])}')  # Учитываются только числа.
print(f'Результат 3: {calculate_average(567)}')  # Передан не список, вызов ошибки.
print(f'Результат 4: {calculate_average([42, 15, 36, 13])}')  # Корректные данные, возвращается среднее значение.

# === Создание исключений в Python ===

# Исключения — это механизм обработки ошибок, возникающих в процессе выполнения программы.
# В Python можно создавать собственные исключения, используя ключевое слово `raise` (перевод: "поднять", "возбудить", "выбросить").
# Оно позволяет искусственно инициировать ошибку и передать её для обработки.

# === Зачем нужен `raise`? ===
# `raise` используется для искусственного поднятия исключений, чтобы:
# 1. **Предупредить о некорректных действиях**: Если пользователь передаёт неверные данные или нарушает правила.
# 2. **Остановить выполнение кода**: Когда продолжение выполнения бессмысленно или невозможно.
# 3. **Выявить ошибки логики**: Указать на состояние, которое не должно было возникнуть.

# === Почему нужно использовать `raise`? ===
# 1. **Генерация исключений при некорректных аргументах**:
#    Если функция получает неверные аргументы, можно использовать `raise` для информирования пользователя о проблеме.
# 2. **Остановка выполнения бессмысленного кода**:
#    Когда дальнейшее выполнение программы невозможно или бессмысленно, `raise` сигнализирует об ошибке.
# 3. **Выявление ошибок в логике программы**:
#    Помогает отладить и найти логические ошибки, которые не должны возникать при корректной работе.

# === Синтаксис ===
# raise [ExceptionType]("Сообщение об ошибке")
# Аргументы:
# - **ExceptionType**: Класс исключения. Например, `Exception`, `ValueError`, или пользовательский класс.
# - **Сообщение об ошибке** (str): Описание причины ошибки.

# === Пример 1. Простое использование `raise` ===
def greet_person(person_name):
    """
    Синтаксис: greet_person(person_name: str) -> None
    Описание: Приветствует пользователя, если его имя не запрещено.
    Аргументы:
    - person_name (str): Имя пользователя.
    Исключения:
    - Exception: Если имя запрещено.
    """
    if person_name == 'ВоланДеМорт':
        raise Exception('Мы не любим тебя, ВоланДеМорт')  # Искусственно вызываем исключение с текстовым описанием.
    print(f'Приветствую тебя, {person_name}')  # Приветствуем пользователя, если имя не запрещено.

# Пример использования функции:
greet_person('Дорогой ученик')  # Вывод: Приветствую тебя, Дорогой ученик.
# greet_person('ВоланДеМорт')  # Исключение: Мы не любим тебя, ВоланДеМорт.

print('--------------------------')

# === Пример 2. Перехват исключений и их повторная генерация ===
try:
    raise NameError('Привет Там')  # Генерация исключения типа NameError с описанием.
except NameError as exc:
    # Обрабатываем исключение: выводим его тип и параметры.
    print(f'Исключение типа {type(exc)} пролетело мимо! Его параметры: {exc.args}')
####raise  # Повторно поднимаем исключение, чтобы передать его на уровень выше.
    # Повторная генерация исключения (raise без аргументов) передаёт ошибку выше, сохраняя её контекст.

# === Как работает `raise`? ===
# Исключение, вызванное через `raise`,:
# 1. **Поднимается вверх по стеку вызовов**, если его не обработать на текущем уровне.
# 2. **Обрабатывается ближайшим блоком except** или приводит к завершению программы.

# === Механизм работы `raise` ===
# Исключение, вызванное через `raise`, может быть:
# 1. Обработано на текущем уровне с помощью блока `except`.
# 2. Передано выше по стеку вызовов, если на текущем уровне его обработка не предусмотрена.
# Это работает аналогично башенке: исключение поднимается вверх до тех пор, пока не будет перехвачено или не приведёт к завершению программы.

# === Пример 3. Создание пользовательского исключения ===
# Когда стандартных исключений недостаточно, можно создать собственный класс ошибок.

class ProZero(Exception):
    """
    Класс пользовательской ошибки.
    Описание: Исключение для случаев деления на ноль с дополнительной информацией.
    """
    def __init__(self, message, extra_info):
        """
        Синтаксис: __init__(self, message: str, extra_info: dict) -> None
        Описание: Инициализирует сообщение об ошибке и дополнительную информацию.
        Аргументы:
        - message (str): Сообщение об ошибке.
        - extra_info (dict): Дополнительные данные об ошибке.
        """
        self.message = message  # Сохраняем сообщение об ошибке.
        self.extra_info = extra_info  # Сохраняем дополнительные данные.

def f(a, b):
    """
    Синтаксис: f(a: Any, b: Any) -> float
    Описание: Выполняет деление числа `a` на `b`, перехватывая ошибку деления на ноль.
    Аргументы:
    - a (Any): Числитель.
    - b (Any): Знаменатель.
    Исключения:
    - ProZero: Если знаменатель равен 0.
    """
    if b == 0:
        raise ProZero('Деление на ноль невозможно', {'a': a, 'b': b})  # Создаём и вызываем пользовательское исключение.
    return a / b

# Пример использования:
try:
    result = f(10, 0)  # Вызываем функцию с делением на 0.
except ProZero as e:
    # Перехватываем пользовательское исключение и выводим его детали.
    print('Не очень хороший день, мы словили ошибку.')
    print(f'Сообщение об ошибке: {e.message}')
    print(f'Дополнительная информация: {e.extra_info}')
else:
    print(result)  # Выводим результат, если ошибки не было.

# Пример: Перенос ошибки по стеку
def level_3():
    raise ValueError("Ошибка на третьем уровне!")  # Исключение возникает здесь.

def level_2():
    level_3()  # level_2 вызывает level_3.

def level_1():
    try:
        level_2()  # level_1 вызывает level_2.
    except ValueError as e:
        print(f"Исключение обработано на первом уровне: {e}")

level_1() # Исключение обработано на первом уровне: Ошибка на третьем уровне!
# 1. Вызов функций:
#    level_1()
#      └──> level_2()
#               └──> level_3()  (исключение: ValueError)
#
# 2. Обработка исключения:
#    level_3()  ---->  level_2()  ---->  level_1()  ---->  Обработано в except



# === DZ 34. Работа с исключениями и проверкой данных ===
# === Создание пользовательских исключений ===
class IncorrectVinNumber(Exception):
    """
    Исключение для случаев некорректного VIN-номера.
    """
    def __init__(self, message):
        self.message = message  # Сохраняем сообщение об ошибке.

class IncorrectCarNumbers(Exception):
    """
    Исключение для случаев некорректного формата автомобильного номера.
    """
    def __init__(self, message):
        self.message = message  # Сохраняем сообщение об ошибке.

# === Класс Car ===
class Car():
    """
    Класс для создания объекта автомобиля с проверкой VIN и номеров.
    """
    def __init__(self, model, __vin, __numbers):
        """
        Синтаксис: __init__(self, model: str, __vin: int, __numbers: str) -> None
        Описание: Инициализирует автомобиль с проверкой корректности данных.
        Аргументы:
        - model (str): Модель автомобиля.
        - __vin (int): VIN-номер автомобиля.
        - __numbers (str): Регистрационные номера автомобиля.
        """
        self.model = model  # Устанавливаем модель автомобиля.
        if self.__is_valid_vin(__vin):  # Проверяем VIN-номер.
            self.__vin = __vin  # Если проверка пройдена, сохраняем VIN.
        if self.__is_valid_numbers(__numbers):  # Проверяем номера автомобиля.
            self.__numbers = __numbers  # Если проверка пройдена, сохраняем номера.

    def __is_valid_vin(self, vin_number):
        """
        Синтаксис: __is_valid_vin(self, vin_number: int) -> bool
        Описание: Проверяет корректность VIN-номера.
        Аргументы:
        - vin_number (int): VIN-номер для проверки.
        Исключения:
        - IncorrectVinNumber: Если номер некорректен.
        """
        if not isinstance(vin_number, int):
            # Проверяем, является ли VIN-номер целым числом.
            # Оператор `not` инвертирует результат isinstance().
            # isinstance(vin_number, int) вернёт True, если vin_number — целое число.
            # `not` превращает True в False. Если isinstance() вернёт False (vin_number не является int),
            # то not сделает это значение True, и условие выполнится.
            raise IncorrectVinNumber('Некорректный тип vin номер')  # Вызываем исключение для неправильного типа.
        if not 1000000 <= vin_number <= 9999999:
            # Проверяем, находится ли VIN в допустимом диапазоне.
            # Условие (1000000 <= vin_number <= 9999999) проверяет, входит ли значение в диапазон.
            # Если оно True, `not` превращает это значение в False.
            # Если значение не входит в диапазон, условие становится False, а `not` превращает его в True.
            raise IncorrectVinNumber('Неверный диапазон для vin номера')  # Вызываем исключение для неправильного диапазона.
        return True  # Если всё корректно, возвращаем True.

    def __is_valid_numbers(self, numbers):
        """
        Синтаксис: __is_valid_numbers(self, numbers: str) -> bool
        Описание: Проверяет корректность регистрационного номера.
        Аргументы:
        - numbers (str): Регистрационные номера для проверки.
        Исключения:
        - IncorrectCarNumbers: Если номера некорректны.
        """
        if not isinstance(numbers, str):
            # Проверяем, является ли номер строкой.
            # isinstance(numbers, str) вернёт True, если numbers — строка.
            # `not` инвертирует значение. Если numbers не строка, isinstance() вернёт False, и `not` сделает это True.
            raise IncorrectCarNumbers('Некорректный тип данных для номеров')  # Вызываем исключение для неправильного типа.
        if not len(numbers) == 6:
            # Проверяем, состоит ли номер из шести символов.
            # len(numbers) == 6 возвращает True, если длина строки равна 6.
            # `not` превращает True в False. Если длина не равна 6, условие становится False, а `not` делает его True.
            raise IncorrectCarNumbers('Неверная длина номера')  # Вызываем исключение для неправильной длины.
        return True  # Если всё корректно, возвращаем True.

# === Примеры использования ===
# Первый автомобиль.
try:
    first = Car('Model1', 1000000, 'f123dj')  # Создаём автомобиль с корректными данными.
except IncorrectVinNumber as exc:  # Обрабатываем исключение IncorrectVinNumber.
    print(exc.message)  # Выводим сообщение об ошибке.
except IncorrectCarNumbers as exc:  # Обрабатываем исключение IncorrectCarNumbers.
    print(exc.message)  # Выводим сообщение об ошибке.
else:
    print(f'{first.model} успешно создан')  # Если ошибок нет, выводим успешное сообщение.

# Второй автомобиль.
try:
    second = Car('Model2', 300, 'т001тр')  # Создаём автомобиль с некорректным VIN.
except IncorrectVinNumber as exc:
    print(exc.message)
except IncorrectCarNumbers as exc:
    print(exc.message)
else:
    print(f'{second.model} успешно создан')

# Третий автомобиль.
try:
    third = Car('Model3', 2020202, 'нет номера')  # Создаём автомобиль с некорректным номером.
except IncorrectVinNumber as exc:
    print(exc.message)
except IncorrectCarNumbers as exc:
    print(exc.message)
else:
    print(f'{third.model} успешно создан')

### === Practice === ###
# === Функция для вычисления выражений из строки ===
def calc(line):
    """
    Синтаксис: calc(line: str) -> None
    Описание: Выполняет арифметическую операцию, представленную строкой.
    Аргументы:
    - line (str): строка вида "число операция число" (например, "5 + 3").
    """
    # === Разделение строки на компоненты ===
    operand_1, operation, operand_2 = line.split(' ')
    # Разбиваем строку на три части: два числа (операнды) и оператор.
    # Используется метод .split(' ') с пробелом как разделителем.
    # Пример: "5 + 3" -> ['5', '+', '3'].

    # === Преобразование операндов в числа ===
    operand_1 = int(operand_1)  # Преобразуем первый операнд в число.
    operand_2 = int(operand_2)  # Преобразуем второй операнд в число.

    # === Выполнение арифметических операций ===
    # Переменная `operation` изначально является строкой (str),
    # поэтому мы сравниваем её с текстовыми представлениями операторов, такими как '+' или '/'.
    if operation == '+':
        # Выполняем операцию сложения и выводим результат.
        print(f'Результат: {operand_1 + operand_2}')
    if operation == '-':
        # Выполняем операцию вычитания и выводим результат.
        print(f'Результат: {operand_1 - operand_2}')
    if operation == '/':
        # Выполняем операцию деления и выводим результат.
        print(f'Результат: {operand_1 / operand_2}')
    if operation == '//':
        # Выполняем целочисленное деление и выводим результат.
        print(f'Результат: {operand_1 // operand_2}')
    if operation == '%':
        # Вычисляем остаток от деления и выводим результат.
        print(f'Результат: {operand_1 % operand_2}')
    if operation == '*':
        # Выполняем операцию умножения и выводим результат.
        print(f'Результат: {operand_1 * operand_2}')

    # Примечание:
    # Если оставить только первую строку (разбиение строки с помощью .split()),
    # ошибки возникнут, если строка не содержит ровно три элемента, разделённых пробелами.
    # Например, строка "5 +" вызовет ValueError: "not enough values to unpack".
    # Также, если удалить все арифметические операции, программа будет выводить только ошибки,
    # тем самым превращаясь в "анализатор" строкового ввода.


# === Счётчик строк файла ===
cnt = 0  # Счётчик строк. Используется для отслеживания номера текущей строки.

# === Чтение файла и обработка строк ===
with open('data.txt', 'r') as file:  # Открываем файл в режиме чтения.
    for line in file:  # Построчно проходим по содержимому файла.
        cnt += 1  # Увеличиваем счётчик строк.
        try:
            calc(line)  # Вызываем функцию calc для обработки строки.
        except ValueError as exc:
            # Обрабатываем ошибки, связанные с неверным форматом строки.

            # Проверяем, содержит ли первое сообщение об ошибке слово "unpack".
            # `exc.args` — это кортеж, содержащий дополнительные параметры ошибки.
            # Мы можем обращаться к элементам этого кортежа по индексу.
            # Например, exc.args[0] — первое сообщение об ошибке.
            if 'unpack' in exc.args[0]:
                print(f'Ошибка в линии {cnt}, не хватает данных для выполнения операции')

            # Если ошибка не связана с разбиением строки, она может быть связана с преобразованием в число.
            else:
                print(f'Ошибка в линии {cnt}, не удалось перевести число')

# === Примечания ===
# 1. `operation` используется для текстового сравнения, так как она содержит строку, например '+', '-', '/'.
# 2. Каждое условие выполняет математическую операцию, такую как сложение, вычитание, умножение или деление.
# 3. Если удалить все условия с арифметическими операциями (например, проверки `if operation == '+'` и т.д.),
#    программа будет выводить только ошибки, связанные с некорректным вводом.
#    Это полезно для создания программы, которая анализирует ввод и выдаёт свод ошибок.


# === Введение в функциональное программирование ===

# === Разница между ООП и ФП ===
# - **Объектно-ориентированное программирование (ООП)**:
#    В ООП используется классы и объекты для создания логических блоков.
#    Пример:
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        print(f"Привет, меня зовут {self.name} и мне {self.age} лет.")

person = Person("Иван", 30)
person.greet()

# - **Функциональное программирование (ФП)**:
#    ФП использует функции как основную структурную единицу программы.
#    Пример:
def greet(name, age):
    print(f"Привет, меня зовут {name} и мне {age} лет.")

greet("Иван", 30)

# === Пример 1. Функция как объект ===
def get_russian_names():
    """
    Возвращает список русских имён.
    """
    return ['Ваня', 'Коля', 'Миша']

# === Функция является объектом ===
# Мы можем присваивать функцию переменной и вызывать её через эту переменную.
my_func = get_russian_names  # Присваиваем функцию переменной.
print(my_func())  # Вызов функции через переменную.

# === Пример 2. Список функций ===
# Сохраняем функции в коллекцию и вызываем их динамически.
def get_british_names():
    """
    Возвращает список британских имён.
    """
    return ['Kendrick', 'Vince', 'Marshal']

name_getters = [get_russian_names, get_british_names]  # Список функций.

# Мы перебираем список функций и вызываем каждую функцию.
# Когда мы вызываем каждую функцию, она возвращает результат (в нашем случае список имён).
# Результат выполнения каждой функции (список) выводится по очереди.
for getter in name_getters:  # Перебираем функции в списке.
    print(getter())  # Вызываем каждую функцию и выводим её результат.

# Результатом перебора будет последовательный вывод списков:
# ['Ваня', 'Коля', 'Миша']
# ['Kendrick', 'Vince', 'Marshal']

# Почему при переборе функций мы получаем список?
# Когда мы передаем функцию в список (например, `name_getters = [get_russian_names, get_british_names]`),
# мы накапливаем не сами данные, а **ссылки на функции**. Это значит, что мы можем потом вызвать каждую
# функцию из списка, получая в ответ те значения, которые они возвращают.
# Функции могут вернуть любые данные, включая списки.

# === Пример 3. Функция высшего порядка ===
def adder(args):
    """
    Суммирует числа из списка.
    """
    res = 0
    for numbers in args:
        res += numbers
    return res

def multiplier(args):
    """
    Перемножает числа из списка.
    """
    res = 1
    for number in args:
        res *= number
    return res

def process_numbers(numbers, function):
    """
    Применяет переданную функцию к списку чисел.
    Аргументы:
    - numbers: Список чисел.
    - function: Ссылка на функцию, которая будет применена к numbers.
    """
    result = function(numbers)  # Вызываем переданную функцию с аргументами.
    print(f'Получилось {result}')  # Выводим результат работы функции.

# === Работа функции process_numbers ===
# 1. В функцию process_numbers передаются:
#    - список чисел `numbers`;
#    - ссылка на функцию (например, `adder` или `multiplier`).
# 2. Переменная `function` содержит ссылку на переданную функцию, но сама функция ещё не вызывается.
# 3. Когда мы пишем `function(numbers)`, происходит вызов переданной функции с аргументом `numbers`.
# 4. Результат сохраняется в переменную `result`, и его значение выводится на экран.

# === Когда использовать ссылку на функцию? ===
# - Ссылка на функцию (например, `adder`) полезна, когда нужно передать её для вызова в другой функции.
# - Это удобно в функциях высшего порядка, таких как `map`, `filter`, или `process_numbers`.
# - Используйте ссылку на функцию, если вызов будет происходить позднее или многократно в другой логике.

# Пример использования:
my_numbers = [3, 1, 4, 1, 5, 9, 2, 6]
process_numbers(my_numbers, adder)  # Передаём функцию adder.
process_numbers(my_numbers, multiplier)  # Передаём функцию multiplier.

# === Почему иногда мы вызываем функцию, а иногда используем её без вызова? ===
# - Когда мы пишем `adder` (без скобок), это ссылка на сам объект функции.
#   Мы можем передать эту ссылку как аргумент или сохранить её в переменную.
# - Когда мы пишем `adder(numbers)` (со скобками), это вызов функции, где `numbers` — аргумент.
# - Передача ссылки на функцию позволяет вызвать её позднее, например, в другом месте программы или внутри другой функции.
# - Это особенно полезно при использовании функций высшего порядка, таких как `map`, `filter` или `process_numbers`.

# === Пример с map ===
# map применяет функцию ко всем элементам последовательности.
# Синтаксис: map(function, iterable, ...) -> map object
# Описание:
# - Применяет указанную функцию `function` ко всем элементам переданного итерабельного объекта `iterable`.
# - Возвращает итератор (объект map), который можно преобразовать в список, кортеж или другой контейнер.

# Аргументы:
# - **function**: Функция, применяемая к каждому элементу.
# - **iterable**: Итерабельный объект (список, кортеж, строка и т.д.).
# - Допускается передача нескольких итерабельных объектов, если функция принимает соответствующее количество аргументов.

def mul_by_x(x):
    return x * 2

result = map(mul_by_x, my_numbers)  # Умножаем каждый элемент на 2.
print(result)  # Выводит объект map: <map object at 0x...>.
print(list(result))  # Преобразуем результат в список. Вывод: [6, 2, 8, 2, 10, 18, 4, 12].

# Пример с несколькими итерабельными объектами:
a = [1, 2, 3]
b = [4, 5, 6]
result = map(lambda x, y: x + y, a, b)  # Суммируем элементы из двух списков.
print(list(result))  # Вывод: [5, 7, 9].

# === Пример с filter ===
# filter оставляет только те элементы, для которых переданная функция возвращает True.
# Синтаксис: filter(function, iterable) -> filter object
# Описание:
# - Применяет указанную функцию `function` к каждому элементу `iterable`.
# - Возвращает итератор (объект filter), содержащий только те элементы, для которых функция вернула True.

def is_odd(x):
    return x % 2 != 0  # Проверяем, является ли число нечётным.

result = filter(is_odd, my_numbers)  # Оставляем только нечётные числа.
print(result)  # Выводит объект filter: <filter object at 0x...>.
print(list(result))  # Преобразуем результат в список. Вывод: [3, 1, 1, 5, 9].

# Если в функции is_odd заменить `!= 0` на `== 0`, filter вернёт только чётные числа:
result = filter(lambda x: x % 2 == 0, my_numbers)  # Оставляем только чётные числа.
print(list(result))  # Вывод: [4, 2, 6].

# === Использование lambda с filter ===
# Вместо создания отдельной функции можно использовать lambda.
# Пример:
result = filter(lambda x: x > 4, my_numbers)  # Оставляем числа больше 4.
print(list(result))  # Вывод: [5, 9, 6].

# === Синтаксис и описание lambda ===
# `lambda` — это анонимная (безымянная) функция, которая может быть использована для создания небольших функций
# без необходимости их объявлять как обычные функции с именем.
# Синтаксис: `lambda аргументы: выражение`
# Пример:
add = lambda x, y: x + y  # Лямбда-функция, которая принимает два аргумента и возвращает их сумму.
print(add(3, 4))  # Вывод: 7

# Преимущества:
# - Лямбда-функции удобны, когда требуется небольшая функция для одноразового использования.
# - Их можно передавать как аргументы в другие функции (например, в `map`, `filter` и другие).

# Пример использования lambda:
result = map(lambda x: x ** 2, my_numbers)  # Возводим каждый элемент в квадрат.
print(list(result))  # Вывод: [9, 1, 16, 1, 25, 81, 4, 36].


# === DZ 35 Функциональное программирование: использование функций как объектов и применение их в различных контекстах ===
def apply_all_func(int_list, *functions):
    """
    Применяет переданные функции ко всему списку и возвращает результаты в виде словаря.

    Аргументы:
    - int_list (list): Список чисел, к которому будут применяться функции.
    - *functions: Переменное количество функций, каждая из которых будет применена к int_list.

    Возвращает:
    - dict: Словарь, где ключи — имена функций, а значения — результаты их применения.
    """
    result = {}  # Словарь для хранения результатов применения функций.
    for i in functions:  # Перебираем каждую функцию, переданную через *functions.
        res = i(int_list)  # Применяем текущую функцию к списку `int_list`.

        # === Первый способ ===
        # Создаёт новый словарь на каждой итерации. Это приводит к полной потере данных,
        # добавленных ранее, поскольку новый словарь перезаписывает переменную `result`.
        # result = {i.__name__: res}
        # Минусы:
        # - Утрата всех результатов, сохранённых ранее, при каждой итерации.
        # - При большом количестве функций увеличивается расход памяти из-за частого создания новых объектов.

        # === Второй способ ===
        # Обновляет словарь на каждой итерации с помощью метода update().
        # result.update({i.__name__: res})
        # Минусы:
        # - Хотя этот метод корректен, он добавляет лишнюю операцию (вызов метода `update()`),
        #   что избыточно для простого добавления элемента в словарь.
        # - Существуют более простые и производительные способы (см. ниже).

        # === Третий способ (оптимальный) ===
        # Прямое добавление в словарь. Если ключ совпадает, его значение обновляется.
        # Если ключ отсутствует, он будет добавлен в словарь со значением `res`.
        result[i.__name__] = res
        # Плюсы:
        # - Наиболее оптимальный способ: минимизирует количество операций.
        # - Нет необходимости в создании новых объектов или вызове методов.
        # - Чётко и лаконично отражает суть добавления данных.

    return result  # Возвращаем итоговый словарь с результатами.


# Тестируем функцию:
print(apply_all_func([6, 20, 15, 9], max, min))
# Результат: {'max': 20, 'min': 6}

print(apply_all_func([6, 20, 15, 9], len, sum, sorted))
# Результат: {'len': 4, 'sum': 50, 'sorted': [6, 9, 15, 20]}

# === Описание функций ===

# 1. max(iterable, *[, key, default])
#    - **Описание:** Возвращает наибольший элемент из итерабельного объекта.
#    - **Аргументы:**
#        - `iterable`: Объект, из которого выбирается максимальный элемент.
#        - `key` (опционально): Функция, определяющая критерий сравнения.
#        - `default` (опционально): Значение, возвращаемое, если `iterable` пуст.
#    - **Пример использования:**
#        print(max([6, 20, 15, 9]))  # Вывод: 20

# 2. min(iterable, *[, key, default])
#    - **Описание:** Возвращает наименьший элемент из итерабельного объекта.
#    - **Аргументы:**
#        - `iterable`: Объект, из которого выбирается минимальный элемент.
#        - `key` (опционально): Функция, определяющая критерий сравнения.
#        - `default` (опционально): Значение, возвращаемое, если `iterable` пуст.
#    - **Пример использования:**
#        print(min([6, 20, 15, 9]))  # Вывод: 6

# 3. len(s)
#    - **Описание:** Возвращает количество элементов в объекте.
#    - **Аргументы:**
#        - `s`: Объект, поддерживающий подсчёт длины (например, список, строка, словарь).
#    - **Пример использования:**
#        print(len([6, 20, 15, 9]))  # Вывод: 4

# 4. sum(iterable, /, start=0)
#    - **Описание:** Возвращает сумму всех элементов в итерабельном объекте.
#    - **Аргументы:**
#        - `iterable`: Объект, содержащий числа.
#        - `start` (опционально): Начальное значение для суммы (по умолчанию 0).
#    - **Пример использования:**
#        print(sum([6, 20, 15, 9]))  # Вывод: 50

# 5. sorted(iterable, /, *, key=None, reverse=False)
#    - **Описание:** Возвращает новый отсортированный список из элементов переданного объекта.
#    - **Аргументы:**
#        - `iterable`: Объект, элементы которого будут отсортированы.
#        - `key` (опционально): Функция, задающая критерий сортировки.
#        - `reverse` (опционально): Если True, сортирует в обратном порядке.
#    - **Пример использования:**
#        print(sorted([6, 20, 15, 9]))  # Вывод: [6, 9, 15, 20]


# === Введение в списковые, словарные сборки ===

# === Пример с функциями map и filter ===
def by_3(x):
    return x * 3  # Функция, умножающая число на 3.

def is_odd(x):
    return x % 2  # Функция, проверяющая, является ли число нечётным (возвращает 1 для нечётных чисел, 0 для чётных).

my_numbers = [3, 1, 4, 1, 5, 9, 2, 6]  # Исходный список чисел.
result = map(by_3, filter(is_odd, my_numbers))  # Сначала фильтруем нечётные числа с помощью filter, затем умножаем их на 3 с помощью map.
print(list(result))  # Выводим результат в виде списка.

# === Списковые сборки (list comprehensions) ===
# Списковые сборки — это удобный способ создания новых списков, основанных на существующих, с возможностью применения операций и фильтров.
# Они более читабельны и компактны по сравнению с использованием функций map и filter.

# === Пример 1. Генерация списка с новой операцией ===
list_comp = [x * 3 for x in my_numbers]  # Создаём новый список, умножая каждый элемент исходного списка на 3.
# "x * 3" — это операция, результат которой добавляется в новый список.
# Например, для x = 3 результатом будет 9, который добавляется в список.
print(list_comp)  # Вывод: [9, 3, 12, 3, 15, 27, 6, 18].

# === Пример 2. Списковая сборка с фильтром ===
list_comp_2 = [x * 3 for x in my_numbers if x % 2]  # Умножаем на 3 только нечётные числа из исходного списка.
# "x * 3" — это операция, применяемая к каждому нечётному элементу.
# Условие "if x % 2" фильтрует элементы, оставляя только нечётные числа.
print(list_comp_2)  # Вывод: [9, 3, 15, 27].

# === Пример 3. Списковая сборка с условием if-else ===
list_comp_3 = [x * 2 if x > 2 else x * 10 for x in my_numbers]  # Применяем разные операции в зависимости от значения x.
# "x * 2" применяется, если x > 2. Иначе применяется "x * 10".
# Например, для x = 3 результат будет 6 (3 * 2), а для x = 1 результат будет 10 (1 * 10).
print(list_comp_3)  # Вывод: [6, 10, 8, 10, 10, 18, 10, 12].

# === Пример 4. Списковая сборка с условием на тип данных ===
my_numbers = ["A", 1, 4, "B", 5, "C", 2, 6]  # Список с элементами разных типов.
list_comp_4 = [x if type(x) == str else x * 5 for x in my_numbers]  # Если элемент строка, добавляем его без изменений. Иначе умножаем на 5.
# Например, для x = "A" результатом будет "A", а для x = 4 результатом будет 20 (4 * 5).
print(list_comp_4)  # Вывод: ["A", 5, 20, "B", 25, "C", 10, 30].

# === Пример 5. Вложенные циклы в списковых сборках ===
my_numbers = [3, 1, 4, 1, 5, 9, 2, 6]  # Первый список чисел.
they_number = [2, 7, 1, 8, 2, 8, 1, 8]  # Второй список чисел.

# Генерация нового списка на основе вложенных циклов.
result = [x * y for x in my_numbers for y in they_number]  # Перемножаем каждый элемент x из my_numbers с каждым элементом y из they_number.
# Работа цикла:
# 1. Берётся первый элемент из my_numbers (x = 3).
# 2. Перемножается с каждым элементом из they_number (y = 2, 7, 1...).
# 3. Переходим к следующему элементу из my_numbers (x = 1) и повторяем процесс.
print(result)  # Вывод: [6, 21, 3, 24, 6, 24, 3, 24, ...].

# С добавлением фильтра:
result = [x * y for x in my_numbers for y in they_number if x % 2]  # Перемножаем только нечётные числа из my_numbers.
# Условие "if x % 2" фильтрует только нечётные значения x.
print(result)  # Вывод: [6, 21, 3, ...].

# Сложный фильтр с несколькими условиями:
result = [x * y for x in my_numbers for y in they_number if x % 2 and y // 2]  # Условие включает только те пары, где x нечётное, а y > 1.
print(result)  # Вывод: [6, 21, ...].

# === Пример 6. Создание множества и словаря на лету ===
result = {x for x in my_numbers}  # Создаём множество из уникальных элементов my_numbers.
# Множество автоматически удаляет дубликаты и упорядочивает элементы.
print(result)  # Вывод: {1, 2, 3, 4, 5, 6, 9}.

result = {x: x ** 2 for x in my_numbers}  # Создаём словарь, где ключ — элемент списка, а значение — его квадрат.
# Например, для x = 3 в словарь добавляется пара 3: 9.
print(result)  # Вывод: {3: 9, 1: 1, 4: 16, ...}.

# === Пример 7. С использованием if...else
test = {key: value if condition else alternative_value for item in iterable}
my_numbers = [3, 1, 4, 1, 5, 9, 2, 6]
result = {x: x ** 2 if x % 2 == 0 else x ** 3 for x in my_numbers}
print(result)

# === DZ 36 Списковые, словарные сборки ===

# Списки строк для анализа.
first_strings = ['Elon', 'Musk', 'Programmer', 'Monitors', 'Variable']  # Список строк для первой операции.
second_strings = ['Task', 'Git', 'Comprehension', 'Java', 'Computer', 'Assembler']  # Список строк для второй операции.

# === Операция 1: Списковая сборка для фильтрации строк по длине ===
# Задача: Создать список длины строк из `first_strings`, длина которых больше 5.
# Синтаксис списковой сборки:
# [операция для каждого_элемента in коллекция if условие]
# Например, "len(x)" — это операция, результат которой добавляется в новый список.
# Условие "len(x) > 5" фильтрует строки, длина которых больше 5.
first_result = [len(x) for x in first_strings if len(x) > 5]
print(first_result)  # Вывод: [10, 8, 8]
# Объяснение:
# - "len(x)" вычисляет длину строки, и это значение добавляется в список.
# - "if len(x) > 5" добавляет строку в результат только, если её длина больше 5.
# - Результатом становится список длины строк: [10 ('Programmer'), 8 ('Monitors'), 8 ('Variable')].

# === Операция 2: Списковая сборка для поиска строк с одинаковой длиной ===
# Задача: Создать список пар строк (x, y), где x из `first_strings`, y из `second_strings`,
# и длина строки x равна длине строки y.
# Синтаксис:
# [(операция) для x in коллекция1 для y in коллекция2 if условие]
# Здесь "(x, y)" — это операция, результат которой добавляется в новый список.
# Условие "len(x) == len(y)" проверяет равенство длины строк.
second_result = [(x, y) for x in first_strings for y in second_strings if len(x) == len(y)]
print(second_result)
# Объяснение:
# - Внешний цикл for перебирает строки из `first_strings`.
# - Вложенный цикл for перебирает строки из `second_strings`.
# - Условие "if len(x) == len(y)" добавляет только пары строк с одинаковой длиной.
# - Результатом является список пар, например, [('Elon', 'Task'), ('Musk', 'Java')].

# === Операция 3: Словарная сборка для создания словаря строк с чётной длиной ===
# Задача: Создать словарь, где ключи — строки из объединённых списков `first_strings` и `second_strings`,
# а значения — их длина, но только если длина строки чётная.
# Синтаксис словарной сборки:
# {ключ: значение для каждого_элемента in коллекция if условие}
# Здесь "{x: len(x)}" — это операция, результат которой добавляется в словарь.
# Условие "len(x) % 2 == 0" проверяет, является ли длина строки чётной.
third_result = {x: len(x) for x in first_strings + second_strings if len(x) % 2 == 0}
print(third_result)
# Объяснение:
# - "first_strings + second_strings" объединяет оба списка строк.
# - "if len(x) % 2 == 0" добавляет в словарь только строки с чётной длиной.
# - Ключами словаря становятся строки, а значениями — их длина.
# - Пример результата: {'Variable': 8, 'Computer': 8, 'Assembler': 8}.



# === Генераторные сборки ===
# Генераторные сборки — это инструмент, который позволяет динамически генерировать значения для коллекций данных,
# используя **ленивые вычисления**. Такие вычисления выполняются только тогда, когда это действительно необходимо,
# что экономит память и делает генераторы особенно полезными при работе с большими объёмами данных.

# === Ленивые вычисления ===
# Ленивые вычисления (lazy evaluation) откладывают выполнение операций до момента,
# когда результат требуется. Это уменьшает использование памяти, так как значения не сохраняются в памяти полностью.

# === Ключевые особенности генераторных сборок ===
# 1. Генераторные сборки записываются в круглых скобках `( )`, в отличие от списковых `[ ]`.
# 2. Они возвращают **итератор**, который можно итерировать только один раз.
# 3. Генераторы позволяют работать с большими данными, избегая создания промежуточных коллекций в памяти.

# === Пример 1. Ленивые вычисления ===
my_numbers = [3, 1, 4, 1, 5, 9, 2, 6]

# Генераторная сборка. Вычисления выполняются только при итерировании.
result = (x ** 100 for x in my_numbers)  # Каждое число возводится в степень 100.
print(result)  # Вывод: объект генератора <generator object <genexpr> at 0x...>.

# Печать значений генератора.
for elem in result:  # При каждом проходе выполняется возведение в степень.
    print(elem)  # Выводится результат для каждого числа.

# === Пример 2. Генератор можно использовать только один раз ===
print('Еще раз')

# Повторный цикл не выведет значения, так как генератор уже был использован.
for elem in result:  # Генератор пуст, так как его значения уже были использованы.
    print(elem)  # Ничего не выводится.

# === Пример 3. Затратные операции ===
# Генераторы особенно полезны при выполнении сложных и ресурсоёмких операций.

print('---------')
import time  # Импорт модуля для измерения времени.

start_time = time.time()  # Засекаем начальное время.

# Генератор, где числа возводятся в степень 3000.
my_numbers = [3, 1, 4, 1, 5, 9, 2, 6]
result = (x ** 3000 for x in my_numbers)
print(result)  # Вывод: объект генератора <generator object <genexpr> at 0x...>.

# Итерация по генератору. Возведение в степень выполняется только при итерировании.
for i in result:
    print(i)  # Вывод результата для каждого числа.

finish_time = time.time()  # Засекаем конечное время.
# Вывод времени выполнения операций в миллисекундах.
print(f'Время в миллисекундах: {(finish_time - start_time) * 1000}')

# === Пример 4. Встроенные функции с ленивыми вычислениями ===
# Некоторые встроенные функции Python, такие как `range`, `zip`, и `map`, также используют ленивые вычисления.

list_1 = [1, 5, 9, 29, 4]  # Первый список.
list_2 = [5, 2, 9, 1, 2]   # Второй список.

# Создаём объект range, представляющий диапазон чисел от 10 до 29.
ran = range(10, 30)  # Объект range, значения генерируются только при итерировании.

# Создаём объект zip, объединяющий элементы двух списков в пары.
zp = zip(list_1, list_2)  # Объект zip: лениво создаёт пары (1, 5), (5, 2), ...

# Создаём объект map, применяя функцию str ко всем элементам list_1.
mp = map(str, list_1)  # Преобразуем числа из list_1 в строки.

# Печать объектов. Выводит ссылки на итераторы, а не значения.
print(ran, zp, mp)  # Вывод: <range object>, <zip object>, <map object>.

# Итераторы можно использовать только один раз. После преобразования в список они станут недоступны.
print(list(ran))  # Преобразуем range в список. Вывод: [10, 11, ..., 29].
print(list(zp))   # Преобразуем zip в список. Вывод: [(1, 5), (5, 2), ...].
print(list(mp))   # Преобразуем map в список. Вывод: ['1', '5', '9', '29', '4'].

# Если попытаться снова преобразовать `ran`, `zp`, или `mp` в список, результат будет пустым.

# === DZ 37 Генераторные сборки ===
# В данном задании используются генераторные сборки для создания ленивых вычислений.
# Эти вычисления выполняются только при итерации, экономя память и ресурсы.

# === Данные ===
# Два списка строк:
first = ['Strings', 'Student', 'Computers']  # Список строк на английском языке.
second = ['Строка', 'Урбан', 'Компьютер']  # Список строк на русском языке.

# === Пример 1. Генератор для вычисления разницы длин строк ===
# Создаём генераторную сборку для вычисления разницы длин строк из двух списков.
# Условие: строки сравниваются только если их длины не равны.
# len(x) - длина строки из списка `first`.
# len(y) - длина строки из списка `second`.

first_result = (len(x) - len(y) for x, y in zip(first, second) if len(x) != len(y))
# - zip(first, second): объединяет элементы двух списков парами.
# - len(x) - len(y): разница длин строк из объединённой пары.
# - if len(x) != len(y): фильтр, чтобы оставить только строки с разной длиной.

# Преобразуем результат генератора в список и выводим.
print(list(first_result))  # Вывод: [-1, 2].

# === Пример 2. Генератор для сравнения диапазонов индексов ===
# Генераторная сборка проверяет, совпадают ли диапазоны индексов строк в каждом из списков.
second_result = (range(len(first[0])) == range(len(second[0])),  # Сравнение для первого элемента.
                 range(len(first[1])) == range(len(second[1])),  # Сравнение для второго элемента.
                 range(len(first[2])) == range(len(second[2]))   # Сравнение для третьего элемента.
                 )
# - range(len(first[i])): создаёт диапазон индексов для строки из списка `first`.
# - range(len(second[i])): создаёт диапазон индексов для строки из списка `second`.
# - ==: сравнивает диапазоны на равенство.

# Преобразуем результат генератора в список и выводим.
print(list(second_result))  # Вывод: [False, True, False].

# === Примечания ===
# second_result = (len(x) == len(y) or len(x) != len(y) for x in first for y in second if range(len(x)) == range(len(y))) # точно не знаю так или нет
# но точно знаю, что мы уходили во внутренний цикл и это было неправильно
# - Альтернативный подход с внутренним циклом оказался некорректным, так как он уходил в глубину и выполнял лишние сравнения.
#   В случае с range каждая строка из `first` сравнивается строго с соответствующей строкой из `second`.
# - range используется для точного сравнения длины строк на уровне их индексов.

# === Заключение ===
# Генераторные сборки позволяют эффективно решать задачи по обработке данных, избегая избыточных вычислений и экономя ресурсы.
# В данном коде генераторы используются для вычисления разницы длин строк и сравнения диапазонов индексов строк в двух списках.



# === Создание функций на лету ===

# Иногда возникает необходимость создать функцию для выполнения краткой математической операции.
# Для этого существуют лямбда-функции — компактные функции, которые создаются и вызываются непосредственно
# в момент использования, после чего о них можно забыть.

# Пример 1. lambda — лямбда-функция
my_func = lambda x: x + 10  # Создаём лямбда-функцию, которая прибавляет 10 к переданному значению.
# Синтаксис: lambda аргументы: выражение
print(my_func(x=42))  # Вывод: 52 (выполняем операцию 42 + 10).
print(my_func.__name__)  # Лямбда-функция не имеет имени, поэтому возвращает '<lambda>'.

# Пример 1.1. С применением функции высшего порядка
my_numbers = [3, 1, 4, 1, 5, 9, 2, 6]  # Исходный список чисел.
result = map(lambda x: x + 10, my_numbers)  # Применяем лямбда-функцию ко всем элементам списка.
# Функция map последовательно передаёт каждый элемент списка `my_numbers` в лямбда-функцию.
print(list(result))  # Вывод: [13, 11, 14, 11, 15, 19, 12, 16].

# === Замыкание в Python ===
# Замыкание — это функция, которая "запоминает" значения из области видимости, в которой она была создана,
# даже если эта область видимости уже завершила своё существование.
# Это позволяет создавать функции, которые помнят значения переменных, существовавших на момент их создания.
# Пример: если функция возвращает другую функцию, внутренняя функция сохраняет доступ к переменным внешней функции.

# === Зачем возвращать функцию? ===
# Возврат функции позволяет:
# - Создавать динамическое поведение (например, разные умножители).
# - Инкапсулировать логику в функции, чтобы избежать дублирования кода.
# - Упростить тестирование и повторное использование кода.

# Пример 1. Создание функции внутри другой функции
def get_multiplier_v1(n):
    """
    Возвращает функцию, умножающую переданное значение на `n`.
    Аргументы:
    - n: множитель, передаётся один раз.
    """
    if n == 2:
        def multiplier(x):
            return x * 2  # Умножаем на 2.
    elif n == 3:
        def multiplier(x):
            return x * 3  # Умножаем на 3.
    else:
        raise Exception('Я могу сделать умножители только на 2 или 3')  # Обрабатываем недопустимые значения.

    return multiplier  # Возвращаем созданную функцию.

my_numbers = [3, 1, 4, 1, 5, 9, 2, 6]

by_2 = get_multiplier_v1(2)  # Создаём функцию, которая умножает на 2. Происходит замыкание значения `n`.
by_3 = get_multiplier_v1(3)  # Создаём функцию, которая умножает на 3. Происходит замыкание значения `n`.

result = map(by_2, my_numbers)  # Применяем функцию `by_2` ко всем элементам списка.
print(list(result))  # Вывод: [6, 2, 8, 2, 10, 18, 4, 12].
result = map(by_3, my_numbers)  # Применяем функцию `by_3` ко всем элементам списка.
print(list(result))  # Вывод: [9, 3, 12, 3, 15, 27, 6, 18].

# Пример 2. Улучшенная версия замыкания
def get_multiplier_v2(n):
    """
    Возвращает функцию, умножающую переданное значение на `n`.
    """
    def multiplier(x):
        return x * n  # Умножаем x на замкнутое значение `n`.
    return multiplier  # Возвращаем функцию.

by_5 = get_multiplier_v2(5)  # Происходит замыкание значения `n = 5`.
print(by_5(x=42))  # Вывод: 210. Умножаем переданное значение 42 на 5.

my_numbers = [3, 1, 4, 1, 5, 9, 2, 6]

by_10 = get_multiplier_v2(10)  # Замыкание: n=10.
by_100 = get_multiplier_v2(100)  # Замыкание: n=100.

print(list(map(by_10, my_numbers)))  # Вывод: [30, 10, 40, 10, 50, 90, 20, 60].
print(list(map(by_100, my_numbers)))  # Вывод: [300, 100, 400, 100, 500, 900, 200, 600].

# Пример 3. Опасность изменения замкнутых объектов
from pprint import pprint

def matrix(some_list):
    """
    Возвращает функцию, которая умножает список `some_list` на переданное значение.
    """
    def multiplier_column(x):
        return [element * x for element in some_list]  # Умножаем каждый элемент списка `some_list` на `x`.
    return multiplier_column

my_numbers = [3, 1, 4, 1, 5, 9, 2, 6]
they_number = [2, 7, 1, 8, 2, 8, 1, 8]

matrix_on_my_numbers = matrix(my_numbers)  # Замыкаем список `my_numbers`. # Замыкание: сохраняется ссылка на список my_numbers.
result = map(matrix_on_my_numbers, they_number)  # Умножаем `my_numbers` на каждый элемент `they_number`.
pprint(list(result))

# Если `my_numbers` изменится, это повлияет на замыкание.
my_numbers.extend([10, 20, 30])  # Добавляем элементы в `my_numbers`. # Изменение замкнутого списка.
result = map(matrix_on_my_numbers, they_number)  # Замыкание использует обновлённый список.
pprint(list(result))  # Результат меняется из-за модификации `my_numbers`.

# Пример 4. Создание объекта, который можно вызывать как функцию
class Multiplier:
    def __init__(self, n):
        self.n = n  # Сохраняем множитель.

    def __call__(self, x):
        """
        Позволяет вызывать объект как функцию. Умножает переданное значение на `n`.
        """
        return x * self.n

my_numbers = [3, 1, 4, 1, 5, 9, 2, 6]

by_100500 = Multiplier(n=100500)  # Создаём объект с множителем 100500.
result = by_100500(x=42)  # Вызываем объект как функцию.
print(result)  # Вывод: 4210500.

result = map(by_100500, my_numbers)  # Применяем объект ко всем элементам списка.
print(list(result))  # Вывод: [301500, 100500, 402000, 100500, 502500, 904500, 201000, 603000].

# Зачем создавать объект как функцию:
# - Сохранение состояния: объект может хранить данные, которые будут использоваться при вызове.
# - Инкапсуляция: позволяет объединить данные и методы для работы с ними в одном месте.
# - Удобство: объект-функция интуитивно понятен и может использоваться в функциях высшего порядка.
# - Гибкость: можно добавлять методы и свойства к объекту для расширения функциональности.

# === DZ 38 Создание функций на лету ===
from random import choice  # Импорт функции choice из модуля random для случайного выбора элемента из последовательности.

# === Пример 1. Lambda-функция ===
first = 'Мама мыла раму'  # Первая строка.
second = 'Рамена мало было'  # Вторая строка.

# Сравнение первых символов каждой пары символов из двух строк.
result = list(map(lambda x, y: x[0] == y[0], first, second))
# map прогоняет каждый элемент последовательности через функцию.
# В данном случае, `lambda` проверяет, совпадают ли первые символы каждой пары.
# Важно: индексы элементов увеличиваются автоматически из-за работы map.
print(result)  # Вывод: [False, False, False, False, True, ...]

# === Пример 2. Замыкание ===
def get_advanced_writer(file_name):
    """
    Возвращает функцию записи данных в файл.
    Замыкание: функция запоминает значение `file_name`, переданное при создании.
    """
    def write_everything(*data_set):
        """
        Записывает переданные данные в указанный файл.
        Аргументы:
        - data_set: Произвольное количество аргументов для записи.
        """
        with open(file_name, "w", encoding='utf-8') as file:
            # "w" — режим перезаписи: содержимое файла полностью заменяется новыми данными.
            # "a" — режим добавления: новые данные добавляются в конец файла.
            file.write(str(f'{data_set}\n'))  # Записываем данные в файл в строковом формате.
    return write_everything  # Возвращаем внутреннюю функцию, создавая замыкание.

write = get_advanced_writer('example.txt')  # На этом этапе происходит замыкание:
# Функция `get_advanced_writer` запоминает имя файла `example.txt`.

# Использование замыкания:
write('Это строчка', ['А', 'это', 'уже', 'число', 5, 'в', 'списке'])
# `write` теперь вызывает функцию `write_everything`, сохраняя связь с указанным файлом.
# Переданные данные записываются в `example.txt`.

# === Пример 3. Класс как функция (метод __call__) ===
class MysticBall:
    """
    Класс, реализующий магический метод __call__.
    Позволяет объекту класса вести себя как функция, возвращая случайное слово из заданного набора.
    """
    def __init__(self, *words):
        """
        Инициализирует объект с набором слов.
        Аргументы:
        - words: Произвольное количество слов.
        """
        self.words = list(words)  # Сохраняем слова в список.

    def __call__(self):
        """
        Позволяет вызывать объект как функцию.
        Возвращает случайное слово из списка.
        """
        return choice(self.words)  # Возвращаем случайный элемент из списка `self.words`.

# Создание объекта MysticBall:
first_ball = MysticBall('Да', 'Нет', 'Наверное')
# Объект `first_ball` можно вызывать как функцию благодаря методу __call__.

# Примеры вызова:
print(first_ball())  # Случайный вывод: "Да", "Нет" или "Наверное".
print(first_ball())
print(first_ball())

# === Примечания ===
# Пример с замыканием:
# - Замыкание позволяет создавать функции с "вшитыми" параметрами, которые сохраняются на момент создания.
# - В примере с `get_advanced_writer`, замыкание запоминает имя файла.

# Пример с классом:
# - Класс с методом __call__ превращает объект в "функцию".
# - Это удобно, когда объект хранит состояние (например, набор слов) и при вызове выполняет действие (выбор случайного слова).



# === Итераторы в Python ===

# Итераторы — это объекты, которые позволяют перемещаться по элементам коллекции или последовательности.
# Их основное преимущество заключается в экономии памяти, так как итераторы используют ленивые вычисления
# (вычисления происходят только по мере необходимости).

# === Как создать собственный итератор? ===
# Чтобы создать итератор, необходимо определить класс с двумя методами:
# 1) `__iter__`: этот метод инициализирует итератор. Он должен вернуть объект самого итератора.
# 2) `__next__`: метод, который возвращает следующий элемент последовательности. Если элементы закончились, он выбрасывает исключение `StopIteration`.

# Итераторы полезны в ситуациях, когда нужно работать с большими данными или выполнять ленивые вычисления,
# где элементы генерируются только при необходимости, а не хранятся в памяти.

# === Пример 1. Итератор на основе библиотеки itertools ===
import sys
from itertools import repeat

# Создаём итератор, который повторяет строку '4' 100_000 раз.
ex_iterator = repeat('4', 100_000)
print(ex_iterator)  # Вывод: <itertools.repeat object at ...>
print(f'Размер итератора - {sys.getsizeof(ex_iterator)} байт')  # Итератор занимает фиксированный размер памяти.

# Создаём строку '4', повторённую 100_000 раз.
ex_str = '4' * 100_000
print(f'Размер строки - {sys.getsizeof(ex_str)} байт')  # Строка занимает значительно больше памяти.

# === Итерация через итератор ===
# Итерация через итератор ex_iterator. Каждый элемент создаётся только тогда, когда он нужен, и не хранится в памяти.
for i in ex_iterator:
    print(i)  # Вывод: '4' для каждого элемента.
    break  # Для демонстрации останавливаемся после первой итерации.

# Итерация через строку ex_str. Все элементы строки уже находятся в памяти.
for i in ex_str:
    print(i)  # Вывод: '4' для каждого элемента.
    break  # Для демонстрации останавливаемся после первой итерации.

# Итератор позволяет экономить память, так как элементы создаются только при необходимости, в отличие от строки.

# === Пример 2. Создание собственного итератора ===
class Iter():
    """
    Класс-итератор, который возвращает три элемента по очереди.
    """

    def __init__(self):
        self.first = 'Первый элемент'  # Первый элемент последовательности.
        self.second = 'Второй элемент'  # Второй элемент последовательности.
        self.third = 'Третий элемент'  # Третий элемент последовательности.
        self.i = 0  # Счётчик текущей позиции.

    def __iter__(self):
        # Метод __iter__ инициализирует итератор.
        # Возвращаем ссылку на объект, чтобы он мог быть использован в цикле.
        self.i = 0  # Сбрасываем счётчик перед началом итерации.
        return self

    def __next__(self):
        # Метод __next__ возвращает следующий элемент.
        self.i += 1  # Увеличиваем счётчик.
        if self.i == 1:
            return self.first
        if self.i == 2:
            return self.second
        if self.i == 3:
            return self.third
        if self.i == 4:
            return 'Подсчёт окончен'
        raise StopIteration()  # Исключение, сигнализирующее об окончании итерации.

obj = Iter()  # Создаём объект итератора.
print(obj)

# Используем итератор в цикле for.
for value in obj:
    print(value)  # На каждой итерации вызывается метод __next__.

# Интерпретатор вызывает метод __next__ при каждом проходе цикла.
# Когда метод __next__ вызывает исключение StopIteration, цикл автоматически завершает работу.

# === Пример 3. Функция для вычисления чисел Фибоначчи ===
def fibonacci(n):
    """
    Генератор последовательности Фибоначчи.
    """
    result = []
    a, b = 0, 1
    for _ in range(n):
        result.append(a)
        a, b = b, a + b
    return result

# Используем функцию для генерации первых 10 чисел Фибоначчи.
for value in fibonacci(n=10):
    print(value)

# === Пример 4. Класс-итератор для чисел Фибоначчи ===
class Fibonacci():
    """
    Класс-итератор, который генерирует последовательность Фибоначчи до N элементов.
    """

    def __init__(self, n):
        self.i, self.a, self.b,  self.n = 0, 0, 1, n  # Инициализация начальных значений.

    def __iter__(self):
        self.i, self.a, self.b = 0, 0, 1  # Сбрасываем итератор перед началом цикла.
        return self

    def __next__(self):
        # Генерируем следующий элемент последовательности.
        self.i += 1
        if self.i > 1:  # Пропускаем первый элемент (0), сразу переходим к вычислению.
            if self.i > self.n:  # Если достигли лимита, завершаем итерацию.
                raise StopIteration()
            self.a, self.b =self.b, self.a + self.b  # Вычисляем следующий элемент.
        return self.a  # Возвращаем текущий элемент.

fib_iterator = Fibonacci(20)  # Создаём итератор на 20 элементов.
print(fib_iterator)

# Используем итератор в цикле for для вывода последовательности Фибоначчи.
for value in fib_iterator:
    print(value)


# === DZ 39 Итераторы ===

# Определяем пользовательское исключение StepValueError для обработки случая, когда шаг равен нулю.
class StepValueError(ValueError):
    def __init__(self, message):
        self.message = message

# Определяем класс Iterator, который создаёт итератор для работы с диапазоном чисел.
class Iterator:

    def __init__(self, start, stop, step=1):
        """
        Конструктор класса. Принимает начальное значение, конечное значение и шаг.
        Проверяет входные значения на корректность и сохраняет их в атрибуты объекта.
        """
        # Проверка, что start — целое число.
        if not isinstance(start, int):
            raise ValueError('Нужно целое число в start')  # Исключение, если start не целое число.
        self.start = start
        # Проверка, что stop — целое число.
        if not isinstance(stop, int):
            raise ValueError('Нужно целое число в stop')  # Исключение, если stop не целое число.
        self.stop = stop
        # Проверка, что шаг не равен нулю.
        if step == 0:
            raise StepValueError("Шаг не может быть равен нулю")  # Исключение, если шаг равен нулю.
        self.step = step
        # Установка указателя на текущее значение итератора (изначально start).
        self.pointer = start

    def __iter__(self):
        # Метод __iter__ возвращает сам объект итератора.
        # Этот метод вызывается при начале итерации, например, в цикле for.
        # Он инициализирует итератор и сбрасывает указатель.
        self.pointer = self.start  # Сбрасываем указатель на начальное значение.
        print(f'{self.pointer}', end=' ')  # Выводим начальное значение для визуализации.
        return self  # Возвращаем сам объект итератора.

        # ВОПРОС: Что делает метод __iter__?
        # ОТВЕТ: Метод __iter__ возвращает сам объект итератора, чтобы позволить его использовать в цикле for или любой другой конструкции, поддерживающей итерацию.
        # Он также сбрасывает указатель, чтобы начать итерацию заново.



        # ВОПРОС: Зачем метод __iter__ возвращает сам объект?
        # ОТВЕТ: Это необходимо для работы итератора в цикле for. Python ожидает, что метод __iter__ вернет объект, который поддерживает метод __next__,
        # чтобы можно было выполнять последовательные итерации.

        # ВОПРОС: Какая ключевая разница между __iter__ и __next__?
        # ОТВЕТ: Метод __iter__ отвечает за начальную настройку итератора (инициализацию), тогда как __next__ отвечает за получение следующего элемента в последовательности
        # и определяет, когда итерация должна завершиться.

    def __next__(self):
        """
        Метод __next__:
        - Управляет логикой итерации.
        - Обновляет указатель self.pointer в соответствии со значением self.step.
        - Проверяет, достигнут ли конец диапазона, и вызывает StopIteration, если итерация завершена.
        """
        # Метод __next__ возвращает следующий элемент последовательности или вызывает StopIteration.
        # Python вызывает этот метод каждый раз, когда требуется следующий элемент итератора.
        if self.step < 0:
            # Если шаг отрицательный, мы движемся в обратном порядке.
            self.pointer += self.step
            if self.pointer < self.stop:  # Проверяем, не вышли ли за пределы.
                print('')
                raise StopIteration()  # Сигнализируем о завершении итерации.
        elif self.start > self.stop:
            # Если начальное значение больше конечного, и шаг положительный, уменьшаем указатель.
            self.pointer -= self.step
            if self.pointer < self.stop:  # Проверяем, не вышли ли за пределы.
                print('')
                raise StopIteration()
        else:
            # Если шаг положительный и начальное значение меньше конечного, увеличиваем указатель.
            self.pointer += self.step
            if self.pointer > self.stop:  # Проверяем, не вышли ли за пределы.
                print('')
                raise StopIteration()
        return self.pointer  # Возвращаем текущее значение указателя.

        # Если метод __next__ не вызывает StopIteration, итерация продолжается.

        # ВОПРОС: То есть метод __next__ использует счетчик (указатель) для завершения итерации?
        # ОТВЕТ: Да, метод __next__ проверяет текущее значение указателя (self.pointer) и изменяет его, исходя из логики итерации.
        # Когда указатель выходит за пределы диапазона (start, stop), вызывается StopIteration, сигнализируя об окончании итерации.

        # ВОПРОС: Что именно будет итератор возвращать при вызове __next__?
        # ОТВЕТ: Итератор возвращает текущее значение указателя (self.pointer), которое изменяется в зависимости от логики шага (step).

# Блоки проверки исключений для конструктора класса Iterator.
# Попытка создать итератор с шагом 0.
try:
    iter1 = Iterator(100, 200, 0)
    for i in iter1:
        print(i, end=' ')
except StepValueError as exc:  # Обработка пользовательского исключения StepValueError.
    print(f'Шаг указан неверно: {exc}')
except ValueError as exc:  # Обработка исключения ValueError.
    print(f'{exc}')

# Попытка создать итератор с нецелым start.
try:
    iter1 = Iterator(100.1, 200, 0)
    for i in iter1:
        print(i, end=' ')
except StepValueError as exc:
    print(f'Шаг указан неверно: {exc}')
except ValueError as exc:
    print(f'{exc}')

# Попытка создать итератор с нецелым stop.
try:
    iter1 = Iterator(100, 200.1, 0)
    for i in iter1:
        print(i, end=' ')
except StepValueError as exc:
    print(f'Шаг указан неверно: {exc}')
except ValueError as exc:
    print(f'{exc}')

iter2 = Iterator(-50, 1)
iter3 = Iterator(6, 105, 2)
iter4 = Iterator(56, 1, -2)
iter5 = Iterator(120, 10)

# Использование итераторов.
for i in iter2:
    print(f'{i}',end=' ')
    # print(' ')
for i in iter3:
    print(f'{i}',end=' ')
    # print(' ')
for i in iter4:
    print(f'{i}',end=' ')
    # print(' ')
for i in iter5:
    print(f'{i}',end=' ')
    # print(' ')

# Подробное объяснение.
# __iter__ метод:
# Этот метод говорит Python, что объект поддерживает итерацию.
# Он возвращает сам объект итератора (то есть тот, у которого определены методы __iter__ и __next__).
# При вызове iter(obj) Python вызывает именно этот метод.
# Часто в __iter__ инициализируется счётчик или указатель (как в вашем примере — self.pointer), чтобы начать итерацию с правильного значения.

# __next__ метод:
# Этот метод отвечает за логику итерации.
# Каждый вызов next(iterator) возвращает следующий элемент последовательности.
# Как только достигается конец итерации (условие завершения), вызывается StopIteration, чтобы сигнализировать Python, что итерация завершена.
# По сути, то, что возвращает __next__, и является текущим элементом итерации.

# Пример с вашим случаем:
# __iter__ настраивает всё для начала итерации (например, сбрасывает указатель self.pointer).
# __next__ управляет тем, как элементы последовательности "выдаются" в каждом шаге. Это и есть "сердце" итератора.

# Можно представить это как поезд:
# __iter__ подготавливает поезд на станции, задавая его начальное состояние.
# __next__ двигает поезд на следующую станцию (или завершает движение, если все станции пройдены).



# === Генераторы ===

# Генератор — это специальная функция, которая возвращает объект-генератор.
# Генератор позволяет обрабатывать последовательности данных лениво — элементы возвращаются по одному по мере необходимости.
# В отличие от обычных функций, генераторы используют ключевое слово `yield` вместо `return`.

# === yield ===
# Ключевое слово `yield` используется для возврата значения из генератора.
# При этом выполнение функции не прекращается, а при следующем вызове итерации (например, через `next()` или `for`)
# выполнение продолжается с той строки, на которой оно было остановлено.

# Пример 1. Создание простого генератора
# В этом примере генератор возвращает значения от 0 до n-1.
def func_generator(n):
    """
    Синтаксис: func_generator(n: int) -> generator
    Описание: Генерирует числа от 0 до n-1.
    Аргументы:
    - n (int): Верхний предел генерации чисел.
    """
    i = 0
    while i != n:
        yield i  # Возвращаем текущее значение i и приостанавливаем выполнение.
        i += 1  # Увеличиваем i для следующей итерации.

# Создаём объект-генератор
obj = func_generator(10)
print(obj)  # Выводит объект-генератор, например: <generator object func_generator at 0x...>.

# Используем генератор в цикле for
for i in obj:
    print(i)  # Выводит числа от 0 до 9.

# Пример 2. Генератор последовательности Фибоначчи
# Сравним обычную функцию и генератор для вычисления чисел Фибоначчи.

def fibonacci_v1(n):
    """
    Синтаксис: fibonacci_v1(n: int) -> list
    Описание: Вычисляет последовательность Фибоначчи с помощью списка.
    Аргументы:
    - n (int): Количество чисел в последовательности.
    """
    result = []
    a, b = 0, 1
    for _ in range(n):
        result.append(a)
        a, b = b, a + b
    return result  # Возвращает список с последовательностью.

def fibonacci_v2(n):
    """
    Синтаксис: fibonacci_v2(n: int) -> generator
    Описание: Генерирует последовательность Фибоначчи с помощью генератора.
    Аргументы:
    - n (int): Количество чисел в последовательности.
    """
    a, b = 0, 1
    for _ in range(n):
        yield a  # Возвращает текущий элемент последовательности и приостанавливает выполнение.
        a, b = b, a + b

# Используем функцию, возвращающую список
fib_1 = fibonacci_v1(n=10)
print(fib_1)  # Выводит список чисел Фибоначчи.

for value in fib_1:
    print(value)  # Печатает числа из списка.

# Используем генератор
fib_2 = fibonacci_v2(n=10)
print(fib_2)  # Выводит объект-генератор, например: <generator object fibonacci_v2 at 0x...>.

for value in fib_2:
    print(value)  # Печатает числа Фибоначчи по одному.

# === Важное замечание ===
# Генератор можно использовать только один раз.
# После того как все значения из генератора будут использованы, он исчерпает себя.

# Пример 3. Бесконечный генератор чисел Фибоначчи
# Генераторы могут быть полезны для создания бесконечных последовательностей.

def fibonacci_v3():
    """
    Синтаксис: fibonacci_v3() -> generator
    Описание: Бесконечно генерирует числа Фибоначчи.
    """
    a, b = 0, 1
    while True:
        yield a  # Возвращает текущее значение и приостанавливает выполнение.
        a, b = b, a + b

# Используем бесконечный генератор
for value in fibonacci_v3():
    print(value)
    if value > 100 ** 6:  # Прерываем бесконечный цикл, если число превышает 100^6.
        break

# Пример 4. Чтение большого файла с помощью генератора
# Генераторы особенно полезны для работы с большими объёмами данных, например, файлами.

import time
start = time.time()

def read_large_file(file_path):
    """
    Синтаксис: read_large_file(file_path: str) -> generator
    Описание: Построчно читает файл, используя генератор.
    Аргументы:
    - file_path (str): Путь к файлу.
    """
    with open(file_path, 'r', encoding='utf-8') as file:
        for line in file:
            yield line.strip()  # Убираем лишние пробелы и возвращаем строку.

# Используем генератор для чтения большого файла
for line in read_large_file('large_file.txt'):
    print(line)

fin = time.time()
print(f'Время выполнения: {(fin - start) * 1000:.2f} мс')

# === Как работает yield ===
# 1. При первом вызове генератора выполнение доходит до ключевого слова `yield` и возвращает его значение.
# 2. При следующем вызове выполнение продолжается с места, где было остановлено, и до следующего `yield`.
# 3. Когда выполнение достигает конца функции, вызывается исключение `StopIteration`.

# Генераторы позволяют экономить память, поскольку данные генерируются по одному элементу,
# а не хранятся целиком в памяти, как это делает, например, список.

# === Дополнительные советы и фишки ===
# - **Используйте генераторы для чтения больших файлов**:
#   Например, если вам нужно обработать файл построчно, генератор предотвратит загрузку всего файла в память.
#   ```python
#   def read_file_by_line(file_path):
#       with open(file_path, 'r') as file:
#           for line in file:
#               yield line.strip()
#   ```

# - **Сочетайте генераторы с функциями высшего порядка**:
#   Такие функции, как `map`, `filter`, и генераторные выражения, идеально дополняют генераторы.
#   ```python
#   result = (x * 2 for x in range(1000) if x % 3 == 0)
#   print(list(result))
#   ```

# - **Создавайте многоуровневые генераторы**:
#   Генераторы могут вызывать другие генераторы с помощью ключевого слова `yield from`.
#   ```python
#   def generator_a():
#       yield from range(5)
#   def generator_b():
#       yield from generator_a()
#   print(list(generator_b()))  # Вывод: [0, 1, 2, 3, 4]
#   ```

# - **Используйте генераторы для потоковой обработки данных**:
#   Если вы обрабатываете данные из API или потоков, генераторы помогут обрабатывать данные без задержек, связанных с загрузкой всей информации.

# Эти преимущества и рекомендации помогут вам эффективно использовать генераторы в реальных задачах!


# === DZ 40 Генераторы ===
def all_variants(text):
    """
    Генератор, возвращающий все возможные подстроки строки `text`.

    Аргументы:
    - text (str): Исходная строка.

    Работает с помощью вложенных циклов. Срез строки text[i:x+1] формирует подстроку от i до x включительно.
    """
    for i in range(len(text)):  # Внешний цикл: выбираем начальный индекс i.
        for x in range(i, len(text)):  # Внутренний цикл: выбираем конечный индекс x.
            # Срез строки text[i:x+1]:
            # - text[i:x+1] включает символы от индекса i (включительно) до x (включительно).
            # - x+1 используется, чтобы сделать конечный индекс включённым, так как срезы в Python не включают конечный индекс.
            yield text[i:x + 1]  # Возвращаем подстроку.


# === Описание срезов ===
# Синтаксис среза строки: text[start:end:step]
# Аргументы:
# - start (необязательный): Начальный индекс, с которого начинается срез (включается в результат). По умолчанию — 0.
# - end (необязательный): Конечный индекс, до которого выполняется срез (НЕ включается в результат).
# - step (необязательный): Шаг, с которым выбираются элементы. По умолчанию — 1.
#
# Примеры срезов:
# text = "abcde"
# - text[1:4] → "bcd" (символы с индексами 1, 2, 3; индекс 4 не включается).
# - text[:3] → "abc" (от начала до индекса 3, не включая).
# - text[2:] → "cde" (от индекса 2 до конца строки).
# - text[::2] → "ace" (все символы с шагом 2).
# - text[::-1] → "edcba" (разворачивает строку).

# Демонстрация работы генератора:
a = all_variants("abc")
for i in a:
    print(i)


# === Альтернативный подход ===
def all_variants(text):
    """
    Генератор, возвращающий все возможные подстроки строки `text` с использованием другого подхода.

    Аргументы:
    - text (str): Исходная строка.

    Работает, формируя подстроки фиксированной длины size и смещая начальный индекс l.
    """
    for size in range(len(text)):  # Внешний цикл: размер подстроки (от 1 до длины строки).
        for l in range(len(text) - size):  # Внутренний цикл: начальный индекс l.
            # Срез строки text[l:l+size+1]:
            # - text[l:l+size+1] включает символы от индекса l до l+size (включительно).
            yield text[l:l + size + 1]  # Возвращаем подстроку.


# Демонстрация работы генератора:
a = all_variants("abc")
for i in a:
    print(i)

# === Пояснение работы среза в генераторах ===
# Генераторы возвращают последовательности с помощью ленивых вычислений. Срезы позволяют получить нужный фрагмент строки без
# необходимости выделять всю последовательность в памяти. Это делает генераторы и срезы особенно эффективными для обработки больших данных.



# === Декораторы ===
# Декораторы не являются генераторами или итераторами и не имеют никакого отношения к этим паттернам программирования.
# Декораторы представляют собой обёртки, которые накладываются на функции или классы в языке Python с целью изменения их поведения.
# Изначально мы имеем функцию, которая выполняет определённую задачу. При применении декоратора, которым, как правило,
# является другая функция, поведение исходной функции изменяется.

# Декоратор представляет собой функцию, которая принимает другую функцию в качестве аргумента и возвращает новую функцию.

# Создание декоратора
# 1. function = decorator(function)
# 2. @decorator
#    def function(,,,):
#       ...

# Пример 1. Создания простого декоратора
# В данном случае мы используем функцию «null_decorator», которая принимает в качестве аргумента другую
# функцию и просто возвращает её без изменений. Такой декоратор не добавляет никакого дополнительного функционала.
# Важно отметить, что декоратор обязательно должен возвращать функцию

def null_decorator(func):
    return func  # Возвращаем переданную функцию без изменений (декоратор должен возвращать функцию для работы)

def greet():
    return "Hello"  # Простая функция, возвращающая строку

greet = null_decorator(greet)  # Применяем декоратор вручную

print(greet())  # Вывод: Hello

# Пример 2. Использование синтаксис Python @ для декорирования функции за один шаг

def null_decorator(func):
    return func  # Возвращаем переданную функцию без изменений (декоратор должен возвращать функцию для работы)

@null_decorator  # Используем декоратор через @
def greet():
    return "Hello"  # Простая функция, возвращающая строку

print(greet())  # Вывод: Hello

# Пример 3. Внутри декоратора определяем еще одну функцию.

def uppercase(func):
    def wrapper():  # Внутренняя функция-обёртка
        original_result = func()  # Вызываем переданную функцию
        modified_result = original_result.upper()  # Преобразуем результат в верхний регистр
        return modified_result  # Возвращаем модифицированный результат
    return wrapper  # Возвращаем обёртку (декоратор должен возвращать функцию для работы)

@uppercase  # Применяем декоратор к функции greet

def greet():
    return "Hello"  # Простая функция, возвращающая строку

print(greet())  # Вывод: HELLO

print('-----')

def uppercase(func):
    def wrapper():  # Внутренняя функция-обёртка
        original_result = func()  # Вызываем переданную функцию
        modified_result = original_result.upper()  # Преобразуем результат в верхний регистр
        return modified_result  # Возвращаем модифицированный результат
    return wrapper  # Возвращаем обёртку (декоратор должен возвращать функцию для работы)

def greet():
    return "Hello"  # Простая функция, возвращающая строку

greet_dec = uppercase(greet)  # Применяем декоратор вручную
print(greet())  # Вывод: Hello
print(greet_dec())  # Вывод: HELLO

# Пример 4. Декоратор для измерения времени выполнения функции

import time  # Импортируем модуль time для работы со временем
import sys  # Импортируем модуль sys для настройки программы

def time_track(func):
    def surrogate(*args, **kwargs):  # Функция-обёртка принимает произвольные аргументы
        started_at = time.time()  # Фиксируем начальное время
        result = func(*args, **kwargs)  # Вызываем декорируемую функцию и сохраняем её результат
        ended_at = time.time()  # Фиксируем время завершения
        elapsed = round(ended_at - started_at, 4)  # Рассчитываем время выполнения (в секундах)
        print(f'Функция работала {elapsed} секунд(ы)')  # Выводим время выполнения
        return result  # Возвращаем результат работы декорируемой функции
    return surrogate  # Возвращаем обёртку (декоратор должен возвращать функцию для работы)

@time_track  # Применяем декоратор к функции digit

def digit(*args):
    total = 1  # Инициализируем переменную для вычислений
    for number in args:  # Проходим по всем аргументам
        total *= number ** 5000  # Возводим в степень и перемножаем
    return len(str(total))  # Возвращаем длину числа

sys.set_int_max_str_digits(100000)  # Увеличиваем максимальную длину строки для больших чисел

result = digit(3141, 5926, 2718, 2818)  # Вызываем функцию с большими числами
print(result)  # Выводим результат

# Пример 5. Декораторы функций (содержимое из изображения)

def func_decorator(func):
    def wrapper(*args, **kwargs):
        print("------ что-то делаем перед вызовом функции ------")  # Вывод перед вызовом функции
        res = func(*args, **kwargs)  # Вызов переданной функции с аргументами
        print("------ что-то делаем после вызова функции ------")  # Вывод после вызова функции
        return res  # Возвращаем результат работы оригинальной функции (декоратор должен возвращать функцию для работы)
    return wrapper  # Возвращаем обёртку (декоратор должен возвращать функцию для работы)

@func_decorator  # Применяем декоратор к функции some_func

def some_func(title, tag):
    print(f"title = {title}, tag = {tag}")  # Вывод значений аргументов
    return f"<{tag}>{title}</{tag}>"  # Возвращаем строку в формате HTML-тега

# Использование функции с декоратором
result = some_func("Python навсегда!", "h1")  # Вызываем функцию с аргументами
print(result)  # Выводим результат работы функции


# === DZ 41 Декораторы ===
# Декоратор is_prime используется для проверки, является ли результат работы функции простым числом.
def is_prime(func):  # Декоратор принимает функцию func в качестве аргумента.
    def warp(*args, **kwargs):  # Внутренняя обёртка принимает произвольные аргументы.
        res_sum_three = func(*args, **kwargs)  # Вызываем исходную функцию и сохраняем её результат.
        if res_sum_three <= 1:  # Проверяем, является ли число меньше или равно 1.
            return 'Число меньше одного или равное одному не являются простыми'

            # Проверяем делимость числа на любые числа от 2 до √(числа) включительно.
            # res_sum_three ** 0.5 — это эквивалент квадратного корня числа res_sum_three
            # Степень 0.5 означает извлечение квадратного корня. Математически: x ** 0.5 = sqrt(x)
        for i in range(2, int(res_sum_three ** 0.5) + 1):
            if res_sum_three % i == 0:  # Если число делится без остатка, то оно составное.
                return f'{res_sum_three} - Число составное'
        # Если цикл завершился без нахождения делителей, число простое.
        return f'{res_sum_three} - Число простое'

    return warp  # Возвращаем обёртку (декоратор должен возвращать функцию для корректной работы).


# Декорируем функцию sum_three, которая возвращает сумму трёх чисел.
@is_prime
def sum_three(a, b, c):  # Функция принимает три аргумента.
    return a + b + c  # Возвращаем их сумму.

# Вызываем функцию и проверяем её результат.
result = sum_three(2, 3, 6)  # Результат: 2 + 3 + 6 = 11 (простое число).
print(result)  # Вывод: 11 - Число простое
result2 = sum_three(3, 4, 8)  # Результат: 3 + 4 + 8 = 15 (составное число).
print(result2)  # Вывод: 15 - Число составное
result3 = sum_three(1, 4, 2)  # Результат: 1 + 4 + 2 = 7 (простое число).
print(result3)  # Вывод: 7 - Число простое
result4 = sum_three(8, 7, 44)  # Результат: 8 + 7 + 44 = 59 (простое число).
print(result4)  # Вывод: 59 - Число простое
result5 = sum_three(1, 22, 13)  # Результат: 1 + 22 + 13 = 36 (составное число).
print(result5)  # Вывод: 36 - Число составное
result6 = sum_three(4, 15, 5)  # Результат: 4 + 15 + 5 = 24 (составное число).
print(result6)  # Вывод: 24 - Число составное
result7 = sum_three(1, 2, 2)  # Результат: 1 + 2 + 2 = 5 (простое число).
print(result7)  # Вывод: 5 - Число простое
result8 = sum_three(1, 1, 1)  # Результат: 1 + 1 + 1 = 3 (простое число).
print(result8)  # Вывод: 3 - Число простое

# === Декораторы.2 ===
import time  # Импортируем модуль для работы со временем.
import sys  # Импортируем модуль для управления системными параметрами.

# === Пример 1. Функция, которая возвращает декоратор ===

def func_gen_dec(precision):
    """
    Функция высшего порядка, создающая декоратор с заданной точностью precision.
    Аргументы:
    - precision (int): Количество знаков после запятой для округления времени выполнения функции.
    Возвращает:
    - Декоратор (функция dec).
    """
    def dec(func):
        """
        Декоратор, добавляющий измерение времени выполнения функции.
        Аргументы:
        - func: Функция, которую необходимо декорировать.
        Возвращает:
        - Функцию-обёртку (wrapper).
        """
        def wrapper(*args, **kwargs):
            """
            Функция-обёртка, измеряющая время выполнения декорируемой функции.
            """
            started_at = time.time()  # Засекаем время начала выполнения.
            result = func(*args, **kwargs)  # Вызываем реальную функцию и сохраняем её результат.
            ended_at = time.time()  # Засекаем время завершения выполнения.
            elapsed = round(ended_at - started_at, precision)  # Вычисляем время выполнения с заданной точностью.
            print(f'Функция работала {elapsed} секунд(ы)')  # Выводим время выполнения.
            return result  # Возвращаем результат выполнения функции.
        return wrapper  # Возвращаем функцию-обёртку.
    return dec  # Возвращаем декоратор.

# === Декорирование функции через синтаксис @ ===
@func_gen_dec(precision=6)
def digits(*args):
    """
    Функция, выполняющая сложные вычисления.
    """
    total = 1  # Начальное значение произведения.
    for number in args:  # Проходим по всем аргументам.
        total *= number ** 5000  # Возводим числа в степень и перемножаем.
    return len(str(total))  # Возвращаем длину результата в виде строки.

sys.set_int_max_str_digits(10**5)  # Увеличиваем лимит длины строки для больших чисел.

result = digits(3141, 5926, 2718, 2818)  # Вызываем функцию digits с большими числами.
print(result)  # Выводим результат.

# === Декорирование функции вручную ===
time_track_precision_6 = func_gen_dec(precision=10)
# Вызываем func_gen_dec(precision=10), что возвращает декоратор (функцию dec).
# В данном случае dec имеет сохранённое значение precision в замыкании.

digits = time_track_precision_6(digits)
# Применяем декоратор вручную:
# - time_track_precision_6 возвращает функцию wrapper, в которую передаётся оригинальная функция digits.
# Теперь переменная digits указывает на обёрнутую функцию wrapper, а не на оригинальную.

result = digits(3141, 5926, 2718, 2818)
# Вызываем обёрнутую функцию digits. В процессе выполнения:
# - Вызывается wrapper.
# - Засекается время выполнения оригинальной функции.
# - Выводится время выполнения.
# - Возвращается результат оригинальной функции.
print(result)  # Выводим результат.

# === Пример 2. Подробное объяснение работы декоратора ===

def func_get_dec(precision):
    """
    Функция высшего порядка, подробно объясняющая создание декоратора.
    """
    print('получили точность, с которой надо выводить результат')
    print('начинаем создавать декоратор')

    def dec(func):
        """
        Декоратор, подробно объясняющий свою работу.
        """
        print(f'декоратор принял на вход функцию, которую надо отдекорировать - {func}')
        print('начинает создавать функцию-обёртку')

        def wrapper(*args, **kwargs):
            """
            Функция-обёртка с подробным объяснением своей работы.
            """
            print('мы в функции-обёртке, которая заместит реальную функцию func')
            print('засекаем время')
            started_at = time.time()  # Засекаем время начала выполнения.
            print('запускаем реальную функцию с переданными в функцию-обёртку параметрами и запоминаем результат')
            result = func(*args, **kwargs)  # Вызываем декорируемую функцию.
            print('определяем затраченное время и выводим его')
            ended_at = time.time()  # Засекаем время завершения выполнения.
            print(f'вот тут-то и пригодится precision (== {precision}) - он запомнился в замыкании surrogate')
            elapsed = round(ended_at - started_at, precision)  # Вычисляем время выполнения.
            print(f'Функция работала {elapsed} секунд(ы)')  # Выводим время выполнения.
            print('возвращаем результат, который вернула реальная функция')
            return result  # Возвращаем результат выполнения функции.
        print('декоратор создал функцию-обёртку и возвращает её')
        return wrapper  # Возвращаем функцию-обёртку.
    print('декоратор создан и пора его вернуть')
    return dec  # Возвращаем декоратор.

@func_get_dec(precision=6)
def digits(*args):
    """
    Функция для сложных математических вычислений.
    """
    total = 1  # Начальное значение произведения.
    for number in args:  # Проходим по всем аргументам.
        total *= number ** 5000  # Возводим числа в степень и перемножаем.
    return len(str(total))  # Возвращаем длину результата в виде строки.

sys.set_int_max_str_digits(10**5)  # Увеличиваем лимит длины строки для больших чисел.

result = digits(3141, 5926, 2718, 2818)  # Вызываем функцию digits.
print(result)  # Выводим результат.


# === Декораторы.3 ===
# Задание:
# 1. Написать функцию, которая возвращает функцию повторения двух первых символов строки n раз.
# 2. Создать массив функций и применить их поочерёдно к аргументу.
# 3. Применить все функции поочерёдно к массиву аргументов.

# Данные для работы:
animal = 'мишка'  # Строка для обработки.
animals = ['зайка', 'мишка', 'бегемотик']  # Список строк для обработки.

# === 1. Генерация функции повторения двух первых символов строки n раз ===
def gen_repeat(n):
    """
    Функция высшего порядка, которая создаёт функцию для повторения двух первых символов строки n раз.
    Аргументы:
    - n (int): Количество повторений.
    Возвращает:
    - Функцию repeat, которая принимает строку и выполняет повторение.
    """
    def repeat(animal):
        """
        Функция, возвращающая строку с повторением двух первых символов n раз.
        Аргументы:
        - animal (str): Исходная строка.
        Возвращает:
        - Строку, где два первых символа повторены n раз, разделены дефисом.
        """
        # Срез animal[:2] берёт два первых символа строки.
        # Операция (animal[:2] + '-') * n повторяет эти два символа n раз с дефисом между ними.
        return (animal[:2] + '-') * n + animal  # Добавляем к результату исходную строку.
    return repeat  # Возвращаем функцию repeat.

# Тестирование функции:
test_1 = gen_repeat(1)  # Создаём функцию с повторением двух первых символов 1 раз.
test_2 = gen_repeat(2)  # Создаём функцию с повторением двух первых символов 2 раза.
print(test_1(animal))  # Вывод: ми-мишка
print(test_2(animal))  # Вывод: ми-ми-мишка

# === 2. Создание массива функций и применение их к одному аргументу ===

# Создаём список функций, каждая из которых повторяет два первых символа от 1 до 3 раз.
repetitions = [gen_repeat(n) for n in range(1, 4)]  # Списковая сборка генерирует функции на лету.
# Списковая сборка: выполняется для каждого n в диапазоне [1, 4).
# Операция gen_repeat(n) создаёт функцию для каждого значения n.
print(repetitions)  # Вывод: [<function gen_repeat.<locals>.repeat>, ...]

# Применяем каждую функцию из списка repetitions к переменной animal.
result = [func(animal) for func in repetitions]  # Применение функций к строке.
# Списковая сборка: func(animal) вызывает каждую функцию с аргументом animal.
print(result)  # Вывод: ['ми-мишка', 'ми-ми-мишка', 'ми-ми-ми-мишка']

# === 3. Применение всех функций к массиву аргументов ===

# Первый способ: Сначала берём функцию, потом проходим по списку animals.
fin_result = [func(x) for func in repetitions for x in animals]
# Сначала перебираются функции в repetitions, затем для каждой функции обрабатываются строки из animals.

# Второй способ: Сначала берём строку, потом проходим по списку функций.
fin_result2 = [func(x) for x in animals for func in repetitions]
# Сначала перебираются строки из animals, затем для каждой строки вызываются все функции из repetitions.

print(fin_result)  # Вывод всех строк с повторением символов для каждого animal.
print(fin_result2)  # Альтернативный порядок применения.

# === Оптимизация функции через декоратор memoize ===
# Пример с ускорением вычислений через сохранение результатов (мемоизация).

def memoize_func(f):
    """
    Декоратор для мемоизации результатов функции.
    Аргументы:
    - f: Декорируемая функция.
    Возвращает:
    - Функцию-обёртку, которая сохраняет результаты выполнения.
    """
    mem = {}  # Словарь для сохранения результатов выполнения функции.
    def wrapper(*args):
        """
        Функция-обёртка для сохранения результата выполнения декорируемой функции.
        """
        print(f'Выполнение функции с аргументами={args}, внутренняя память={mem}')
        # Оператор `not` проверяет, нет ли текущих аргументов в памяти mem.
        # Если `args not in mem`, значит, текущие аргументы ещё не обработаны.
        if args not in mem:  # Если аргументов нет в памяти:
            mem[args] = f(*args)  # Вызываем оригинальную функцию, сохраняем результат в mem.
            # mem[args]: Ключ в словаре — это кортеж аргументов args, значение — результат выполнения функции f.
            return f'Функция выполнилась, ответ = {mem[args]}'
        else:  # Если аргументы уже есть в памяти:
            return f'Функция была выполнена раньше, ответ = {mem[args]}'
    return wrapper  # Возвращаем обёртку.

@memoize_func  # Применяем декоратор для ускорения выполнения функции.
def func(a, b):
    """
    Функция для возведения числа a в степень b.
    """
    print(f'Выполняем функцию с аргументом ({a}, {b})')
    return a ** b  # Возвращаем результат.

# Тестирование мемоизации:
print(func(3, 5), '\n')  # Выполнение функции, результат сохраняется.
print(func(3, 4), '\n')  # Выполнение функции, результат сохраняется.
print(func(3, 2), '\n')  # Выполнение функции, результат сохраняется.
print(func(3, 5), '\n')  # Повторное использование результата из памяти.
print(func(3, 4), '\n')  # Повторное использование результата из памяти.
print(func(3, 5), '\n')  # Повторное использование результата из памяти.

# === Ручное применение декоратора ===

# Создаём экземпляр декоратора:
memoized_func = memoize_func(func)

# Применяем обёртку вручную:
print(memoized_func(3, 5))  # Выполнение через обёртку, результат сохраняется.
print(memoized_func(3, 5))  # Повторное выполнение, результат берётся из памяти.


# === DZ 41 Декораторы ===
# Декоратор is_prime используется для проверки, является ли результат работы функции простым числом.
def is_prime(func):  # Декоратор принимает функцию func в качестве аргумента.
    def warp(*args, **kwargs):  # Внутренняя обёртка принимает произвольные аргументы.
        res_sum_three = func(*args, **kwargs)  # Вызываем исходную функцию и сохраняем её результат.
        if res_sum_three <= 1:  # Проверяем, является ли число меньше или равно 1.
            return 'Число меньше одного или равное одному не являются простыми'

            # Проверяем делимость числа на любые числа от 2 до √(числа) включительно.
            # res_sum_three ** 0.5 — это эквивалент квадратного корня числа res_sum_three
            # Степень 0.5 означает извлечение квадратного корня. Математически: x ** 0.5 = sqrt(x)
        for i in range(2, int(res_sum_three ** 0.5) + 1):
            if res_sum_three % i == 0:  # Если число делится без остатка, то оно составное.
                return f'{res_sum_three} - Число составное'
        # Если цикл завершился без нахождения делителей, число простое.
        return f'{res_sum_three} - Число простое'

    return warp  # Возвращаем обёртку (декоратор должен возвращать функцию для корректной работы).


# Декорируем функцию sum_three, которая возвращает сумму трёх чисел.
@is_prime
def sum_three(a, b, c):  # Функция принимает три аргумента.
    return a + b + c  # Возвращаем их сумму.


# Вызываем функцию и проверяем её результат.
result = sum_three(2, 3, 6)  # Результат: 2 + 3 + 6 = 11 (простое число).
print(result)  # Вывод: 11 - Число простое

result2 = sum_three(3, 4, 8)  # Результат: 3 + 4 + 8 = 15 (составное число).
print(result2)  # Вывод: 15 - Число составное

result3 = sum_three(1, 4, 2)  # Результат: 1 + 4 + 2 = 7 (простое число).
print(result3)  # Вывод: 7 - Число простое

result4 = sum_three(8, 7, 44)  # Результат: 8 + 7 + 44 = 59 (простое число).
print(result4)  # Вывод: 59 - Число простое

result5 = sum_three(1, 22, 13)  # Результат: 1 + 22 + 13 = 36 (составное число).
print(result5)  # Вывод: 36 - Число составное

result6 = sum_three(4, 15, 5)  # Результат: 4 + 15 + 5 = 24 (составное число).
print(result6)  # Вывод: 24 - Число составное

result7 = sum_three(1, 2, 2)  # Результат: 1 + 2 + 2 = 5 (простое число).
print(result7)  # Вывод: 5 - Число простое

result8 = sum_three(1, 1, 1)  # Результат: 1 + 1 + 1 = 3 (простое число).
print(result8)  # Вывод: 3 - Число простое



# === Введение в потоки ===
# Что такое поток?
# Потоки (threads) можно рассматривать как минимальную единицу выполнения работы в операционной системе.
# Поток представляет собой минимальную единицу работы, которую ОС должна выполнить.
# Для того чтобы лучше понять, что это такое, нужно знать, что потоки существуют внутри процессов.

# Процесс — это экземпляр программы, который запущен и выполняется операционной системой.
# Каждый процесс может иметь один или несколько потоков, которые работают параллельно.

# Особенности потоков внутри процесса
# Главная особенность потоков, которые находятся внутри одного процесса, заключается в том,
# что они работают с общим состоянием и памятью родительского процесса.
# Это значит, что все потоки в процессе имеют доступ к одним и тем же переменным, памяти и ресурсам,
# что делает их выполнение быстрым и эффективным.
# Однако это также источник потенциальных проблем, таких как гонки потоков, так как потоки могут пытаться изменить одни и те же данные одновременно.

# В Python для работы с потоками используется модуль threading, который предоставляет все необходимые средства для создания и управления потоками.
import threading  # Импортируем модуль threading для работы с потоками
import time  # Импортируем модуль time для работы с задержками

# === Определение функций для выполнения в потоках ===
def func1():
    """
    Функция func1() выполняет задачу в основном потоке.
    Цикл выводит числа от 0 до 9 с задержкой в 0.5 секунды.
    """
    for i in range(10):  # Основной поток обрабатывает этот цикл
        time.sleep(0.5)  # Задержка на 0.5 секунды
        print(i, threading.current_thread())  # Вывод текущего числа и информации о потоке

def func2(x):
    """
    Функция func2(x) принимает один аргумент и выполняет задачу во вспомогательном потоке.
    Цикл выводит числа от 0 до 9 с задержкой в 1 секунду.
    Также проверяется, активен ли поток в данный момент.
    """
    for i in range(10):  # Вспомогательный поток обрабатывает этот цикл
        time.sleep(1)  # Задержка на 1 секунду
        print(i, threading.current_thread())  # Вывод текущего числа и информации о потоке
        # Поток считается "живым", пока он не завершит выполнение всех задач.
        print(threading.current_thread().is_alive())  # Проверка, активен ли поток (возвращает True, пока поток не завершён)

# === Создание потока ===
# Python позволяет создавать потоки двумя основными способами.
# 1. **Создание потока с использованием класса Thread и передачи функции**:
#    Это наиболее простой и распространённый способ. Мы передаём ссылку на функцию, которую поток должен выполнить.
thread = threading.Thread(
    target=func2,  # Ссылка на функцию, которая будет выполняться в потоке
    args=(1,),  # Кортеж аргументов, передаваемых в функцию
    daemon=True  # Поток-демон, завершится при завершении основного потока
)
# Потоки-демоны работают в фоновом режиме и автоматически завершаются,
# как только завершатся все основные потоки программы.

# Поток изначально находится в состоянии "ожидания".
# Для его запуска необходимо вызвать метод `start()`:
thread.start()

# Метод `join()` — это способ заставить основной поток ждать завершения указанного потока.
# Если раскомментировать строку ниже, основной поток программы будет ждать завершения вспомогательного потока.
# Это полезно, если результат работы вспомогательного потока критически важен для дальнейшей работы программы.
thread.join()

print(thread.is_alive())  # Проверка, активен ли поток (вывод True, пока поток выполняет задачи)

# === Основной поток ===
# Функция func1() выполняется в основном потоке.
func1()  # Основной поток продолжает выполнение без ожидания завершения потока `thread` (если thread.join() закомментирован).

# === Информация о потоках ===
# `threading.enumerate()` возвращает список всех активных потоков в программе.
print(threading.enumerate())  # Вывод информации обо всех потоках (основной поток и потоки-демоны, если они активны)

# `threading.current_thread()` возвращает объект текущего потока, выполняющего код.
print(threading.current_thread())  # Вывод информации о текущем потоке
# ============================= #
# 2. **Создание потока через наследование класса Thread**:
#    Этот способ требует создания пользовательского класса, который наследуется от `threading.Thread`.
#    Мы переопределяем метод `run()` для задания задач, которые будет выполнять поток.
class MyThread(threading.Thread):
    def __init__(self, x):
        super().__init__()  # Инициализируем родительский класс
        self.x = x  # Сохраняем аргументы как атрибуты экземпляра

    def run(self):
        """
        Метод `run()` выполняется при вызове `start()`.
        В этом методе определяем задачи, которые должен выполнить поток.
        """
        for i in range(10):
            time.sleep(1)  # Задержка на 1 секунду
            print(f"Thread (x={self.x}): {i}")  # Вывод текущего числа и информации о потоке

# Создаём экземпляр пользовательского потока:
custom_thread = MyThread(x=10)  # Передаём аргументы в конструктор
custom_thread.start()  # Запускаем поток, который выполняет метод `run()`
custom_thread.join()  # Дожидаемся завершения работы потока

# === Разница между способами ===
# - **Способ 1** (через `Thread`): используется для простых задач, где потоку достаточно передать функцию для выполнения.
# - **Способ 2** (через наследование `Thread`): предпочтителен, если поток должен обладать собственной логикой,
#   атрибутами и методами, которые делают его более гибким и адаптируемым к сложным задачам.

# Оба способа создают вспомогательные потоки, которые работают параллельно с основным потоком.


# === Пример работы с потоками и методом join() ===
import threading  # Импортируем модуль threading для работы с потоками
from time import sleep  # Импортируем sleep для создания задержки в выполнении

# === Функция, выполняемая в потоках ===
def task(name, duration):
    """
    Эмулирует выполнение задачи с задержкой.
    Аргументы:
    - name (str): Название потока или задачи.
    - duration (int/float): Время выполнения задачи в секундах.
    """
    print(f'{name} начал выполнение...')  # Выводим сообщение о начале выполнения
    sleep(duration)  # Приостанавливаем выполнение задачи на указанное время
    print(f'{name} завершён.')  # Выводим сообщение о завершении выполнения

# === Создание потоков ===
thread1 = threading.Thread(target=task, args=("Поток 1", 2))  # Создаём поток, передавая функцию task и её аргументы
thread2 = threading.Thread(target=task, args=("Поток 2", 4))  # Второй поток с большей задержкой

# === Запуск потоков ===
thread1.start()  # Запускаем поток 1
thread2.start()  # Запускаем поток 2

# === Основной поток ожидает завершения потоков ===
thread1.join()  # Основной поток приостанавливается, пока не завершится Поток 1
print("Основной поток: Поток 1 завершён, продолжаю выполнение.")  # Выводим сообщение после завершения Потока 1

thread2.join()  # Основной поток приостанавливается, пока не завершится Поток 2
print("Основной поток: Поток 2 завершён, завершение программы.")  # Выводим сообщение после завершения Потока 2


# === DZ 42 Создание потоков ===

import threading  # Импортируем модуль для работы с потоками
from time import sleep  # Импортируем функцию sleep для задержки выполнения
from datetime import datetime  # Импортируем datetime для измерения времени выполнения

# === Функция для записи слов в файл ===
def wite_words(word_count, file_name):
    """
    Записывает заданное количество строк в файл с задержкой.
    Аргументы:
    - word_count (int): Количество строк для записи.
    - file_name (str): Имя файла, в который будут записаны строки.
    """
    with open(file_name, 'a', encoding='utf-8') as file:  # Открываем файл в режиме добавления ('a')
        for i in range(word_count + 1):  # Проходим по диапазону от 0 до word_count включительно
            sleep(0.1)  # Задержка в 0.1 секунды между записями
            file.write(f'Какое-то слово № <{i}>\n')  # Записываем строку в файл
        print(f'Завершилась запись в файл <{file_name}>')  # Уведомляем, что запись завершена

# === Последовательное выполнение функции (основной поток) ===
time_start = datetime.now()  # Засекаем начальное время выполнения

# Последовательно вызываем функцию для записи слов в файлы
wite_words(10, 'example1.txt')
wite_words(30, 'example2.txt')
wite_words(200, 'example3.txt')
wite_words(100, 'example4.txt')

# Вычисляем общее время выполнения всех вызовов функции
time_end = datetime.now() - time_start  # Разница между начальным и конечным временем
print(f'Работа функции {time_end}')  # Выводим общее время выполнения

# === Использование потоков для выполнения функции параллельно ===

# Засекаем начальное время выполнения потоков
start_time_thread = datetime.now()

# Создаём вспомогательные потоки
thread = threading.Thread(target=wite_words, args=(10, 'example5.txt'))  # Поток для записи в example5.txt
thread2 = threading.Thread(target=wite_words, args=(30, 'example6.txt'))  # Поток для записи в example6.txt
thread3 = threading.Thread(target=wite_words, args=(200, 'example7.txt'))  # Поток для записи в example7.txt
thread4 = threading.Thread(target=wite_words, args=(100, 'example8.txt'))  # Поток для записи в example8.txt

# Запуск всех потоков без ожидания
thread.start()
thread2.start()
thread3.start()
thread4.start()

# Дожидаемся завершения всех потоков после их запуска
thread.join()
thread2.join()
thread3.join()
thread4.join()

# Вычисляем общее время выполнения потоков
end_time_thread = datetime.now() - start_time_thread
print(f'Работа функции {end_time_thread}')  # Выводим общее время выполнения потоков

# === Пояснения ===

# --- Работа с потоками параллельно ---
# Когда мы запускаем несколько потоков с помощью `start()`, все они начинают выполняться одновременно (насколько это позволяет процессор).
# Это позволяет задачам, которые не зависят друг от друга, выполняться быстрее, чем при последовательном запуске в одном потоке.
# Например, если каждая функция `wite_words` выполняется 2 секунды, запуск их параллельно сокращает общее время выполнения.

# --- Работа с потоками непараллельно ---
# Если после запуска потока использовать метод `join()`, основной поток программы будет ожидать завершения работы текущего потока.
# Это приводит к последовательному выполнению потоков. Например:
# thread.start()
# thread.join()  # Основной поток ждёт завершения потока thread
# thread2.start()
# thread2.join()  # Основной поток ждёт завершения потока thread2
# В результате потоки выполняются один за другим, а не одновременно.

# Пример параллельной и непараллельной работы потоков:
# Если убрать вызовы `join()` после `start()`, то потоки будут работать параллельно:
# thread.start()
# thread2.start()
# thread3.start()
# thread4.start()
# thread.join()  # Основной поток ждёт завершения ВСЕХ потоков после их запуска
# thread2.join()
# thread3.join()
# thread4.join()
# В таком случае время выполнения программы будет сокращено.

# --- Основной поток vs вспомогательные потоки ---
# В начале программы код выполняется в основном потоке. Это последовательный поток выполнения инструкций.
# Потоки, создаваемые с помощью класса `Thread`, являются вспомогательными. Они выполняются параллельно с основным потоком.
# Если основной поток завершится, программа завершится, даже если вспомогательные потоки не закончили свою работу,
# если они помечены как `daemon=True`.

# --- Работа с datetime ---
# Модуль `datetime` используется для работы с датами и временем.
# 1. `datetime.now()` возвращает текущую дату и время.
# 2. Разница между двумя объектами `datetime` даёт объект `timedelta`, представляющий разницу во времени.
# 3. Например:
#    - `time_start = datetime.now()` — засекаем время начала.
#    - `time_end = datetime.now() - time_start` — вычисляем, сколько времени прошло.

# === Итог ===
# Использование потоков позволяет значительно сократить время выполнения задач, если они не зависят друг от друга.
# Однако важно учитывать необходимость синхронизации данных между потоками, чтобы избежать конфликтов при доступе к общим ресурсам.


# === Потоки на классах ===
import threading  # Импортируем модуль threading для работы с потоками
import time  # Импортируем модуль time для работы с задержками и временем

# === Введение в потоки на основе классов ===
# Потоки (threads) представляют собой минимальную единицу выполнения работы внутри процесса.
# Работа с потоками на основе классов даёт следующие преимущества:
# 1) **Логическая структура**: Упрощённая организация кода, особенно если потоку требуется больше данных или сложная логика.
# 2) **Инкапсуляция**: Код, связанный с потоком, организован в рамках класса, что улучшает читаемость и поддержку.
# 3) **Расширяемость**: Легко добавлять новые методы или атрибуты для управления потоками, отслеживания состояния и обработки ошибок.

# === Класс для работы с потоками ===
class MyThread(threading.Thread):  # Класс MyThread наследуется от threading.Thread
    def __init__(self, name, counter, delay):
        """
        Инициализация потока.
        Аргументы:
        - name (str): Имя потока.
        - counter (int): Количество итераций выполнения.
        - delay (float): Задержка между итерациями.
        """
        threading.Thread.__init__(self)  # Вызываем конструктор родительского класса threading.Thread
        self.name = name  # Имя потока (идентификатор)
        self.counter = counter  # Количество итераций выполнения
        self.delay = delay  # Задержка между итерациями

    def timer(self, name, counter, delay):
        """
        Функция, которая выполняет задачу потока с заданным количеством итераций и задержкой.
        Аргументы:
        - name (str): Имя потока.
        - counter (int): Количество итераций.
        - delay (float): Задержка между итерациями.
        """
        while counter:  # Пока счётчик итераций больше 0
            time.sleep(delay)  # Приостанавливаем выполнение на заданное время
            print(f'{self.name} {time.ctime(time.time())}')  # Выводим имя потока и текущее время
            counter -= 1  # Уменьшаем счётчик

    def run(self):
        """
        Метод, который выполняется при запуске потока.
        Этот метод вызывается автоматически, когда мы вызываем thread.start().
        """
        print(f'Поток {self.name} запущен')  # Уведомление о запуске потока
        self.timer(self.name, self.counter, self.delay)  # Запускаем выполнение задачи потока
        print(f'Поток {self.name} завершен')  # Уведомление о завершении потока

# === Подробное объяснение работы класса потока ===
# 1. **Инициализация**:
#    - Конструктор `__init__()` задаёт основные параметры потока: имя, количество итераций и задержку.
#    - `threading.Thread.__init__(self)` вызывается, чтобы инициализировать базовый функционал потока.
#    - Атрибуты `self.name`, `self.counter`, `self.delay` инициализируются для хранения параметров.
#
# 2. **Метод timer()**:
#    - Выполняет задачу потока, организованную через цикл `while`, с задержкой `time.sleep(delay)`.
#    - Внутри цикла выводится имя потока и текущее время через `time.ctime()`.
#    - Счётчик `counter` уменьшается до тех пор, пока не станет равным 0.
#
# 3. **Метод run()**:
#    - `run()` содержит основную логику, которая выполняется в потоке. Его не нужно вызывать вручную, он запускается через `start()`.
#    - Метод выводит уведомление о начале выполнения потока, вызывает `self.timer()` для выполнения задачи, а затем уведомляет о завершении работы.

# === Создание потоков ===
thread1 = MyThread('thread1', 5, 1)  # Создаём поток с именем 'thread1', 5 итерациями и задержкой в 1 секунду
thread2 = MyThread('thread2', 3, 0.5)  # Создаём поток с именем 'thread2', 3 итерациями и задержкой в 0.5 секунды

# === Запуск потоков ===
thread1.start()  # Запускаем поток 1. Метод start() вызывает метод run() внутри потока
thread2.start()  # Запускаем поток 2

# === Примечание о потоках ===
# - Каждый поток запускается через метод `start()`, который вызывает метод `run()` внутри потока.
# - Оба потока выполняются параллельно, каждый выполняет свою задачу в методе `timer()`.


# === DZ 43 Потоки на классах ===
import threading  # Импортируем модуль для работы с потоками
import time  # Импортируем модуль для работы со временем (например, для задержки выполнения)

# === Класс Knight для моделирования битвы рыцарей ===
class Knight(threading.Thread):  # Наследуем класс от threading.Thread, чтобы сделать его потоком
    def __init__(self, name, power):
        """
        Инициализация класса Knight.
        Аргументы:
        - name (str): Имя рыцаря.
        - power (int): Сила атаки рыцаря.
        """
        super().__init__()  # Инициализируем поток через super()
        # threading.Thread.__init__(self)  # Альтернативный способ инициализации потока через родительский конструктор
        self.name = str(name)  # Имя рыцаря
        self.power = int(power)  # Сила атаки рыцаря
        self.hp_bot = 100  # Количество "воинов" или "жизней" у врага (начальное значение)
        self.day = 0  # Счётчик дней, который отображает, сколько дней длилась битва

    def fight(self, name, power):
        """
        Функция моделирует битву рыцаря против врага.
        Аргументы:
        - name (str): Имя рыцаря (не используется в логике, но оставлено для наглядности).
        - power (int): Сила атаки рыцаря (используется для уменьшения hp_bot).
        """
        while True:  # Битва продолжается, пока враг не побеждён
            self.hp_bot -= self.power  # Уменьшаем количество врагов на значение силы рыцаря
            self.day += 1  # Увеличиваем счётчик дней
            print(f'{self.name} сражается {self.day} день/дня, осталось {self.hp_bot} воинов!')
            time.sleep(1.1)  # Задержка для имитации прохождения времени
            if self.hp_bot <= 0:  # Если врагов не осталось
                print(f'{self.name} одержал победу спустя {self.day} дней/дня!')
                break  # Завершаем битву

    def run(self):
        """
        Основная функция потока, автоматически вызываемая при вызове метода start().
        Моделирует начало битвы.
        """
        print(f'{self.name}, на нас напали!')  # Уведомляем, что началась битва
        self.fight(self.name, self.power)  # Запускаем функцию битвы для рыцаря

# === Создание объектов класса Knight (потоков) ===
first_knight = Knight('Sir Lancelot', 10)  # Создаём рыцаря Sir Lancelot с силой 10
second_knight = Knight("Sir Galahad", 20)  # Создаём рыцаря Sir Galahad с силой 20

# === Запуск потоков (начало битв) ===
first_knight.start()  # Запускаем поток для первого рыцаря
second_knight.start()  # Запускаем поток для второго рыцаря

# === Ожидание завершения потоков (битв) ===
first_knight.join()  # Ожидаем завершения потока (битвы) первого рыцаря
second_knight.join()  # Ожидаем завершения потока (битвы) второго рыцаря

# === Завершение программы ===
print(f'Все битвы окончены. Воцарился мир!')  # Сообщаем, что все битвы завершены и наступил мир

# === Подробное описание потоков и их методов ===
# 1. **threading.Thread.__init__(self)**:
#    - Этот метод вручную инициализирует поток. Обычно используется как альтернатива вызову `super().__init__()`.
#    - Если вы используете его, вы явно вызываете конструктор родительского класса (threading.Thread).

# 2. **start()**:
#    - Метод, который запускает поток. При вызове `start()` автоматически запускается метод `run()`.

# 3. **run()**:
#    - Основной метод, содержащий логику выполнения потока. Если переопределён, выполняется вместо стандартного поведения потока.

# 4. **join()**:
#    - Метод, который заставляет основной поток ждать завершения потока, к которому он применён.
#    - Без `join()` основной поток может завершиться до окончания вспомогательных потоков.

# 5. **Потоковая модель**:
#    - В этом примере `first_knight` и `second_knight` — это вспомогательные потоки, выполняющие задачи (битвы).
#    - Основной поток запускает их с помощью `start()` и дожидается их завершения с помощью `join()`.

# === Примечания ===
# - Потоки в Python могут работать параллельно, но из-за GIL (Global Interpreter Lock) только один поток выполняется в один момент времени на уровне интерпретатора.
# - Для настоящей параллельности в Python используется модуль `multiprocessing`, который создаёт независимые процессы с собственной памятью.



# === Проблемы многопоточного программирования, блокировки и обработка ошибок ===

# Обсуждение проблем многопоточности: состояние гонки, блокировки, обработка ошибок.
# Использование блокировок (`Lock`) помогает синхронизировать потоки и избежать ошибок.

import threading  # Модуль для работы с потоками

# === Глобальная переменная и блокировка ===
counter = 0  # Общая переменная, которая будет изменяться в потоках

# **Важно: создание объекта блокировки**
# Вместо вызова блокировки через `threading.Lock()` для каждого потока, лучше создать
# **единственный объект блокировки**, чтобы гарантировать правильную синхронизацию.
# Создание одного объекта блокировки помогает избежать ошибок, таких как неправильная синхронизация
# при использовании нескольких блокировок для одного ресурса.
# Почему:
# - Если мы создаём новый объект блокировки в каждом потоке, каждый поток будет работать с
#   независимым объектом блокировки, и это не обеспечит нужную синхронизацию между потоками.
# - Один и тот же объект блокировки используется всеми потоками, что позволяет синхронизировать доступ
#   к общим данным.
lock = threading.Lock()  # Создаём один объект блокировки

# --- Что такое Lock? ---
# `Lock` — это механизм, который позволяет «захватить» ресурс одним потоком и заблокировать доступ
# к этому ресурсу для других потоков до тех пор, пока он не будет освобождён.
# Это предотвращает состояние гонки.
# Пример работы с `Lock`:
# - `lock.acquire()` — захватывает блокировку. Если она уже занята, поток ждёт её освобождения.
# - `lock.release()` — освобождает блокировку, позволяя другим потокам использовать ресурс.
# - Или используем контекстный менеджер `with lock`, который автоматически вызывает `release()` после выхода из блока кода.

print(lock.locked())  # Проверяем, заблокирован ли объект Lock в данный момент (False)

# === Функция для увеличения счётчика ===
def increment(name):
    global counter
    with lock:  # Используем контекстный менеджер для автоматического управления блокировкой
        # Блокируем доступ к ресурсу (counter) для других потоков на время выполнения кода внутри блока
        for i in range(1000):
            counter += 1  # Увеличиваем счётчик
            print(name, counter)  # Выводим имя потока и текущее значение счётчика

# === Функция для уменьшения счётчика ===
def decrement(name):
    global counter
    try:
        lock.acquire()  # Захватываем блокировку вручную
        # Блокируем доступ к ресурсу (counter) для других потоков на время выполнения кода внутри блока
        for i in range(1000):
            counter -= 1  # Уменьшаем счётчик
            print(name, counter, lock.locked())  # Выводим имя потока, значение счётчика и статус блокировки
    except Exception:  # Обработка возможных исключений
        pass
    finally:
        lock.release()  # Освобождаем блокировку вручную

# --- Отличие lock.acquire() от `with lock` ---
# - `lock.acquire()` и `lock.release()` требуют ручного управления блокировкой. Если забыть вызвать `release()`, это
#   может привести к взаимной блокировке (deadlock).
# - `with lock` автоматически вызывает `lock.acquire()` при входе в блок и `lock.release()` при выходе,
#   даже если внутри блока произошло исключение. Это делает использование `with` более безопасным и удобным.

# === Создание потоков ===
thread1 = threading.Thread(target=increment, args=('thread1',))  # Поток для увеличения счётчика
thread2 = threading.Thread(target=decrement, args=('thread2',))  # Поток для уменьшения счётчика
thread3 = threading.Thread(target=increment, args=('thread3',))  # Ещё один поток для увеличения
thread4 = threading.Thread(target=decrement, args=('thread4',))  # Ещё один поток для уменьшения

# --- Запуск потоков ---
thread1.start()  # Запускаем поток 1
thread3.start()  # Запускаем поток 3
thread2.start()  # Запускаем поток 2
thread4.start()  # Запускаем поток 4

# --- Оператор with ---
# Синтаксис: `with <контекстный_объект> as <переменная>:`
# Контекстный менеджер автоматически вызывает методы `__enter__()` (вход в блок кода) и `__exit__()` (выход из блока кода).
# Например:
# ```
# with lock:
#     # Код внутри блока имеет эксклюзивный доступ к ресурсу
#     counter += 1
# ```
# Когда выполнение блока завершено, метод `lock.release()` вызывается автоматически.

# --- Потоки и проблемы ---
# 1. **Состояние гонки**: Если два потока одновременно выполняют `counter += 1`, то счётчик может быть увеличен неправильно.
#    Например, вместо увеличения на 2 он может быть увеличен на 1.
#    Это связано с тем, что операции чтения, модификации и записи переменной выполняются как отдельные действия.
# 2. **Использование блокировок**: Позволяет синхронизировать потоки и исключить такие ошибки.

# --- Пример различий между блокировками ---
# Без блокировок:
# - Поток 1 читает `counter = 0`.
# - Поток 2 читает `counter = 0`.
# - Оба потока увеличивают `counter` до 1 и записывают результат.
# С блокировками:
# - Поток 1 захватывает блокировку и увеличивает `counter` до 1.
# - Поток 2 ждёт, пока блокировка не будет освобождена.

"""
# Синхронизация потоков может происходить через блокировки (например, threading.Lock), 
# если потоки обращаются к общему ресурсу. Это предотвращает состояние гонки и гарантирует,
# что только один поток в определённый момент времени использует ресурс.
# Если потоки работают независимо и не делят ресурсы, синхронизация может быть естественной, 
# без использования блокировок.
"""


# === DZ 44 Блокировки и обработка ошибок ===
from random import randint  # Импортируем функцию для генерации случайных чисел
import threading  # Импортируем модуль для работы с потоками
from time import sleep  # Импортируем функцию для задержки выполнения


# === Класс Bank для моделирования работы банка ===
class Bank():
    """
    Класс, моделирующий банковскую систему.
    Содержит методы для пополнения и снятия средств с использованием многопоточности и блокировок.
    """

    def __init__(self):
        """
        Инициализируем начальный баланс и объект блокировки (Lock).
        """
        self.balance = int(0)  # Баланс банка, инициализированный значением 0
        self.lock = threading.Lock()  # Блокировка для управления доступом к общему ресурсу (балансу)

    def deposit(self):
        """
        Метод для пополнения счёта.
        Генерирует случайные суммы и добавляет их к балансу банка.
        """
        x = 0  # Счётчик числа операций
        while x < 100:  # Максимальное число операций: 100
            refill = randint(50, 500)  # Генерируем случайную сумму пополнения
            self.balance += refill  # Добавляем сумму к балансу
            print(f'Пополнение {refill}. Баланс {self.balance}')  # Выводим информацию о пополнении
            sleep(0.002)  # Задержка для моделирования времени обработки операции

            # Проверяем, нужно ли освободить блокировку
            if self.balance >= 500 and self.lock.locked() == True:
                # Если баланс больше или равен 500, а блокировка активна, освобождаем её
                self.lock.release()
            x += 1  # Увеличиваем счётчик операций

    def take(self):
        """
        Метод для снятия средств со счёта.
        Генерирует запрос на снятие случайной суммы и выполняет его, если средств достаточно.
        """
        x = 0  # Счётчик числа операций
        while x < 100:  # Максимальное число операций: 100
            refill = randint(50, 500)  # Генерируем случайную сумму снятия
            print(f'Запрос на {refill}')  # Выводим информацию о запросе на снятие

            if refill <= self.balance:  # Проверяем, достаточно ли средств для снятия
                self.balance -= refill  # Уменьшаем баланс
                print(f'Снятие: {refill}. Баланс: {self.balance}')  # Выводим информацию о снятии
                sleep(0.002)  # Задержка для моделирования времени обработки операции
                x += 1  # Увеличиваем счётчик операций
            else:
                # Если средств недостаточно, блокируем поток и ждём пополнения
                print(f'Запрос отклонён, недостаточно средств')
                self.lock.acquire()  # Захватываем блокировку (ожидание пополнения)


# === Создание объекта банка ===
bk = Bank()

# === Создание потоков для пополнения и снятия средств ===
th1 = threading.Thread(target=Bank.deposit, args=(bk,))  # Поток для пополнения счёта
th2 = threading.Thread(target=Bank.take, args=(bk,))  # Поток для снятия средств

# === Запуск потоков ===
th1.start()  # Запускаем поток пополнения
th2.start()  # Запускаем поток снятия

# === Ожидание завершения потоков ===
th1.join()  # Ждём завершения потока пополнения
th2.join()  # Ждём завершения потока снятия

# === Вывод итогового баланса ===
print(f'Итоговый баланс: {bk.balance}')  # Выводим итоговый баланс после выполнения всех операций

# === Пояснения ===

# --- Работа блокировки ---
# Блокировка (`Lock`) используется для синхронизации потоков и предотвращения одновременного доступа к общему ресурсу (балансу).
# - `lock.acquire()`: Захватывает блокировку. Если блокировка уже занята, поток ждёт её освобождения.
# - `lock.release()`: Освобождает блокировку, позволяя другим потокам использовать ресурс.
# - `lock.locked()`: Возвращает `True`, если блокировка захвачена, и `False`, если она свободна.

# --- Пример с использованием блокировки ---
# В методе `take`:
# - Если запрашиваемая сумма превышает текущий баланс, поток вызывает `lock.acquire()` и ожидает.
# - В методе `deposit`:
#   - Если баланс превышает 500, поток проверяет, занята ли блокировка (`lock.locked() == True`), и освобождает её (`lock.release()`).

# --- Почему `with lock` предпочтительнее? ---
# Использование `with lock` позволяет автоматически освободить блокировку, даже если внутри блока кода произойдёт исключение.
# Это делает код более безопасным и удобным для чтения.

# --- Важные моменты ---
# 1. Потоки работают параллельно, но их доступ к балансу синхронизирован с помощью блокировки.
# 2. Поток `deposit` добавляет средства, освобождая блокировку, когда баланс >= 500.
# 3. Поток `take` захватывает блокировку и ожидает пополнения, если средств недостаточно.

# --- Вопросы для практики ---
# 1. Что произойдёт, если убрать `lock.acquire()` и `lock.release()`?
# Без блокировки потоки одновременно изменят общий ресурс (self.balance), вызывая состояние гонки.
# Итоговый баланс станет некорректным. Блокировка гарантирует, что только один поток работает с ресурсом в данный момент.

# 2. Можно ли заменить `lock.acquire()` на `with lock` в данном коде?
# Нет, так как `with lock` автоматически освобождает блокировку после выхода из блока.
# Здесь блокировка должна сохраняться при определённых условиях, что требует явного управления через acquire() и release().

# 3. Какие ещё механизмы синхронизации есть в `threading`?
# - `RLock`: позволяет одному потоку захватывать блокировку несколько раз.
# - `Semaphore`: ограничивает доступ к ресурсу нескольким потокам одновременно.
# - `Event`: синхронизирует потоки, ожидающие сигнала.
# - `Condition`: управляет сложной координацией между потоками.

# === Выводы ===
# 1. Использование блокировок позволяет избежать состояния гонки и синхронизировать потоки.
# 2. Контекстный менеджер (`with lock`) делает работу с блокировками более безопасной.
# 3. Блокировки позволяют управлять доступом к общим ресурсам, но требуют внимательного подхода, чтобы избежать взаимной блокировки.



# === Раздел 1. Глобальная блокировка интерпретатора (GIL) ===

# Сегодня на уроке мы поговорили о GIL (Global Interpreter Lock).
# GIL — это глобальная блокировка интерпретатора, которая позволяет работать только одному потоку с Python-кодом в конкретный момент времени.

# GIL делает многопоточность в Python неэффективной для вычислительных задач, так как потоки работают последовательно.
# Однако потоки полезны для операций ввода-вывода (I/O-bound), таких как работа с файлами, сетевые запросы и т.д.

from threading import Thread

# === Пример работы с потоками ===
def counter_up(name, n):
    """
    Выводит значения от 0 до n-1 с указанием имени потока.
    Аргументы:
    - name (str): имя потока.
    - n (int): число итераций.
    """
    for i in range(n):  # Цикл, выполняющийся n раз
        print(name, i, sep=': ')  # Вывод имени потока и текущего значения

# Создаём два потока
t1 = Thread(target=counter_up, args=('Thread1', 100))  # Поток t1, выполняющий counter_up
t2 = Thread(target=counter_up, args=('Thread2', 100))  # Поток t2, выполняющий counter_up

# Запускаем потоки
t1.start()
t2.start()

# Ожидаем завершения потоков
t1.join()
t2.join()

# --- Ключевые моменты раздела ---
# 1. **GIL**:
#    - Глобальная блокировка интерпретатора позволяет работать только одному потоку с Python-кодом.
#    - Потоки исполняются поочерёдно, что делает их неэффективными для вычислительных задач.
#    - Полезны для ввода-вывода, где работа Python-кода минимальна.
# 2. **Многопоточность**:
#    - Потоки создаются через `Thread` из модуля `threading`.
#    - Используются методы `start()` для запуска и `join()` для ожидания завершения потоков.

# Разделитель между примерами
print("\n" + "=" * 50 + "\n")

# === Раздел 2. Последовательная работа с файлами ===

import datetime  # Для замера времени выполнения
import json  # Для работы с JSON-файлами
from random import randint  # Для генерации случайных чисел

res = []  # Список для хранения данных
files = ['file1.json', 'file2.json', 'file3.json', 'file4.json']  # Список файлов

# Код для генерации файлов с данными (закомментирован после создания файлов):
# for file in files:
#     for _ in range(100_000):  # Генерация 100,000 случайных чисел
#         res.append(randint(0, 10000))
#     with open(file, 'w') as f:  # Запись данных в файл
#         json.dump(res, f)
#     res = []  # Очищаем список для следующего файла

res_to_count = []  # Список для хранения данных из всех файлов
start = datetime.datetime.now()  # Засекаем время начала

for file in files:
    with open(file, 'r') as f:  # Читаем данные из каждого файла
        data = json.load(f)
        res_to_count.extend(data)  # Добавляем данные в общий список

print(sum(res_to_count))  # Вывод суммы всех чисел
end = datetime.datetime.now()  # Засекаем время завершения
print(end - start)  # Вывод времени выполнения

# --- Ключевые моменты раздела ---
# 1. **Последовательная обработка**:
#    - Код читает данные из файлов последовательно, не используя многопоточность.
#    - Это надёжно, но может быть медленным для больших объёмов данных.
# 2. **Работа с файлами**:
#    - Используем модуль `json` для чтения данных.
#    - `datetime` помогает измерить время выполнения.

# Разделитель между примерами
print("\n" + "=" * 50 + "\n")

# === Раздел 3. Многопоточность при работе с файлами ===

# Используем потоки для параллельной обработки данных из файлов.

from threading import Thread

res = []  # Список для хранения данных из всех файлов
threads = []  # Список для хранения потоков
files = ['file1.json', 'file2.json', 'file3.json', 'file4.json']  # Список файлов

def worker(file):
    """
    Читает данные из файла и добавляет их в общий список.
    Аргументы:
    - file (str): имя файла.
    """
    with open(file, 'r') as f:  # Открываем файл для чтения
        js = json.load(f)  # Загружаем данные из файла
        res.extend(js)  # Добавляем данные в общий список

def main():
    """
    Создаёт потоки для чтения данных из файлов и замеряет время их выполнения.
    """
    start = datetime.datetime.now()  # Засекаем время начала
    for i in range(len(files)):
        t = Thread(target=worker, args=(files[i],))  # Создаём поток для файла
        t.start()  # Запускаем поток
        threads.append(t)  # Сохраняем поток в списке
    for t in threads:
        t.join()  # Ожидаем завершения всех потоков
    end = datetime.datetime.now()  # Засекаем время завершения
    sum(res)  # Считаем сумму данных (хотя она не выводится)
    return end - start  # Возвращаем время выполнения

time_calc = []  # Список для хранения времени выполнения каждой итерации

# Замеряем время выполнения main() 100 раз
for i in range(100):
    res = []  # Очищаем список перед каждой итерацией
    time_calc.append(main())  # Добавляем время выполнения в список

# Среднее время выполнения
print(sum([calc.microseconds for calc in time_calc]) / len(time_calc))

# --- Ключевые моменты раздела ---
# 1. **Многопоточность**:
#    - Потоки работают параллельно, читая данные из файлов.
#    - Используется метод `join()`, чтобы основной поток дождался завершения всех потоков.
# 2. **GIL**:
#    - Из-за GIL параллельная обработка в Python ограничена.
#    - Для операций ввода-вывода, таких как работа с файлами, многопоточность всё же может дать улучшение производительности.
# 3. **Замер времени**:
#    - Замеряем время выполнения с помощью `datetime`, усредняя его за 100 итераций для более точного результата.

